{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Cockpitdecks","text":"<p>Cockpitdecks is an application to use decks connected to a computer with a flight simulator software.</p> <p></p> <p>Desktop decks are popular devices to add realism to flight simulation.</p> <p></p> <p>Cockpitdecks currently connects to X-Plane flight simulator. Hooks are ready to connect to other simulators, like Microsoft Flight Simulator.</p> <p>The following make and models of decks have been tested and are known to work with Cockpitdecks:</p> <ul> <li>Elgato Stream Deck (all models work: Small, Mk.2, XL, Plus, and Neo)</li> <li>Loupedeck Loupedeck Live (Loupedeck Live S, Loupedeck+, Loupedeck CT should also work but have not been tested; the LoupedeckLive \u00abclone\u00bb  Razer stream controller also seems to work.)</li> <li>Behringer X-Touch Mini</li> </ul> <p>In addition to above deck devices, Cockpitdecks also provides Web Decks, an emulation of the above decks in a web page, in the context of this application. Yes, you read it, you can now have any of the above deck, reproduced on a tablet, to use with a flight simulator through Cockpitdecks. For free.</p> <p></p> <p>Web decks are not limited to reproducing existing deck models. It is possible to create a custom web decks, out of your imagination, provided it uses common interaction means like push buttons, encoder dials, sliders, and small screens (LCD/LED/TFT) to display images. The demonstration web deck was imagined to show off Cockpitdecks capabilities.</p> <ul> <li>Installation</li> <li>Deck Design</li> <li>Extensions and Developments</li> <li>History</li> </ul>"},{"location":"About/History/","title":"History of Cockpitdecks","text":"<p>The project started from the multiplication of accessory devices. Some are very dedicated and allow for little flexibility. mini\u2022COCKPIT devices or Saitek/Logitec Flight Panels fall into that category. Some other devices are very generic and allow for customizations. Stream decks, Loupedeck devices or other MIDI-based devices fall into this category.</p> <p>I created a single software to allow for the second category of devices to be used with X-Plane. This software relies on conventions to cope with all options and particularities of those devices. That is what I tried to bring into this project.</p> <p>The history of this project explains decisions and processes that were taken to cope with the diversity of devices.</p> <p>A first step was clearly to abstract particularities of device. Pressing keys, rotating knobs or encoders, sliders, touch screens are all different means to interact with some devices. Little iconic display, colored buttons, or multi-led ramps are all different means to communicate feedback to the user. This leads to two abstractions for interaction input (what is called Activation) and feedback output (what is called Representation).</p> <p>A second step was to isolate this software from all device particularities and specificities. This leads to abstractions such as Deck (make, models, device drivers to interact with the device) and Buttons (things a user interact with on a device). A simple abstract model describe the device capabilities and physical organisation (the Deck Type).</p> <p>A final step was to isolate all interactions with flight simulation software: Issuing commands and monitoring data values coming from it. This is done in a collection of specialized Simulator, Variable, and Instruction abstractions.</p> <p>Other entities glue things together with concepts like the Cockpit which is a collection of one or more decks, and a Page that is a grouping of buttons represented at once on a deck.</p> <p>I hope this piece of software will allow you to make a better desktop cockpit and make your flight simulation more enjoyable.</p>"},{"location":"About/History/#see-also","title":"See Also","text":"<p>Bio on X-Plane Forum</p> <p></p> <p>Journey to Cockpitdecks</p>"},{"location":"About/Journey%20to%20Cockpitdecks/","title":"Journey to Cockpitdecks","text":"<p>It started with a standard Stream Deck device. I found it nice to be able to see result of interaction with the deck right away on the deck. Luckily, I found a python langage package to programmatically interact with the device. In particular, the demo allowed to send an image to display on a key. I couldn\u2019t ask for more!</p> <p>I only fly Airbus, so I wanted to see annunciators switches on my deck. On panel at a time.</p> <p>So I started to cut icons from an overhead screen dump. I quickly noticed some repetitive annunciators. But also numerous simple wordings changes. Label above annunciators would also change of course. I did not want to end up with a thousand icons, named by clever convention. So I gave up fairly quickly on image processing and static icons and headed for a mechanism to dynamically create images with words laid over. I elaborated a set of design conventions that resulted in image generation. Annunciators are all very similar, only texts, labels, and colors change. I found a python package (Pillow) to quickly dynamically generate images and used the above demo code to send the image to the stream deck key icon.</p> <p>Convention evolved quickly as I wanted to not only be able to generate annunciators but also switches, rotary knobs, and display some numbers like FCU data, fuel tank levels, battery voltage, etc. All could more or less easily be drawn with the image package I used.</p> <p>Then I discovered the Loupedeck device with encoders and touch screens. I wanted to be able to handle those devices as well. There was no python package to interface, so I created it.</p> <p>I am the happy owner of an inexpensive Behringer X-Touch Mini that I wanted to handle with my development too, even if it was not capable of showing images, it had other LED to communicate. There was no python package to communicate with it. So I created it.</p> <p>This led, one button at a time, one device at a time to what Cockpitdecks is today.</p> <p>One, a gentleman approached me with questions about the configuration of a deck. I was first surprised to discover that somebody else was successfully using my code. But above all, this gentleman who was designing cockpits for other aircrafts needed a way to speed up its development process and suggested rendering decks on screen. This led, in a first iteration in what we called \u00ab\u00a0virtual decks\u00a0\u00bb, but as the screen rendering package used lacked features for interaction and brought in significant complexity, we decided to change for lightweight rendering in a browser window. Virtual decks became web decks (but in the code or wording, both terms still co-exist.) In a nutshell, rather than sending generated images to decks for display on their small LCD screens, we send them to a web page for display on a HTML Canvas. Couldn\u2019t be simpler! (Core code was added in two days.)</p> <p>That, together with numerous code refactoring, abstractions, and conventions, lead to a flexible, configurable, autonomous application that now allow to use common deck models with X-Plane fight simulator. As an illustration of code refactoring, Cockpitdecks was first designed to work with X-Plane only, using X-Plane terminology of Datarefs, Commands, etc. Refactoring brought in a new abstractions for Simulator applications, with neutral generic terminology like Variable and Instruction, and allow now for different simulation software to be used with Cockpitdecks.</p> <p>Cockpitdecks underwent numerous refactoring processes. Some basic, like name changes, some easy, like abstractions (insertion of intermediate often abstract classes), and some heavy (computer value from data with formula). But, through all these changes, the syntax of config.yaml files for buttons rarely changed. Vocabulary get richer because of addition of activations or representations, but older existing definitions kept working with minimal changes. Pages developed two years ago still work surprisingly well after all these internal changes!</p> <p>Everything is created with fun and heart and is freely available for other to enjoy.</p> <p>Later, we added very basic straightforward user interfaces to interactively create buttons on web pages without coding. While the core functions are working as expected, a web user interface specialist could build a friendlier application from the feasibility rough cut we laid over. My knowledge of web user interface faded over time as things were getting highly specialized and refined. I\u2019m sure there is room for a little Svelt or Vue application if someone is tempted by collaborating. (Backend already exists.) This web-based user interface would allow any one to design buttons, button pages and deck layouts to use with any simulation software. Next to that, built in extension mechanism allow developers to bring their own creations to Cockpitdecks.</p>"},{"location":"About/Journey%20to%20Cockpitdecks/#see-also","title":"See Also","text":"<p>History</p> <p></p>"},{"location":"Design/Adding%20a%20Page%20of%20Buttons%20to%20a%20Deck/","title":"Defining buttons","text":"<p>Please follow instructions on Deck Design page to build the correct <code>deckconfig</code> folder structure.</p>"},{"location":"Design/Adding%20a%20Page%20of%20Buttons%20to%20a%20Deck/#add-a-page","title":"Add a Page","text":"<p>Inside the <code>cockpit</code> folder, create a file <code>index.yaml</code>. Insert the following content in the file:</p> <pre><code>buttons:\n  - index: 0\n    label: Map\n    type: push\n    icon: map\n    command: sim/map/show_current\n</code></pre>"},{"location":"Design/Adding%20a%20Page%20of%20Buttons%20to%20a%20Deck/#run","title":"Run","text":"<p>Start X-Plane, load the aircraft where you created your Cockpitdecks configuration folder.</p> <pre><code>$ cockpitdecks-cli --verbose\n</code></pre> <p>Cockpitdecks will start in demonstration mode, and connect to the simulator. Once it is connected to the simulator, it will try to collect the information about the aircraft that is currently loaded. This may take a few seconds. Once Cockpitdecks has the information about the aircraft currently being used, it will search for the <code>deckconfig</code> folder in the folder of the aircraft, and if found, will load the configuration it finds there.</p> <p>If everything worked properly, you should now see the first, upper left button of your deck displaying the Map text.</p>"},{"location":"Design/Adding%20a%20Page%20of%20Buttons%20to%20a%20Deck/#troubleshooting","title":"Troubleshooting","text":"<p>Currently, Cockpitdecks is a application started in a command line shell window. When started with the <code>cockpitdecks-cli</code> command, Cockpitdecks will produce information and warning messages on the shell window. This is the primary source of information to decode what Cockpitdecks do. The most important information is also written into a <code>cockpitdecks.log</code> file.</p>"},{"location":"Design/Adding%20a%20Page%20of%20Buttons%20to%20a%20Deck/#more","title":"More","text":"<p>The above example is simple, yet, everything Cockpitdecks appears in it.</p> <p>Here are a reasonably complex button definitions:</p> <pre><code>  - index: 26\n    name: LANDING LIGHTS\n    label: LAND\n    type: updown\n    commands:\n      - toliss_airbus/lightcommands/LLandLightUp\n      - toliss_airbus/lightcommands/LLandLightDown\n    stops: 2\n    switch:\n      switch-style: 3dot\n      switch-width: 18\n      button-fill-color: black\n      button-underline-width: 4\n      button-underline-color: coral\n      tick-labels:\n        - \"ON\"\n        - \"OFF\"\n      tick-space: 10\n      tick-label-size: 30\n      tick-label-font: DIN Bold\n    options: hexa\n    dataref: AirbusFBW/OHPLightSwitches[4]\n</code></pre> <pre><code>  - index: 0\n    name: ICE WING\n    label: WING\n    type: push\n    command: toliss_airbus/antiicecommands/WingToggle\n    annunciator:\n      model: B\n      size: large\n      B0:\n        text: FAIL\n        color: darkorange\n        dataref: AirbusFBW/OHPLightsATA30[1]\n      B1:\n        text: ON\n        color: deepskyblue\n        framed: true\n        dataref: AirbusFBW/OHPLightsATA30[0]\n</code></pre>"},{"location":"Design/Adding%20a%20Page%20of%20Buttons%20to%20a%20Deck/#references","title":"References","text":"<p>What is a button?</p> <p>More information on available Activations.</p> <p>More information on available Representations</p>"},{"location":"Design/Deck%20Design/","title":"Getting started","text":"<p>The heart of Cockpitdecks is the Deck. A deck is a desktop device with buttons that allow interaction with the computer.</p> <p>Cockpitdecks configuration is the process of telling the computer, or in our case, the simulation software, what to do when buttons are pressed or otherwise manipulated.</p> <p>In return, Cockpitdecks will also display information coming from the simulation software on deck devices that allow it. Some deck devices have simple LED light that can be turned on or off, some more complex devices have small LCD/LED/TFT color screens on keys to display small images.</p> <p>Cockpitdecks allows all this to happen in a highly customizable way through its configuration files.</p> <p>All configuration files are Yaml-formatted files. Yaml is a simple, highly readable structured text file. It allows for comments inside the file, which is very convenient.</p> <p>As an alternative to desktop (physical) decks, Cockpitdecks also offer (virtual) web decks. A Web Deck is a deck run in a browser window. No device necessary. Please head here to discover about Web Decks.</p>"},{"location":"Design/Deck%20Design/#configuration-file-organisation","title":"Configuration File Organisation","text":"<p>All configuration files are grouped into a single folder always named <code>deckconfig</code>. The content of the folder must conform to some conventions.</p> <p>The overall structure of configuration files and folders into the <code>deckconfig</code> folder is as follow:</p> <pre><code>XPlaneAircraftFolder\n  (...)\n  \u22a2 deckconfig\n    config.yaml\n    secret.yaml\n    \u22a2 resources\n      \u22a2 fonts\n      \u22a2 icons\n      \u22a2 sounds\n      \u22a2 ...\n    \u22a2 layout1\n      \u22a2 index.yaml\n      \u22a2 page2.yaml\n      ...\n    \u22a2 layout2\n    ...\n</code></pre>"},{"location":"Design/Deck%20Design/#configyaml","title":"config.yaml","text":"<p>The file named <code>config.yaml</code> directly inside the <code>deckconfig</code> folder is the main configuration file. It lists all decks Cockpitdecks will manage, and global parameters.</p> <p>The main configuration file may be accompanied by a <code>secret.yaml</code> file. This additional file contains the serial number of the deck devices, and is only necessary if there are several decks of the same type, to allow for distinction between them.</p>"},{"location":"Design/Deck%20Design/#resources-folder","title":"resources Folder","text":"<p>The <code>resources</code> folder contains resources used by deck devices. It contains icon images, fonts, sounds, or other parameters.</p> <p>Please refer to the reference documentation for a formal presentation of the <code>resources</code> folder content.</p>"},{"location":"Design/Deck%20Design/#layout-folders","title":"Layout Folders","text":"<p>Layout folders are used to group all things related to one precise deck. In the main configuration file that lists all deck devices that will be used, each deck device must have a layout folder assigned to it. That is where the deck will find its own particular configuration files and be able to determine what it has to do and display when used.</p>"},{"location":"Design/Deck%20Design/#page","title":"Page","text":"<p>The layout folder contains files, called Pages. The name of the file that contains the first Page is <code>index.yaml</code>.</p> <p>It is inside this file that the deck will discover what is has to do and display.</p> <p>Here is the begining of such a index Page:</p> <pre><code>buttons:\n  - index: 0\n    type: push\n    command: sim/view/map_toggle\n    icon: map\n  - ...\n</code></pre> <p>This define that the key (button) at index 0 (top, left) has to issue the command <code>sim/view/map_toggle</code> when pressed, and display the icon image named <code>map</code> on the key.</p> <p>This is a very simple, basic example, but it shows what need to be done to tell each button of each deck what to do and what to display when used with Cockpitdecks.</p>"},{"location":"Design/Deck%20Design/#adding-decks","title":"Adding Decks","text":"<p>The first step is to add decks Cockpitdecks will manage in Cockpitdecks main configuration file:</p> <pre><code>decks:\n  - name: XPLive\n    type: LoupedeckLive\n    layout: cockpit\n    brightness: 100\n</code></pre> <p>Cockpitdecks will manage a LoupedeckLive deck. We will name that deck XPLive when we refer to it. The deck will find its configuration in the layout folder named <code>cockpit</code>.</p> <p>The backlight of the deck will be set to its 100(%) maximum. It could be dimmed to a lower value for night flights.</p>"},{"location":"Design/Deck%20Design/#adding-deck-pages","title":"Adding Deck Pages","text":"<p>Inside <code>deckconfig</code>folder, we create a layout folder named <code>cockpit</code>.</p> <p>Inside that <code>cockpit</code> folder, we create a file named <code>index.yaml</code>.</p> <p>The content of the file defines what the LoupedeckLive deck will do when keys are pressed, or dials turned, and what the deck will need to display in return.</p> <p>Adding a Page of Buttons to a Deck</p>"},{"location":"Design/Demonstration%20Web%20Deck/","title":"Demonstration web deck","text":"<p>When started with no aircraft folder supplied, Cockpitdecks starts a demonstration web deck called Cockpitdecks. It is a 4x3 deck with encoders at the bottom. It demonstrate several of Cockpitdecks capabilities. The definition of the buttons can be used as a basis, as examples, to define yours.</p> <p></p>"},{"location":"Design/Web%20Decks/","title":"Web decks","text":"<p>In addition to real physical decks, Cockpitdecks offers Web Decks rendered in a browser window.</p> <p>Web Decks were first developed as a tool to speed up deck page creation, but Web Decks turned out to be fast and available everywhere, in particular on tablets.</p> <p></p> <p>A Web Deck behaves like their physical counterparts, with limitations inherent to presentation in a browser window. In a nutshell, a web deck has an optional background image (or a uniform background color), and buttons laid over it. Buttons can be of four main types:</p> <ul> <li>Buttons that have an image or iconic representation and that can be pressed,</li> <li>Encoders that can be turned, pushed and pulled,</li> <li>Surfaces that behaves more or less like touchscreens, touched by the mouse pointer,</li> <li>Hardware representation, that are deck-specific images that can be placed to mimic the appearance of the deck, with changing states.</li> </ul> <p>A web deck is added like any other deck.</p> <p>Like its physical counterpart, it first must be named and defined, that is Cockpitdecks must know how many buttons are available, of what type, how can users interact with those buttons, etc.  While this information is sufficient for physical decks, web decks need a little more information to express how buttons, encoders, and touchscreens are positioned on the deck. That is also where we supply a background image.</p> <p>Second, the named web deck need to be added to the list of decks available to an aircraft, in the <code>deckconfig/config.yaml</code> file.</p> <p>If a Web Deck is detected in an aircraft configuration, Cockpitdecks will automagically start a basic web server to present the Web Deck to the user. The index (home) page of the web server will present all web decks available to the user for that aircraft. Selecting on web deck will start it in another browser window.</p> <p>Web decks are very handy to design layout for decks a developer does not necessary owns.</p> <p>Web decks can be (almost) any physical deck represented in Cockpitdecks (most popular brands and models are actually provided with Cockpitdecks), or any next deck model of your fantasy. As an example and proof of concept, Cockpitdecks comes with a fully operational overhead panel for Toliss A321 neo aircraft. Yes, you read it right, you can have Toliss A321 overhead panel on a touch screen or tablet.</p> <p>Web decks that reproduce existing physical decks like Stream Decks and Loupedeck LoupedeckLive are bundled together with their physical counterparts. To use virtual Stream Decks, you must install the streamdeck extension to Cockpitdecks.</p>"},{"location":"Design/Web%20Decks/#web-deck-declaration-and-use","title":"Web Deck Declaration and Use","text":"<p>Virtual decks need to be declared at two places:</p> <ol> <li>Definition of the deck, number of buttons, icon sizes, and layout of buttons. This allows Cockpitdecks to determine the web deck capabilities and key arrangement for drawing, like any other real physical deck.</li> <li>Use of the deck, like any regular deck, with its Layout and is configuring parameters. To use a web deck it must appear in the list of decks in the <code>deckconfig/config.yaml</code> file of an aircraft.</li> </ol> <p>Web Decks communicate with Cockpitdecks through Websockets. A WebSocket proxy server control Interactions between Web Decks and Cockpitdecks.</p>"},{"location":"Design/Web%20Decks/#web-deck-definition","title":"Web Deck Definition","text":"<p>Web decks can be defined at two locations. Cockpitdecks defined a few web decks to help development of physical decks. They are provided with Cockpitdecks and are not meant to be altered by users.</p> <p>However, a cockpit designer may want to add her or his own web deck. To do so, and to prevent adding files to Cockpitdecks source code, it is possible to define additional web deck types in the <code>deckconfig</code> folder of an aircraft.</p> <pre><code>deckconfig\n  \u22a2 resources\n    \u22a2 decks\n\t  \u22a2 types\n\t    \u22a2 custom_deck_type.yaml\n\t \u22a2 images\n\t    \u22a2 custom_background_image.png\n</code></pre> <p>Virtual web decks are defined like any other deck. Their driver must be <code>virtualdeck</code>. They contain  additional attributes to render them on a HTML web Canvas like background image or color.</p> <pre><code>name: Virtual Deck 3\u00d72\ndriver: virtualdeck\nbuttons:\n    - index: 0\n      action: push\n      position: [55, 25]\n      feedback: image\n      image: [96, 96]\n      options: rounded=8\n    - ...\n\nbackground:\n  color: \"#222\"\n  image: loupedeck.live.png\n  size: [800, 600]\n  overlays:\n    - text: Hello, world\n      position: [840, 40]\n      font: anexistingwebfontalreadyloaded\n      size: 20\n      color: white\n    - image: logo-transparent.png\n      position: [840, 40]\n</code></pre> <p>Please refer to the Deck Type for Web Deck for references on how to create and define web decks.</p>"},{"location":"Design/Web%20Decks/#web-deck-usage","title":"Web Deck Usage","text":""},{"location":"Design/Web%20Decks/#web-deck-declaration","title":"Web Deck Declaration","text":"<p>To use a web deck for a given aircraft, it need to be declared in the list of decks available for that aircraft.</p>"},{"location":"Design/Web%20Decks/#deckconfigconfigyaml","title":"<code>deckconfig/config.yaml</code>","text":"<pre><code># Definition of decks for Toliss A321\n#\naicraft: Toliss \ndecks:\n  - name: Vdeck1\n    type: Virtual Deck 3\u00d72\n    layout: devlayout\n</code></pre> <p>The same web deck definition can be used more than once to create similar decks:</p> <pre><code>decks:\n  - name: Vdeck2\n    type: Virtual Deck 3\u00d72\n    layout: test version\n</code></pre> <p>Web decks include their name in the messages they send to Cockpitdecks. This allows Cockpitdecks to identify the deck that sent the message.</p>"},{"location":"Design/Web%20Decks/#deckconfigsecretyaml","title":"<code>deckconfig/secret.yaml</code>","text":"<p>If several web decks are running, it is necessary, like other decks, to specify their serial numbers in the secret.yaml file.</p> <p>Serial Number of Web Decks</p> <p>The serial number of web decks must be specified in the secret.yaml file. It can be any number or string, but it must be different for each web deck.</p> <pre><code>Vdeck1: deck1\nVdeck2: deck2\n</code></pre>"},{"location":"Design/Web%20Decks/#web-deck-application-server","title":"Web Deck Application Server","text":"<p>The Web Deck application server is automagically started when Cockpitdecks starts if there are web decks to serve.</p>"},{"location":"Design/Web%20Decks/#web-deck-list-web-deck-home-page","title":"Web Deck List (Web Deck Home Page)","text":"<p>When started, the web decks server offers a Welcome page with all web decks available to the user. Selecting a deck starts it in another web navigator window.</p> <p></p>"},{"location":"Design/Web%20Decks/#web-deck-example","title":"Web Deck Example","text":"<p>Here is a web deck, carefully designed to represent an existing Elgato Stream Deck MK.2 deck. Cheaper.</p> <p></p>"},{"location":"Design/Web%20Decks/#web-deck-example-complex","title":"Web Deck Example (Complex)","text":"<p>This example shows that there is no limit on background and deck type definition if you are patient and meticulous. Here is a fully working exemple of Toliss A321neo Overhead Panel virtualized with Cockpitdecks.</p>"},{"location":"Design/Web%20Decks/#deck-type","title":"Deck Type","text":"<pre><code>name: Virtual A321neo Overhead\ndriver: virtualdeck\nbuttons:\n  - name: apumaster\n    action: push\n    feedback: image\n    dimension: [40, 40]\n    layout:\n      offset: [560, 855]\n  - name: apustart\n    action: push\n    feedback: image\n    dimension: [40, 40]\n    layout:\n      offset: [560, 918]\nbackground:\n  color: black\n  image: a321neo.overhead.png\n</code></pre>"},{"location":"Design/Web%20Decks/#deckconfigyaml","title":"deckconfig.yaml","text":"<pre><code>decks:\n  -\tname: A321 Overhead\n\ttype: Virtual A321neo Overhead\n\tlayout: overhead\n</code></pre>"},{"location":"Design/Web%20Decks/#overheadindexyaml-page","title":"overhead/index.yaml Page","text":"<pre><code>buttons:\n  - index: apumaster\n    name: APUMASTER\n    type: push\n    annunciator:\n      size: full\n      model: B\n      parts:\n        B1:\n          text: \"ON\"\n          color: deepskyblue\n          framed: true\n          size: 60\n          formula: ${AirbusFBW/APUMaster}\n    command: toliss_airbus/apucommands/MasterToggle\n  - index: apustart\n    name: APUSTART\n    type: push\n    annunciator:\n      size: full\n      model: B\n      parts:\n        B0:\n          text: AVAIL\n          color: lime\n          formula: ${AirbusFBW/APUAvail}\n        B1:\n          text: \"ON\"\n          color: deepskyblue\n          framed: true\n          size: 60\n          formula: ${AirbusFBW/APUStarter}\n    command: toliss_airbus/apucommands/StarterToggle\n</code></pre> <p>Pay attention to the center lower annunciator, lightly white-framed. They are produced by Cockpitdecks and reflect the status of Toliss' annunciators.</p> <p>If buttons have been created for other, physical decks, designing the entire overhead panel is a matter of:</p> <ol> <li>using Deck Designer to spot all annunciators, encoders, buttons, etc. and NAME them.</li> <li>copy/pasting button deck definitions and renaming the button index to the above name.</li> </ol> <p>Nothing more. Nothing less.</p> <p>You can then hang a touchscreen over your head and display the above web page full screen.</p> <p>Cost: 1 touch screen, glue. Protection helmet optional, depending on your trust in the glue.</p> <p>You can consider web decks as live, interactive, responsive images. You can press buttons on the image, Cockpitdecks will adjust the image and its overlays to reflect X-Plane status.</p> <p>Taxi safely.</p>"},{"location":"Design/Web%20Decks/#important-note","title":"Important Note","text":"<p>As explained, Web Deck were originally created has a development tools to speed up button creation and testing. It was suggested by Duane.</p> <p>Once we settle on an architecture, and made critical web-oriented decision (use of HTML Canvas), it took no more that 2 days to get it working! Mainly because of the strict Cockpitdecks architecture and concepts. A few more days were necessary to open up the creation of web decks for Cockpitdecks creators, and imagine Hardware Representation.</p> <p>As today, Cockpitdecks can work with no physical decks, with just Web Decks, even those that replicate existing deck models like Stream Deck and Loupedeck.</p> <p>Please note that web deck lead to Instructions. Currently, Instructions are limited to flight simulation to issue commands, change values, etc. Nothing would prevent a developer from creating Instructions that execute command at the operating system level, like opening a file or starting an application.</p>"},{"location":"Extensions/About%20Extensions/","title":"About Extensions","text":"<p>Cockpitdecks is split into a core package, called <code>cockpitdecks</code>, and optional extension packages.</p> <p>This page lists available extensions. To install and extension, it\u2019s name need to be added to the installation command line.</p>"},{"location":"Extensions/About%20Extensions/#flight-simulator-packages","title":"Flight Simulator Packages","text":"<p><code>cockcpitdecks_xp</code> - xplane: Laminar Research X-Plane flight simulator Extension</p> <p>Title</p> <p><code>cockpitdecks_xp</code> is the name of the development package (python). xplane is the short name of the extension to be used when installing.</p> <p><code>cockpitdecks_fs</code>: Microsoft Flight Simulator Extension</p>"},{"location":"Extensions/About%20Extensions/#deck-device-packages","title":"Deck Device Packages","text":"<p><code>cockpitdecks_bx</code> - xtouch: Extension to interface with Berhinger X-Touch Mini devices</p> <p><code>cockpitdecks_ld</code> - loupedeck: Extension to interface with Loupedeck decks</p> <p><code>cockpitdecks_sd</code> - streamdeck: Extension to interface with Elgato Stream decks</p> <p><code>cockpitdecks_ww</code> - winwing: Extension to interface with Winwing MCDU keyboard and display</p>"},{"location":"Extensions/About%20Extensions/#extensions-packages","title":"Extensions Packages","text":"<p><code>cockpitdecks_wm</code> - weather: Extension to display weather information from sources external to the simulation.</p> <p><code>cockpitdecks_ext</code> - ext: Demonstration extension, mainly for developer, to illustrate extension mechanisms. The proposed extension is a back light dimmer for decks that support back light adjustment.</p>"},{"location":"Extensions/About%20Extensions/#special-purpose-packages","title":"Special Purpose Packages","text":"<p><code>cockpitdecks_tl</code>: Extension for ToLiss Airbus aircrafts simulated in the X-Plane flight simulator.</p>"},{"location":"Extensions/About%20Extensions/#installation-of-packages","title":"Installation of Packages","text":"<p>Packages can be installed be supplying the package name between the <code>[</code> <code>]</code>:</p> <pre><code>pip install 'cockpitdecks[xplane,weather,demoext,streamdeck] @ git+https://github.com/devleaks/cockpitdecks.git'\n</code></pre>"},{"location":"Extensions/Decks/Berhinger/","title":"Berhinger X-Touch Mini","text":"<p>(specifics to be written)</p>"},{"location":"Extensions/Decks/Elgato/","title":"Elgato","text":"<p>(specifics to be written)</p>"},{"location":"Extensions/Decks/Loupedeck/","title":"Loupedeck","text":"<p>(specifics to be written)</p>"},{"location":"Extensions/Others/ToLiss%20Airbus%20Aircrafts/","title":"ToLiss Airbus Aircrafts","text":"<p>(specifics to be written)</p>"},{"location":"Extensions/Others/Weather/","title":"Weather","text":"<p>(specifics to be written)</p>"},{"location":"Extensions/Simulators/Microsoft%20Flight%20Simulator/","title":"Microsoft Flight Simulator","text":"<p>Currently, Cockpitdecks only interface with X-Plane flight simulator. However, hooks are ready to interface Cockpitdecks with other simulation software.</p> <p>To interface a new simulator software with Cockpitdecks, it is necessary to create a Simulator Driver package.</p> <p>Packages like pysimconnect can be used to bridge Cockpitdecks and MSFS. These packages only run on Microsoft Window platform because they require MSFS SDK only available on the MS Window platform. If a developer want to create the MSFS Cockpitdecks plugin for Microsoft Flight Simulator, please contact me.</p>"},{"location":"Extensions/Simulators/X-Plane/Laminar%20Research%20X-Plane/","title":"Laminar Research X Plane","text":"<p>X-Plane is the name of a flight simulation software edited by Laminar Research.</p> <p>For developers, X-Plane offers the following facilities:</p> <ul> <li>A Developer API which consists of library calls to integrate a development inside X-Plane.</li> <li>A network API, which outputs simulator data in UDP packets, and accepts on input some basic instructions to execute named commands, or change simulation internal variables and values.</li> <li>Another network API, a Web REST API to access internal variables and values.</li> <li>Yet another netowkr API, based on WebSocket to access internal variables, issue commands, and get notified of variable changes and command activation.</li> <li>Most, if not all, configuration files are documented text files.</li> </ul> <p>X-Plane maintains and exposes a large number of internal variables, called datarefs. X-Plane. For a running instance of X-Plane, there can be as much as 10,000 datarefs.</p> <p>X-plane also produces a limited number of internal messages to notify of occurence of special events like another plane has been loaded by the user, orr the VR mode has been enabled. X-Plane messages are related to the X-Plane environment and program. There is no message related to the simulation itself. There is no message to tell a plane has taken off, or brought its landing gear down. There are only messages related to the program: New scenery was loaded, new plane was loaded, new sound bank was loaded, X-Plane has crashed (!), etc.</p> <p>Cockpitdecks has two methods to get variable values from X-Plane.</p> <ol> <li>On startup, when a fairly static value needs to be fetched, the (newer) Web REST API is used to get the value of a dataref.</li> <li>The regular method to get values of internal datarefs is a two-step process: First Cockpitdecks notifies X-Plane that it is interested in getting the value of a give dataref, and second, X-Plane sends the value at regular intervals and Cockpitdecks capture the value and interpret it.</li> </ol> <p>Finally, X-Plane externalize a list of commands that can be executed through any of the above API.</p> <p>Since datarefs and commands are sometimes specific to an aircraft, it is advisable to reload and/or somehow reset all variable and command references when loading a new aircraft.</p>"},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Interaction/","title":"X Plane Interaction","text":"<p>The interaction with X-Plane is two folds.</p> <ul> <li>Execution of commands through Activations.</li> <li>Monitor simulator parameter values and enqueue value updates.</li> </ul> <p>But let's first explain how Cockpitdecks connects to X-Plane.</p>"},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Interaction/#x-plane-connector","title":"X-Plane Connector","text":"<p>X-Plane connector through WebSocket uses the following threads of execution to permanently collect dataref values from X-Plane as requested by deck displays.</p>"},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Interaction/#connect-loop","title":"Connect Loop","text":"<p>The connect loop monitors the connection to X-Plane.</p> <p>If there is no connnection, if it cannot connect to X-Plane to submit a command, or if it does not receive any data periodically, the connect loop attempts to connect until it succeeds.</p> <p>When a new connection is established, the websocket message receiver loop is started and enqueues events like value changes and simulator events.</p>"},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Interaction/#activations","title":"Activations","text":"<p>When a button is activated, Cockpitdecks will either submit a command, or ask to change the value of a writable dataref, or both.</p>"},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Interaction/#dataref-value-monitoring","title":"Dataref Value Monitoring","text":"<p>Dataref value monitoring occurs in two steps.</p> <p>First, when a page is loaded in a deck, all dataref it uses and all events it is interested in are registered with the simulator for update.</p> <p>The websocket message receiver loop permanently collects data from X-Plane and generate events for dataref value updates, or when a simulator event of interest occurs.</p> <p>If the loop cannot connect to X-Plane, or if the data collection otherwise fails, a time out occurs.</p> <p>When several times out have occurred, the collection process disconnects and terminates. (There is no need to monitor dataref values if we cannot collect them.) It will be restarted by the connect loop once a new connection is established.</p> <p>The dataref collection loop immediately compare a dataref value with its previous value and enqueues a dataref change event.</p>"},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Observables/","title":"Daytime","text":""},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Observables/#weather-station","title":"Weather Station","text":""},{"location":"Extensions/Simulators/X-Plane/X-Plane%20Observables/#simulator-activity","title":"Simulator Activity","text":""},{"location":"Installation/Installation/","title":"Installation","text":"<p>Cockpitdecks is an autonomous application that runs next to a simulation software. Cockpitdecks can run on the same computer as the simulator software or on another computer connected to it.</p> <p>Cockpitdecks is written in the python language. To run it, python language need to be available on the computer where Cockpitdecks will run. It is recommended to run Cockpitdecks application in its own python environment so that it does not interfere with other python applications.</p> <p></p> <p>Installation requires a few steps to be carried over in order:</p> <ol> <li>Check the requirements</li> <li>Check the simulation software requirements</li> <li>Install Cockpitdecks</li> <li>Optionally start the demonstration (no simulation software necessary) to confirm the proper installation of Cockpitdecks</li> <li>Install configuration files specific to the aircraft you will use</li> <li>Start your simulation software and Cockpitdecks application</li> </ol> <p>At a later stage, you will learn to create your own configuration files, or even extend Cockpitdecks with new components.</p>"},{"location":"Installation/Installation/#requirements","title":"Requirements","text":""},{"location":"Installation/Installation/#hardware-requirements","title":"Hardware Requirements","text":"<p>If you own a desktop deck device, it must be one of these devices:</p> <ul> <li>Elgato Stream Deck (all models work: Small, Mk.2, XL, Plus, and Neo)</li> <li>Loupedeck Loupedeck Live (Loupedeck Live S, Loupedeck+, Loupedeck CT should also work but have not been tested; the LoupedeckLive \u00abclone\u00bb  Razer stream controller also seems to work.)</li> <li>Behringer X-Touch Mini</li> </ul>"},{"location":"Installation/Installation/#software-requirements","title":"Software Requirements","text":"<p>Cockpitdecks is a python application and will run under python 3.12, or newer. Python language need to be installed and available on the host that will run Cockpitdecks. We highly recommend using the latest python release.</p> <p>It is recommended to create a dedicated environment and run Cockpitdecks within that environment.</p>"},{"location":"Installation/Installation/#simulator-sofware-requirement","title":"Simulator Sofware Requirement","text":"<p>Currently, Cockpitdecks only works with Laminar X-Plane simulation software. Here are the requirements for the X-Plane simulator software.</p>"},{"location":"Installation/Installation/#x-plane-version","title":"X-Plane Version","text":"<p>Warning</p> <p>Recent versions of Cockpitdecks (release 15 and above) require version 12.1.4 or later of X-Plane, because Cockpitdecks now exclusively relies on the new X-Plane Web API (release v2 of local Web API, and no longer on UDP). X-Plane Web API considerably simplified communication with the simulator software and made it more reliable. Please make sure you update X-Plane to the latest release before installing and using Cockpitdecks.</p> <p>If you do not upgrade X-Plane to the latest release, this older release may help. Please be aware that this older release will no longer be maintained. It relies on X-Plane UDP API and XPPython3 plugin to circumvent X-Plane UDP API limitations.</p>"},{"location":"Installation/Installation/#enable-x-plane-network","title":"Enable X-Plane Network","text":"<p>Please refer to X-Plane manual to allow for network access to X-Plane.</p> <p>Default behavior as provided with new installations is OK, there is no action necessary.</p>"},{"location":"Installation/Installation/#install-cockpitdecks-application","title":"Install Cockpitdecks Application","text":""},{"location":"Installation/Installation/#install-cockpitdecks-software","title":"Install Cockpitdecks Software","text":"<p>Create a new python environment and activate it. In that environment, issue the installation command:</p> <pre><code>pip install 'cockpitdecks[xplane,weather,demoext,streamdeck] @ git+https://github.com/devleaks/cockpitdecks.git'\n</code></pre>"},{"location":"Installation/Installation/#cockpitdecks-extension-packages","title":"Cockpitdecks Extension Packages","text":"<p>Cockpitdecks is a modular application with extensions. It allows users to only install extensions they require. If you only own Loupedeck devices, there is no need to install Stream Deck or X-Touch Mini extensions.</p> <p>Valid extension packages (placed between the <code>[</code> <code>]</code> in the above installation command, comma separated, no space) are:</p> Extra Content <code>xplane</code> Add X-Plane flight simulator. Mandatory if you want to use it with X-Plane flight simulator. <code>weather</code> Add special iconic representation for weather. These representations fetch information outside of simulation software. For this reason, it is not bundled with Cockpitdecks. <code>toliss</code> Highly specific extension for ToLiss Airbus aircrafts in X-Plane flight simulator. (should work with most Airbus models). Do not install if yo do not own one of those. <code>streamdeck</code> For Elgato Stream Deck devices. <code>loupedeck</code> For Loupedeck LoupedeckLive, LoupedeckLive.s and Loupedeck CT devices. <code>xtouchmini</code> For Berhinger X-Touch Mini devices. <code>demoext</code> Add a few Loupedeck and Stream Deck+ demo extensions. Add a dimmer representation to control the backlight of decks. This extension can be used as a template for creating other extension. <code>development</code> For Cockpitdecks developer only, adds testing packages and python types. Useless if you do not develop Cockpitdecks software."},{"location":"Installation/Installation/#test-cockpitdecks-installation--optional","title":"Test Cockpitdecks Installation \u2014 Optional","text":"<p>After installing Cockpitdecks, it is advisable to start the demonstration. It will ensure that Cockpitdecks works properly.</p> <p>The installation process installs a single command-line instruction called <code>cockpitdecks-cli</code> from which all Cockpitdecks operations can be initiated.</p> <p>To get a glimpse at the possibilities of the client application, issue the following command:</p> <pre><code>cockpitdecks-cli --help\n</code></pre> <p>Parameters and options will be explained later.</p> <p>To start the demonstration, at the command prompt, issue the following command:</p> <pre><code>cockpitdecks-cli --demo\n</code></pre> <p>The demonstration mode does not require a simulator. It provides a single web deck with demonstration interaction.</p> <p></p> <p></p> <p>To exit the demonstration deck, go on the second page, press the guarded button \"STOP\" for two seconds at least to \"lift\" the guard. If the guard was lifted, press again the button to stop.</p>"},{"location":"Installation/Installation/#install-aircraft-configurations","title":"Install Aircraft Configurations","text":"<p>The determine what desktop deck device will do when manipulated, Cockpitdecks reads a set of configuration files. These configuration files change from aircraft to aircraft. There are therefore aircraft specific.</p> <p>Duane, a Cockpitdecks aficionado has realized several configurations for several aircrafts. You can download them from here. For each aircraft type, there will be a folder named <code>deckconfig</code>.</p> <p>For automatic finding of aircraft configuration files, Cockpitdecks expects the <code>deckconfig</code> folder inside the folder of the aircraft being used, like so:</p> <pre><code>&lt;X-Plane 12 Folder&gt;/Aircraft/Extra Airicraft/Toliss A321/deckconfig\n</code></pre> <p>If Cockpitdecks does not find a folder named <code>deckconfig</code> inside the aircraft folder, it will search for configuration files are other locations, and if none is found, it will not load any configuration and only propose the demonstration.</p> <p>Now you are ready to start Cockpitdecks.</p>"},{"location":"Installation/Installation/#running-cockpitdecks-from-a-remote-computer","title":"Running Cockpitdecks from a Remote Computer","text":"<p>Running Cockpitdecks from a Remote Computer</p> <p>This section is for experts only.</p> <p>If you run Cockpitdecks from a remote computer you will need to install a websocket proxy server on the host where X-Plane runs. The reason is that, currently, X-Plane does not allow remote connection to its API. The simplest solution is to setup an <code>nginx</code> web server and make it behave like a HTTP proxy server. The complication will be removed as soon as X-Plane enable its security restriction.</p> <p></p>"},{"location":"Installation/Starting%20Cockpitdecks/","title":"Starting Cockpitdecks","text":""},{"location":"Installation/Starting%20Cockpitdecks/#disconnect-oem-applications","title":"Disconnect OEM Applications","text":"<p>First, you have to completely stop (quit completely) original manufacturer deck configuration applications. They take exclusive access to the device and that prevents Cockpitdecks from finding and using them.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#discover-cockpitdecks-application","title":"Discover Cockpitdecks Application","text":"<p>Cockpitdecks is an application written in a scripting language. It still currently need to be started from a command line prompt.</p> <p>Cockpitdecks only offers a command-line interface to be executed in a shell window.</p> <p>Installation of the Cockpitdecks package in a python environment adds a single command <code>cockpitdecks-cli</code> that can be used to start Cockpitdecks and provide options.</p> <p>Cockpitdecks does it best at starting and finding all components it needs automatically. However, it is possible to explicitely specify a parameter Cockpitdecks would not guess or find.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#command-line-help","title":"Command-Line Help","text":"<p>If always is a good idea to see what the client application offers:</p> <pre><code>$ cockpitdecks-cli --help\nusage: cockpitdecks-cli [-h] [--version] [-v] [-d] [-f] [-w] [-p PACKAGES [PACKAGES ...]] [--template aircraft folder] [--designer] [aircraft_folder]\n  \nStart Cockpitdecks\n  \npositional arguments:\n\u00a0 aircraft_folder \u00a0 \u00a0 \u00a0 aircraft folder for non automatic start\n  \noptions:\n\u00a0 -h, --help\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show this help message and exit\n\u00a0 --version \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 show version information and exit\n\u00a0 -v, --verbose \u00a0 \u00a0 \u00a0 \u00a0 show startup information\n\u00a0 -d, --demo\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 start demo mode\n\u00a0 -f, --fixed \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 does not automatically switch aircraft\n\u00a0 -w, --web \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 open web application in new browser window\n\u00a0 -p PACKAGES [PACKAGES ...], --packages PACKAGES [PACKAGES ...]\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 lookup and load additional packages\n\u00a0 --template aircraft folder\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 create deckconfig and add template files to start\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 in supplied aircraft folder\n\u00a0 --designer\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 start designer\n</code></pre>"},{"location":"Installation/Starting%20Cockpitdecks/#test-cockpitdecks-in-demonstration-mode","title":"Test Cockpitdecks In Demonstration Mode","text":"<p>A second easy step is to start Cockpitdecks in demonstration mode. It will offer a single demonstration web deck. See Demonstration Web Deck for details about the demonstration.</p> <pre><code>cockpitdecks-cli --demo\n</code></pre> <p>In this mode, Cockpitdecks will start a single web deck. Head for the index web page at the following default address:</p> <pre><code>http://127.0.0.1:7777/\n</code></pre> <p></p> <p></p> <p>NoSimulator</p> <p>If no simulator package is loaded, Cockpitdecks will start a dummy, empty simulator connector for its internal use. The above demonstration will be fully functional. Please note that if no specific deck package has been installed, representation specific to a desktop deck device may not appear correctly on the emulated web decks. If streamdeck package has not been installed, streamdeck specific hardware representations won\u2019t be available on web decks.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#start-cockpitdecks-application","title":"Start Cockpitdecks Application","text":"<p>Start Cockpitdecks without any parameter. Cockpitdecks will do its best at guessing what is available on the computer where it runs. Using the <code>--vebose</code> flag will display additional information.</p> <pre><code>$ cockpitdecks-cli --verbose\n</code></pre> <p>Sometimes, or for some complex environment, Cockpitdecks cannot find the information it needs and it will be necessary to supply that information to Cockpitdecks through operating system environment variables.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#environment-variables","title":"Environment Variables","text":"Variable Definiton <code>SIMULATOR_NAME</code> Name of simulator to use. Currently, only X-Plane is a valid value. <code>SIMULATOR_HOME</code> Home directory of X-Plane on the computer where Cockpitdecks runs. If X-Plane is installed on a remote host, <code>SIMULATOR_HOME</code> must be <code>None</code>. <code>SIMULATOR_HOST</code> Hostname or IP address where X-Plane runs. Defaults to local host. <code>APP_HOST</code> Tuple (Hostname or IP address, port) where Cockpitdecks application runs. If specified through operating system environment variables, use (APP_HOST and APP_PORT). Default to (localhost, 7777). <code>API_PORT</code> X-Plane (12.1.1 and above) where REST API runs. Default to <code>8086</code>. <code>API_PATH</code> X-Plane (12.1.1 and above) where REST API: X-Plane API root path. Currently default to <code>/api/v1</code>. <code>COCKPITDECKS_EXTENSION_PATH</code> List of paths where to search for Cockpitdecks extensions <code>COCKPITDECKS_EXTENSION_NAME</code> List of python package names that contains Cockpitdecks extensions <p>In addition, there is an environment variable <code>COCKPITDECKS_PATH</code> that lists folder paths where Cockpitdecks will look for aircraft configurations.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#forced-configuration","title":"Forced Configuration","text":"<p>May be the aircraft loaded in X-Plane has no Cockpitdecks configuration but still, a configuration need to be loaded. The command-line interface can help:</p> <pre><code>cockpitdecks-cli folder-where-there-is-a-config --fixed\n</code></pre> <p>The above command will look for a <code>deckconfig</code> folder in the folder supplied on the command line. The <code>--fixed</code> flag indicates that Cockpitdecks should not try to load another configuration in case the folder loaded (the one supplied on the command line) and the folder of the aircraft used in the simulator do not match.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#command-line-arguments-and-options","title":"Command-Line Arguments and Options","text":"<p><code>--version</code></p> <p>Prints Cockpitdecks version and exits.</p> <p><code>--verbose</code></p> <p>Prints additional information when executed.</p> <p><code>--demo</code></p> <p>Starts Cockpitdecks in demonstration mode.</p> <p><code>--fixed</code></p> <p>Loads an initial aircraft configuration and does not change it, even if loading of a new aircraft is detected.</p> <p><code>--web</code></p> <p>Open the default web browser and show available web decks.</p> <p>`\u2013template aircraft folder</p> <p>Creates <code>deckconfig</code> folder in the supplied aircraft folder and create necessary minimal files from which a new configuration can be created.</p> <p>If a <code>deckconfig</code>folder already exists in the supplied aircraft folder, no template is installed.</p> <p><code>--packages PACKAGE [PACKAGE..]</code></p> <p>Search and load supplied extension packages on startup. Mainly used for development purposee.</p> <p><code>--designer</code></p> <p>Starts the web deck designer (expert only).</p>"},{"location":"Installation/Starting%20Cockpitdecks/#troubleshooting","title":"Troubleshooting","text":"<p>Cockpitdecks creates a <code>cockpitdecks.log</code> files with more information in the directory you started Cockpitdecks from.</p> <p>The level of information produced in the file is controlled by the logging level parameter. (info=some information and warnings, debug=a lot of information for debugging purpose, your XPPython3.log file may grow quite large.) The parameter is available at the global plugin level (the entire plugin will report all messages), or can be set at a Cockpitdecks internal module level to pin point issues.</p> <p>Cockpitdecks is stateless. If we except its internal statistics, Cockpitdecks does not maintain any state variable of a situation. Therefore, at any time, it is possible to stop and restart it. Should a problem persists, please file an issue on Github with necessary information to reproduce it.</p>"},{"location":"Installation/Starting%20Cockpitdecks/#termination","title":"Termination","text":"<p>To terminate Cockpitdecks, press a single Ctrl+C to stop Cockpitdecks client application.</p> <p>Cockpitdecks is designed to terminates cleanly. All requested datarefs monitoring are cancelled, connections are closed, all threads are terminated and joined cleanly. However, it may sometimes take a few seconds before a thread terminates. For example, if a thread is meant to run every 30 seconds, it may be necessary to wait a full 30 seconds before the thread notices the termination request and quits. Longer threads (above 30 seconds or a minute) check periodically for termination request. Cockpitdecks should always terminate cleanly to release resources it controls from the simulator.</p> <p>If necessary, there is an activation that can be assigned to a button to stop Cockpitdecks.</p> <p>If necessary, or blocked, pressing Ctrl+C several time in the main window will stop Cockpitdecks completely right away.</p>"},{"location":"Reference/Activations/","title":"Activations","text":"<p>In the definition of the button, the <code>type</code> attribute determine what the button will do.</p> <p>For a given button on a deck, the action that the button will be able to carry over is limited to a set of valid types. A push button is not capable of rotations of an encoder.</p> <p>On the other hand, a button that can be pressed can offer different types of usage: simple press, long, continuous press, emulation of rotation switch\u2026 all this can be activated from a button with a simple press capability.</p> <p>When interaction occurs on a button on a deck, Cockpitdecks creates a typed Event, and passes it for activation.</p> <p>Each activation is designed to handle one or more Events types. For example a EncoderPush activation is capable of handling both PressEvent and EncoderEvent. What is does with those event is left to the activation.</p> <p>This file list all activations that are currently available in Cockpitdecks. For each activation, we present its name or keyword by which it must be referred to, the attributes it expects to work properly, the type of events it expects, and internal state values it produces and maintains.</p> <ul> <li>Activations#No Activation</li> <li>Activations#Page</li> <li>Activations#Push</li> <li>Activations#ShortOrLongpress</li> <li>Activations#OnOff</li> <li>Activations#UpDown</li> <li>Activations#Encoder</li> <li>Activations#EncoderPush</li> <li>Activations#EncoderOnOff</li> <li>Activations#EncoderLongPush</li> <li>Activations#EncoderValue</li> <li>Activations#Slider</li> <li>Activations#Swipe</li> </ul>"},{"location":"Reference/Activations/#activation-steps","title":"Activation Steps","text":"<p>Each activation always goes through 3 steps.</p> <p>First, the event is handled completely. Most of the time, the root class of activations is activated first, for global handling and checks. Then the activation itself is performed. The activation returns a boolean flag to indicate that it completed successfully.</p> <p>Second, if the activation produces a value, it is written to the <code>set-dataref</code> of the button, if any. This operation can be considered like an second instruction that is performed provided that the button instructed to write the value to the dataref pointed by <code>set-dataref</code>.</p> <p>Third, and finally, if the button activation contains a <code>view</code> command, it is executed. The purpose of the view command if to alter the view in the cockpit, may be to focus on a particular area of the dashboard to control the effect of the activation.</p>"},{"location":"Reference/Activations/#command-commands-and-macro-instruction","title":"Command, Commands, and \u00abMacro Instruction\u00bb","text":"<p>When specifying attributes for an activation <code>command</code> and <code>commands</code> attributes can be requested. A <code>command</code> is a single command, <code>commands</code> is a list of individual commands, often, the number of commands in the list matters and match the Activation requirements.</p> <p>A <code>command</code> can be:</p> <ul> <li>a single string naming the command to execute, or</li> <li>a single command block, with a condition and or a delay, or</li> <li>a Macro Instruction, that can contain one or more command blocks.</li> </ul>"},{"location":"Reference/Activations/#single-command-string","title":"Single Command String","text":"<pre><code>    command: sim/map/show_current\n</code></pre>"},{"location":"Reference/Activations/#command-to-change-variable","title":"Command to Change Variable","text":"<pre><code>    set-dataref: AirbusFBW/DUBrightness[0]\n</code></pre> <p>While it does not appear as a command, the above instruction is actually a command to set the value pointed by the <code>set-dataref</code> variable to the value of the button.</p>"},{"location":"Reference/Activations/#single-command-block","title":"Single Command Block","text":"<p>A Command Block is a series of attributes that specify a command to execute and some optional behavior.</p> <pre><code>\tcommand:\n\t  - set-dataref: sim/value/to/set\n\t    condition: ${sim/position/altitude} 5000 &gt;\n\t    delay: 5\n</code></pre> <p>The group of attributes <code>set-dataref</code>, <code>condition</code>, <code>delay</code> is a command block. It is one instruction (<code>set-dataref</code>), a condition to satisfy before executing the instruction, and a delay to wait after the condition is satisfied before executing the command.</p> <p>The condition is evaluated each time one of its parameter changes.</p>"},{"location":"Reference/Activations/#command-block-attributes","title":"Command Block Attributes","text":""},{"location":"Reference/Activations/#command","title":"Command","text":"<p>There are currently two attributes that can be used to specify a command to execute:</p> <ul> <li><code>command</code></li> <li><code>set-dataref</code></li> </ul> <p>Either one can be used but not both. (If both are specified, a warning is issued and the command is ignored.)</p>"},{"location":"Reference/Activations/#condition","title":"Condition","text":"<p>A condition is a formula that specify, when evaluated, if the command can be executed. The condition is evaluated each time one of its constituting simulator value changes.</p>"},{"location":"Reference/Activations/#delay","title":"Delay","text":"<p>The delay is a value in seconds that specifies how long after the command receives its instruction to execute it actually perform the task. This allows to pause between commands rather than submitting them all simultaneously to the target. The delay starts when the previous command is submitted for execution.</p>"},{"location":"Reference/Activations/#multiple-command-blocks-macro-instruction","title":"Multiple Command Blocks: Macro Instruction","text":"<pre><code>    command:\n      - command: AirbusFBW/MCDU1Menu\n      - command: AirbusFBW/MCDU1LSK6L\n        delay: 1\n      - command: AirbusFBW/MCDU1LSK6R\n        delay: 1\n      - command: AirbusFBW/MCDU1LSK1R\n        delay: 1\n</code></pre> <p>In the above example, the single command consists of a series of 4 command blocks. In this case, the single command is called a Macro Instruction.</p> <p>Since delay starts after the previous command is started, the command <code>AirbusFBW/MCDU1LSK1R</code> will be executed 1 second after <code>AirbusFBW/MCDU1LSK6R</code> command is started, 3 seconds after command <code>AirbusFBW/MCDU1Menu</code> is started.</p>"},{"location":"Reference/Activations/#no-activation","title":"No Activation","text":"<p><code>type: none</code></p> <p>Button with no activation are button used for display purpose only.</p>"},{"location":"Reference/Activations/#events","title":"Events","text":"<p>Any event can be handed over to the No Activation, since it will not be used.</p>"},{"location":"Reference/Activations/#state-values","title":"State Values","text":"State Variable Value <code>activation_count</code> Number of time button was activated <code>last_activated</code> Time stamp of last activation <code>initial_value</code> Initial value in configuration (if any) <code>current_value</code> Button current value <code>previous_value</code> Button previous value before change <code>guarded</code> Whether button has a guard on top of it <code>managed</code> Whether button has managed mode (specific to some cockpits, which means there are alternate display values)"},{"location":"Reference/Activations/#activation-value","title":"Activation Value","text":"<p>Among the above State Value that an Activation returns, there always is a special state value named the activation value. The activation value can be accessed by requesting the <code>activation_value</code> attribute in the state values.</p> <p>This value is just a value among the existing state values that gets highlighted because it is the most sensible value used by the activation.</p> <p>For exemple, the activation value for the On/Off activation is the current state of the activation, either On or Off.</p> <p>In the following descriptions, the activation value is highlighted for each activation.</p> <p>For No Activation activation, the activation value is equal to the activation count. This is also the \"default\" activation value, if nothing more precise is returned, the activation value is the number of activation of that button.</p> <p>The activation value comes to play when the button needs to determine its value. It first look for a formula, then a single dataref, and if there is no formula and no single dataref, the activation value is used.</p>"},{"location":"Reference/Activations/#page","title":"Page","text":"<p><code>type: page</code></p> <p>When the button is pressed, a deck will load a page of buttons.</p>"},{"location":"Reference/Activations/#attributes","title":"Attributes","text":"Attribute Definition <code>page</code> Mandatory. Name of the page to load. The page must be in the Layout of the target deck. <code>remote_deck</code> Optional. If present, will load the page on the target deck."},{"location":"Reference/Activations/#events_1","title":"Events","text":"<p><code>PushEvent</code> and <code>PressEvent</code> can trigger the Page activation.</p>"},{"location":"Reference/Activations/#state-values_1","title":"State Values","text":"Attribute Definition <code>page</code> page that is currently displayed"},{"location":"Reference/Activations/#theme","title":"Theme","text":"<p><code>type: theme</code></p> <p>When the button is pressed, the main theme will be changed.</p>"},{"location":"Reference/Activations/#attributes_1","title":"Attributes","text":"Attribute Definition <code>theme</code> Mandatory. Name of theme."},{"location":"Reference/Activations/#events_2","title":"Events","text":"<p><code>PushEvent</code> and <code>PressEvent</code> can trigger the Page activation.</p>"},{"location":"Reference/Activations/#push","title":"Push","text":"<p><code>type: push</code></p> <p>Push button.</p>"},{"location":"Reference/Activations/#attributes_2","title":"Attributes","text":"Attribute Definition <code>command</code> Mandatory. X-Plane command that is executed each time the button is pressed. <p>Note</p> <p>Command is a mandatory parameter but if no command is necessary a command placeholder value can be used. Command placeholder value are any of the following string: <code>none, noop, no-operation, no-command, do-nothing</code> They all are ignored and do not trigger any activity in X-Plane.</p>"},{"location":"Reference/Activations/#events_3","title":"Events","text":"<p>PushEvent. Please note that PushEvent consists of 2 distinct events, a pressed event (PushEvent with pressed = True), and a release event (PushEvent with pressed = False), when the button is pressed or released respectively.</p>"},{"location":"Reference/Activations/#options","title":"Options","text":"Option Definition <code>auto-repeat</code> Auto repeat command at specified pace while the button remains pressed.<code>auto-repeat</code> option accepts a couple of optional values:- <code>delay</code>: Time (in second) after which the auto-repeat starts, default to 1 second.- <code>speed</code>: Time (in second) between 2 executions of the command. <pre><code>\toptions: auto-repeat=3/0.5,dot\n</code></pre> <p>Auto-repeat will start 3 second after the button was pressed, the command will auto-repeat every 0.5 seconds, twice per second. (<code>dot</code> option also set for other purpose.)</p>"},{"location":"Reference/Activations/#beginendpress","title":"BeginEndPress","text":"<p><code>type: begin-end-command</code></p> <p>Push button that will carry the command as long as the button will remain pressed.</p> <p>Long press command should not be confused with auto-repeat commands. A BeginEndPress command in one command that is executed once as long as the button remain pressed. An auto-repeat command is the same command that is executed several times at regular interval (typically once every 0.2 seconds, 5 times per second) as long as the button is pressed.</p> <p>Note</p> <p>The BeginEndPress command requires installation of a XPPYthon3 plugin in X-Plane to circumvent a few X-Plane UDP limitations.</p>"},{"location":"Reference/Activations/#events_4","title":"Events","text":"<p>PushEvent</p> <p>Only PushEvent can be used to trigger BeginEndPress Activation since both press and release events are necessary to estimate the timing between both events.</p>"},{"location":"Reference/Activations/#attributes_3","title":"Attributes","text":"Attribute Definition <code>command</code> Mandatory. X-Plane command that is executed each time the button is pressed. <p>X-Plane will issue a <code>beginCommand</code> when the button is pressed and a <code>endCommand</code> when released.</p> <p>Note</p> <p>Please note that the use of longpress command needs the addition of a little plugin to circumvent X-Plane UDP limitations when used through UDP.</p>"},{"location":"Reference/Activations/#onoff","title":"OnOff","text":"<p><code>type: onoff</code></p> <p>Push button.</p>"},{"location":"Reference/Activations/#events_5","title":"Events","text":"<p>PushEvent, PressEvent, LongPressEvent</p>"},{"location":"Reference/Activations/#attributes_4","title":"Attributes","text":"Attribute Definition <code>commands</code> Optional pair of X-Plane commands that are executed alternatively. Two commands must be supplied, but the same command can be provided twice. <code>set-dataref</code> Optional dataref to set On(=1) or Off (=0).Either attribute can be set or both. In the latter case, the command is first executed and then the dataref is set."},{"location":"Reference/Activations/#state-values_2","title":"State Values","text":"Attribute Definition <code>on</code> current state On or Off"},{"location":"Reference/Activations/#activation-value_1","title":"Activation Value","text":"<p>The activation value for On/Off activation is the current status, either On or Off.</p>"},{"location":"Reference/Activations/#updown","title":"UpDown","text":"<p><code>type: updown</code></p> <p>Cycle Up and Down button.</p>"},{"location":"Reference/Activations/#attributes_5","title":"Attributes","text":"Attribute Definition <code>commands</code> X-Plane commands that are executed when pushes increase value, and when pushes descrease value. <code>stops=3</code> Number of stop values. For example: Stops=3 will give 0-1-2-1-0 cycles, with 3 stops 0, 1, and 2. <code>initial-value</code> If an initial value is supplied, it's sign indicated how the value will evolve.For example, if the initial value is 1, the next value will be 2 (go up). If the initial value is -1, the initial value will be set to 1, but the next value will be zero (go down). <code>set-dataref</code> Optional dataref to set the value of the current stop.Very much like On/Off activation either <code>commands</code> or <code>set-dataref</code> can be supplied or both. <p>The number of supplied commands may vary.</p> <p>If no command is supplied, it is assumed that there is a <code>set-dataref</code> instruction. In this case, the activation runs inside the <code>[0, #stops[</code> interval and writes the current value to the dataref.</p> <p>If two commands are supplied, they are assumed to be commands to go up and go down when cycling between the values.</p> <p>If the number of commands is equal to the number of stops, and if there are more than 3 stops, then the activation runs inside the <code>[0, #stops[</code> interval and executes the command corresponding to the current value.</p>"},{"location":"Reference/Activations/#activation-value_2","title":"Activation Value","text":"<p>The activation value for UpDown activation is the current value.</p>"},{"location":"Reference/Activations/#state-values_3","title":"State Values","text":"Attribute Definition <code>stops</code> Number of stops <code>go_up</code> True will increase at next push; False will decrease <code>stop</code> Current value"},{"location":"Reference/Activations/#shortorlongpress","title":"ShortOrLongpress","text":"<p>Short or long press has two commands, one that is executed when the button is pressed for less than <code>long-time</code> seconds, and one when it is pressed more than <code>long-time</code> seconds.</p> <p><code>type</code>: short-or-longpress</p>"},{"location":"Reference/Activations/#attributes_6","title":"Attributes","text":"Attribute Definition <code>commands</code> Two commands, the first one is called on short press. <code>long-time</code> Time to press the button to activate second command. Default to 2 seconds."},{"location":"Reference/Activations/#encoder","title":"Encoder","text":"<p><code>Type: encoder</code></p> <p>An Encoder is a rotating knob or dial with steps. Steps are often materialised by a little sound or a slight resistance in the rotation.</p>"},{"location":"Reference/Activations/#attributes_7","title":"Attributes","text":"Attribute Definition <code>commands</code> An Encoder has two commands, one that is executed for each step while turning clockwise, and one for each step when turning counter-clockwise."},{"location":"Reference/Activations/#state-values_4","title":"State Values","text":"State Definition <code>rotation_clockwise</code> number of times/clicks the encoder was turned clockwise. <code>rotation_counterclockwise</code> same."},{"location":"Reference/Activations/#activation-value_3","title":"Activation Value","text":"<p>The activation value for Encoder activation is the current rotation value, i.e. number of rotation clockwise minus number of rotation counter-clockwise, negative values means there are more counter clockwise turns.</p>"},{"location":"Reference/Activations/#encoderpush","title":"EncoderPush","text":"<p><code>type: encoder-push</code></p> <p>An EncoderPush is the combination of an Encoder and a push button.</p>"},{"location":"Reference/Activations/#attributes_8","title":"Attributes","text":"Attribute Definition <code>commands</code> An EncoderPush has 3 commands:1. First command gets executed when it is pushed2. Second command gets executed when encoder is turned clockwise3. Third command gets executed when encoder is turned counterclockwise"},{"location":"Reference/Activations/#state-values_5","title":"State Values","text":"State Definition <code>turns</code> Number of turns, positive is clockwise <code>cw</code> number of times/clicks the encoder was turned clockwise. <code>ccw</code> same, counter clockwise."},{"location":"Reference/Activations/#activation-value_4","title":"Activation Value","text":"<p>Same as Encoder activation.</p>"},{"location":"Reference/Activations/#encoderonoff","title":"EncoderOnOff","text":"<p><code>type: encoder-push</code></p> <p>An EncoderOnOff is the combination of an Encoder and an OnOff button.</p>"},{"location":"Reference/Activations/#attributes_9","title":"Attributes","text":"Attribute Definition <code>commands</code> An EncoderPush has 4 commands:1. First command gets executed when it is OFF, to turn it ON2. Second command gets executed when it is ON, to turn it OFF3. Third command gets executed when encoder is turned clockwise4. Fourth command gets executed when encoder is turned counterclockwise"},{"location":"Reference/Activations/#options_1","title":"Options","text":"Attribute Definition <code>dual</code> With option <code>dual</code>, the activation uses two more commands.1. First command gets executed when it is OFF, to turn it ON2. Second command gets executed when it is ON, to turn it OFF3. Third command gets executed when encoder is turned clockwise and ON4. Fourth command gets executed when encoder is turned counterclockwise and ON5. Third command gets executed when encoder is turned clockwise and OFF6. Fourth command gets executed when encoder is turned counterclockwise and OFF."},{"location":"Reference/Activations/#state-values_6","title":"State Values","text":"State Definition <code>cw</code> number of times/clicks the encoder was turned clockwise. <code>ccw</code> same. <code>on</code> Is currently On or Off"},{"location":"Reference/Activations/#activation-value_5","title":"Activation Value","text":"<p>Same as Encoder activation.</p>"},{"location":"Reference/Activations/#encoderlongpush","title":"EncoderLongPush","text":"<p>A combination of pushing and turning.</p>"},{"location":"Reference/Activations/#attributes_10","title":"Attributes","text":"Attribute Definition <code>commands</code> An EncoderLongPush has 4 commands:1. First command  gets executed when encoder is turned clockwise2. Second command gets executed when encoder is turned counterclockwise3. Third command gets executed when encoder is first pushed, then turned clockwise4. Fourth command gets executed when encoder is first pushed, then turned counterclockwise"},{"location":"Reference/Activations/#state-values_7","title":"State Values","text":"State Definition <code>cw</code> number of times/clicks the encoder was turned clockwise. <code>ccw</code> same."},{"location":"Reference/Activations/#activation-value_6","title":"Activation Value","text":"<p>Same as Encoder activation.</p>"},{"location":"Reference/Activations/#encodervalue","title":"EncoderValue","text":"<p><code>type: encoder-push</code></p> <p>An EncoderValue is an Encoder that increases or decrease an internal value each time it is rotated clockwise or counterclockwise. The value can be written to an X-Plane dataref or used for other pruposes.</p>"},{"location":"Reference/Activations/#attributes_11","title":"Attributes","text":"Attribute Definition <code>initial-value</code> Initial value. Default to 0. <code>step</code> Amount of value increase or decrease. <code>stepxl</code> Alternate value for step increase or decrease. If the encoder is capable of push action, the push action will switch between the <code>step</code> and <code>stepxl</code> values. <code>min</code> Minimal value. <code>max</code> Maximal value. <code>formula</code> Optional. Formula to transform the <code>${state:button-value}</code> before it is sent to the dataref. <code>set-dataref</code> Optional dataref to set to the value of the computed value. The value is sent right away, after each encoder activation."},{"location":"Reference/Activations/#state-values_8","title":"State Values","text":"State Definition <code>cw</code> number of times/clicks the encoder was turned clockwise. <code>ccw</code> same. <code>value</code> Current raw value"},{"location":"Reference/Activations/#activation-value_7","title":"Activation Value","text":"<p>The activation value of the EncoderValue activation is the computed value of the encoder.</p>"},{"location":"Reference/Activations/#slider","title":"Slider","text":"<p><code>type: slider</code></p> <p>A Slider is a one dimensional cursor that produces a continuous value within a range. The value can be written to an X-Plane dataref, directly, or after a computation.</p>"},{"location":"Reference/Activations/#attributes_12","title":"Attributes","text":"Attribute Definition <code>set-dataref</code> Optional. Dataref to write the value to, if present. <code>formula</code> Optional. Formula to transform the <code>${state:button-value}</code> (value produced by the slider) before it is sent to the dataref."},{"location":"Reference/Activations/#state-values_9","title":"State Values","text":"State Definition <code>value</code> Current raw value"},{"location":"Reference/Activations/#activation-value_8","title":"Activation Value","text":"<p>The activation value of the Slider activation is the  value of the slider.</p>"},{"location":"Reference/Activations/#swipe","title":"Swipe","text":"<p><code>type: swipe</code></p> <p>A Swipe is a 2 dimensional movement of a finger on a surface. The event produced consists of the start and end positions of the finger relative to the surface (x, y) and timing information (time stamp).</p> <p>(Currently not used.)</p> <p>The Swipe event has no attribute.</p>"},{"location":"Reference/Activations/#state-values_10","title":"State Values","text":"<p>The event of a swipe is complex. The entire event is available as <code>last_event</code>.</p> <p>The event has the following structure:</p> <pre><code>ts_start: 123.456\nts_end: 135.246\npos_start: (23, 48)\npos_end: (78, 42)\n</code></pre>"},{"location":"Reference/Activations/#state-values_11","title":"State Values","text":"State Definition <code>start_x</code> Start of swipe position laterally <code>start_y</code> Start of swipe position vertically <code>start_ts</code> Timestamp of start of swipe, in microseconds <code>end_x</code> End of swipe position laterally <code>end_y</code> End of swipe position vertically <code>end_ts</code> Timestamp of end of swipe, in microseconds <p>From the above values, with some tolerence, it is possible to determine whether the finger moved on the surface or not (swipe or touch), and to determine the duration of the contact with the surface.</p>"},{"location":"Reference/Activations/#button-activations-for-developers","title":"Button Activations for Developers","text":"<p>Reload, Stop, or Inspect are special activations for developer.</p> <p>These activations are normally not used during regular operations.</p>"},{"location":"Reference/Activations/#new-activations","title":"New Activations","text":"<p>It always is possible to create new activations by extending Cockpitdecks.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/","title":"Attribute Default Values","text":"<p>Buttons are defined by a list of attributes.</p> <p>Some attributes are unique to a button, very specific, and cannot have default values like, for exemple, the button index or a button label attribute.</p> <p>Some other attributes are used by numerous buttons, like for example the color of the label. These common attributes benefit from a sophisticated default value lookup.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#attribute-hierarchical-lookup","title":"Attribute Hierarchical Lookup","text":"<p>Before we can look up at the attribute evaluation method, we must notice that all objects we manipulate in Cockpitdecks are organized in a hierarchical way.</p> <ol> <li>A the highest, top level sits the Cockpit.</li> <li>The Cockpit holds all Decks available to the simulator.</li> <li>Each Deck uses a Layout</li> <li>Each Layout has one or more Pages</li> <li>Each Page can include other Pages</li> <li>Each Page contains all Buttons definitions.</li> </ol> <p>This hierarchy is very important.</p> <p>As an example, let us find the value of the <code>label-color</code>.</p> <p>First, the button will perform a direct lookup in its attribute. If it finds a  <code>label-color</code> in its attribute, it will use it. If it does not find it, it will ask for its <code>default-label-color</code>. The button will ask its parent entity for the <code>default-label-color</code>.</p> <p>So the Page will search for a <code>default-label-color</code> in its attributes. If it finds it, it will use it. If it does not find it, it ask its parent entity.</p> <p>The Deck will search for a <code>default-label-color</code> in its attributes. If it finds it, it will use it. If it does not find it, it ask its parent entity.</p> <p>Finally, the Cockpit will return a <code>default-label-color</code>. If there is no value for the <code>default-label-color</code>, Cockpitdecks will issue an error. It simply means that there is no default value for that attribute and that a value must be supplied by the user in the definition of the button.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#theme","title":"Theme","text":"<p>Cockpitdecks introduced the concept of color schemes or Themes. A theme is an additional parameter (string) that is added to the attribute name being looked up. Let us see in a practical example.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#day-or-night-theme","title":"Day or Night Theme","text":"<p>Cockpitdecks attempts to provide a day and a night theme. The attribute <code>cockpit</code> can be set to <code>day</code> (or <code>light</code>) or <code>night</code>(or <code>dark</code>) to specify which theme to use.</p> <pre><code>cockpit-theme: dark\n</code></pre> <p>The effect is that in <code>night</code> (or <code>dark</code>) theme, default values prefixed with <code>dark-</code> will be favored. If no default value prefixed with <code>dark-</code> is found, the regular default value is fetched.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#example-for-label-color","title":"Example for label color","text":"<p>If the theme <code>dark</code> is defined, the attribute <code>dark-default-label-color</code> is first searched, and if not defined, the <code>default-label-color</code> is retuned.</p> <p>The word <code>dark</code> is arbitrary. It can be any string. But the attribute named <code>&lt;any-string&gt;-default-label-color</code> will be searched first, and if not found <code>default-label-color</code> will be used.</p> <p>Note</p> <p>Ultimately, this scheme can be extended to any theme name value, like airbus, or barbie. However, it is advisable to limit theme default values to global appearance parameters like colors, fonts, textures, and sizes.</p> <p>There is no automatic theme switch, but a special activation allows for theme setting.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#configuration-files","title":"Configuration Files","text":"<p>Cockpitdecks behavior and deck appearance are driven by a list of Yaml config action files always called <code>config.yaml</code>.</p> <ol> <li>Cockpitdecks internals (cannot be modified)</li> <li>Global configuration file: Cockpitdecks/resources/config.yaml (cannot be modified)</li> <li>Aircraft configuration file: Aircraft/deckconfig/config.yaml</li> <li>Layout configuration file: Aircraft/deckconfig/layout1/config.yaml</li> <li>Page configuration file: Aircraft/deckconfig/layout1/page1.yaml</li> </ol> <p>Sometimes, configuration values can be specified at different level for a given entity.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#cockpitdecks-application-cockpits","title":"Cockpitdecks (Application), Cockpits","text":"<p>At the highest level, a Cockpit will start with a set of default values provided in its internal code.</p> <p>It will then loads additional parameters in a global resource configuration file. That file is the same for ALL aircrafts. The config.yaml file is located in the home directory of Cockpitdecks software, in the resources folder. It cannot be changed.</p> <p>Next, Cockpitdecks will look for an aircraft specific configuration file, in the  deckconfig folder of that aircraft. It will load the config.yaml file of that aircraft, and default values loaded from there will apply to that aircraft only. That configuration file can be used for cockpit designer to specify their requirements and preferences.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#decks-and-layouts","title":"Decks and Layouts","text":"<p>A Deck will start with the configuration attributes supplied by the Cockpit. The Cockpit uses the configuration passed in the the global, aircraft-level configuration file.</p> <p>A deck will load a Layout. When doing so, the deck may read an optional configuration file located in the folder of the Layout it will use. The attributes specified in the layout configuration file will take precedence over those at the deck level.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#pages-and-includes","title":"Pages and Includes","text":"<p>In addition to button definitions, a Page contains other page-level attributes.</p> <p>When a page includes another page, their respective attributes get melted (combined). The attributes of the included page overwrite the attributes of the base page.</p> <p>Since a page can include more than one other page, the attributes of the included page are added (on top of) the attribute of the base page and other included pages. But since the order of page inclusion is not specified, attributes may be piled up in any order.</p> <p>In other words, it is advisable to not include any page-level attribute in a page that will be included in another page, it may lead to unexpected behavior or presentation. It is safer to limit inclusion to the <code>buttons</code> attribute, where buttons of main page and included page are merged together.</p>"},{"location":"Reference/Button%20Attribute%20Default%20Values/#summary","title":"Summary","text":"<p>Here is an example how attribute value is looked up for a button's <code>bg-color</code>.</p> <p></p>"},{"location":"Reference/Button%20Value/","title":"Value","text":"<p>A button builds its representation from its value. The value of the button is computed from one or more dataref values returned by X-Plane and/or from some internal state variable values.</p> <p>A Button can have 0, 1, or more than one value in the special case of annunciators or Mosaic  (A Mosaic  can have two or more buttons represented inside.). Each annunciator part or each button inside a Mosaic has either 0, or 1 value.</p> <p>Each value of a button is either None (no value) or a numeric value (which is most of the time a floating point number). If a button has several values, its value is either a list of values or a dictionary of all individual values, each individual value being None or a number.</p> <p>Activations and Representations of the button knows how to manage the different values contained in the annunciator or Mosaic.</p>"},{"location":"Reference/Button%20Value/#x-plane-datarefs","title":"X-Plane Datarefs","text":"<p>A dataref is the name of a value used by the X-Plane simulator.</p> <p>The value can be a string, integer, or float value, either a single value or an array of (same type of) values. A dataref has a name to access it. Names are organized in a folder-like structure (namespace using <code>/</code> separator). Some datarefs are read-only, some other can be written and modified. Names that start with <code>sim/</code> are reserved for the simulator internal use.</p>"},{"location":"Reference/Button%20Value/#examples","title":"Examples","text":"Dataref name Value Description sim/cockpit/misc/barometer_setting Float Value of the atmospheric pressure at the aircraft location in inches of mercury <p>There are thousands of datarefs in a running instance of X-Plane. Datarefs drive almost everything in the simulator.</p> <p>When used by a button in Cockpitdecks, the value of a dataref is monitored. Its value is fetched from the simulator at regular interval (typically every second). When a dataref's value has changed, all buttons that depend on that dataref are notified of the change to, for example, update their appearance.</p> <p>To explore datarefs available in the simulator, there is a handy X-Plane plugin called DataRefTool. There are also a few web pages that collect, report, and present them so that they can be searched. The plugin allow not only for inspection of datarefs, but also for inspection and discovery of commands, strings that can be submitted to the simulator to perform some action.</p> <p>For simplicity, Cockpitdecks assumes all individual dataref values are floating point numbers or strings. The reason for this is that as today, X-Plane UDP only returns floating point numeric values for requested datarefs.</p>"},{"location":"Reference/Button%20Value/#dataref-rounding","title":"Dataref Rounding","text":"<p>Dataref values can change insignificantly very rapidly. To prevent dataref update and its consequences (update of the button value and its representation) with the value change insignificantly, dataref values can immediately be rounded before they are communicated to Cockpitdecks.</p> <p>Required rounding is expressed in the <code>config.yaml</code> file.</p> <p>The <code>dataref-roundings</code> attribute is a list of (dataref-name, significant decimal digit after comma):</p> <pre><code>dataref-roundings:\n    sim/cockpit/autopilot/heading_mag: 2\n    sim/flightmodel/position/latitude: 8\n    sim/flightmodel/position/longitude: 8\n    sim/cockpit/misc/barometer_setting: 2\n</code></pre> <p>There is a global, application-level, <code>dataref-roundings</code> located in the main Cockpitdecks resources folder. The file should never be changed or touched.</p> <p>It is possible for the aircraft configuration developer to specify particular rounding needs in the main <code>config.yaml</code> file in the aircraft <code>deckconfig</code> folder in the same way. Aircraft roundings will take precedence on global roundings.</p> <p>Dataref roundings only applies to datarefs fetched from X-Plane.</p>"},{"location":"Reference/Button%20Value/#dataref-fetch-frequency","title":"Dataref Fetch Frequency","text":"<p>Similarly to dataref roundings, it is possible to specify, on a dataref basis, the frequency at which Cockpitdecks will ask X-Plane to send values in UDP packets.</p> <p>The default values is between 1 and 4 times per seconds, 1 to 4 Hz.</p> <pre><code>dataref-fetch-frequencies:\n    sim/cockpit/autopilot/heading: 10\n</code></pre> <p>The above configuration indicates that dataref named <code>sim/cockpit/autopilot/heading</code> should be fetched 10 times per second (which is a lot, if not too much. Please recall that Cockpitdecks drives \"deck\" devices, not screen! Transfer of images to deck icons occurs on slow serial lines.)</p>"},{"location":"Reference/Button%20Value/#cockpitdecks-internal-datarefs","title":"Cockpitdecks \u00abInternal\u00bb Datarefs","text":"<p>Cockpitdecks manages its own set of internal datarefs.</p> <p>All datarefs that have a path or name that starts with a special key word are NOT forwarded to X-Plane but rather managed internally inside Cockpitdecks. Otherwise, they are not different from X-Plane datarefs. They can be set and used like any other datarefs.</p> <p>When a button produces an internal dataref, it's definition mention it clearly so that it can be used by other buttons.</p> <p>The current default prefix for internal datarefs is <code>data:</code>.</p> <pre><code>   set-dataref: data:my-local-variable\n\n# in the same or another button, it can be used like so:\n\n   formula: ${data:my-local-variable}\n</code></pre> <p>In the above example, the prefix <code>data:</code> denotes internal datarefs. The name of the internal dataref is <code>data:my-local-variable</code>.</p> <p>Internal datarefs can be used as inter-button communication, to set a value in one button, and use or read it in another one.</p>"},{"location":"Reference/Button%20Value/#button-internal-state-attributes","title":"Button \u00abInternal State\u00bb Attributes","text":"<p>When a button cannot fetch its representation from X-Plane, it is possible to use some Cockpitdecks internal variables made available through the button state. Each button maintain its state, a few internal variables that can be accessed in formula.</p> <p>Some state variables are generic, and available for almost every buttons, like for instance the number of time a button was activated. Other state variables are activation specific and listed in the Activations page under the activation being used, like for example, the number of times a encoder was turned clockwise.</p> <p>Numeric internal values are accessible as <code>${state:variable-name}</code> in formula.</p> <pre><code>\tformula: {state:button_pressed_count} 2 mod\n</code></pre>"},{"location":"Reference/Button%20Value/#activation-attributes-and-activation-value","title":"Activation Attributes and Activation Value","text":"<p>Most state attributes of a button come from the activation. Each activation has a specific set of state attributes. Among these state attributes, there is a more particular attribute, called the activation value, which is the most sensible value produced by the activation.</p>"},{"location":"Reference/Button%20Value/#class-instance-attributes","title":"Class Instance Attributes","text":"<p>For Cockpitdecks developers, all attributes used in the button, its activation, or its representation class instances are also available as state variables. In this case, the value of the attribute is returned with no type checking.</p> <pre><code>class SpecialActivation:\n    ACTIVATION_NAME = \"my-activation\"\n    def __init__(self):\n        self.my_value = 8\n</code></pre> <p>When used:</p> <pre><code>my-activation:\n    formula: ${state:my_value} 2 /\n</code></pre> <p>equals 4.</p>"},{"location":"Reference/Button%20Value/#button-value","title":"Button Value","text":"<p>From the above</p> <ul> <li>X-Plane datarefs</li> <li>Cockpitdecks internal datarefs</li> <li>Button internal state attributes, in particular the activation value</li> </ul> <p>which may be called variables, a button provides a final value. This value is supplied to the representation that will provide the button feedback on the deck.</p> <p>The following sections details how the value gets computed from the above variables. The possibilities are:</p> <ul> <li>Value from a formula (that combines several datarefs and button internal state attributes),</li> <li>Value from a single dataref,</li> <li>Value returned by the activation,</li> <li>A list of values for a representation that requires it,</li> <li>or finally, a list of all the above variables in a dictionary of values.</li> </ul>"},{"location":"Reference/Button%20Value/#single-dataref-value","title":"Single Dataref Value","text":"<p>The value of the button is determined by a single dataref value.</p> <pre><code>dataref: sim/weather/region/atmospheric_pressure\n</code></pre>"},{"location":"Reference/Button%20Value/#combining-multiple-variables-with-formula","title":"Combining Multiple Variables with Formula","text":"<p>A Representation is driven by a single final value. However, it is possible to compute that final value form a list of dataref values, internal button attributes, and mathematical operations. This is done through a <code>formula</code> attribute. The formula is written in Reverse Polish Notation, a method to write and execute operations on values. Since a formula allows for value transformation, a formula should always produce a value that is directly usable by a representation. The value of a button can be computed from data coming either from X-Plane (through dataref values) and/or from the button's internal state values.</p> <p>Examples of <code>formula</code>:</p> <pre><code># Simple math (in reverse polish notation):\nformula: ${AirbusFBW/OHPLightsATA34[8]} 2 * floor\n\n# Constant 1; always 1; always True or On\nformula: 1\n\n# Insert 0 = true, 1 = false\nformula: ${sim/cockpit2/switches/avionics_power_on} 1 - abs\n\n# Boolean operation not\nformula: ${sim/cockpit2/switches/avionics_power_on} not\n\n# Boolean operation\nformula: ${AirbusFBW/OHPLightsATA34[8]} 4 eq\n\n# Formula used for display of a value\nformula: ${sim/cockpit/misc/barometer_setting} 33.8639 *\ntext: ${formula}\ntext-format: \"{: 4.0f}\"\n\n# The following two lines are equivalent; they both return the same value\nformula: ${sim/cockpit/autopilot/vertical_velocity}\t\ndataref: sim/cockpit/autopilot/vertical_velocity\n</code></pre> <p>Only one formula attribute can be used for a button or a annunciator part or a LargeButton button.</p>"},{"location":"Reference/Button%20Value/#expression","title":"Expression","text":"<p>The formula for computation is expressed in Reverse Polish Notation. The result of the formula is a numeric value (float value that can be rounded to an integer if necessary.) It is intimidating at first to write RPN formula, but once a user get use to it, it actually is equaly easy to write RPN formula and formula with parenthesis. In a nutshell, rather than writing:</p> <pre><code>(8 / 2) + (4 \u00d7 5)\n</code></pre> <p>in RPN, we write:</p> <pre><code>8 2 / 4 5 \u00d7 +\n</code></pre> <p>We place the value we act upon first, then the operation we perform on those values.</p>"},{"location":"Reference/Button%20Value/#operators","title":"Operators","text":"<p>The following operator have been added:</p> <ul> <li><code>%</code> or <code>mod</code>: Pushes reminder of division of last two elements, modulo.</li> <li><code>floor</code>: Round element to smaller integer value.</li> <li><code>ceil</code>: Round element to larger interger value.</li> <li><code>round</code>: Last element rounded to closest integer value.</li> <li><code>roundn</code>: Element rounded to last element of stack (forced to interger): <code>1.2345 2 roundn =&gt; 1.23</code></li> <li><code>abs</code>: Absolute value of last element</li> <li><code>chs</code>: Change sign of last element</li> <li><code>eq</code>: Test for equality of last two elements. Pushes 1 for True, 0 for False on the stack.</li> <li><code>not</code>: Boolean not operator, insert 1 if it was 0 or 0 otherwise.</li> </ul>"},{"location":"Reference/Button%20Value/#variable-substitution","title":"Variable Substitution","text":"<p>In formula:</p> <ul> <li><code>${dataref-path}</code> is replaced by the scalar value (converted to float) of the dataref pointed by <code>dataref-path</code>. Example: <code>${sim/aircraft/fuel/tankleft}</code>.</li> <li><code>${state:name}</code> is replaced by the scalar value of the (current) button' state variable named <code>name</code>. Names of available state variables depend on the activation; each activation lists internal state variables made available through the button' state. Example: <code>${state:activation_count}</code>.</li> <li><code>${button:cockpit-name:deck-name:page-name:button-name:button-variable-name}</code>:  Substitute de given button name by its value. Example:  <code>${button:Airbus A321:sd-xl:efis:apu:status:activation_count}</code> . If no button variable name is given, the current value of the button is returned.</li> </ul> <p>In all case, if the value is not found, it is replaced by None, which translate into 0 (zero) in formula (to prevent the formula from failing to compute). If the value is not found, a warning message is reported.</p> <p>The following formula determine the final status On(=1) or Off(=0) from the number of times a button was pressed:</p> <pre><code>formula: ${state:activation_count} 2 %\n</code></pre>"},{"location":"Reference/Button%20Value/#activation-value","title":"Activation Value","text":"<p>If a button does not reference a dataref, and has no formula, the activation value can be used if it is available.</p>"},{"location":"Reference/Button%20Value/#multiple-button-values","title":"Multiple Button Values","text":"<p>In case a button has multiple values, each value comes from a part of the button. Each part of the button is independent of other parts of the same button. Each part maintains its single value.</p> <p>All part values are aggregated into either a dictionary or an array of values that is made available at the button level.</p> <p>For example, Annunciator, or LargeButton representation, have more than one individual values that are fetched and maintained to provide a single table (or array) of individual values.</p> <p>Another example is a button that has more than one dataref and no formula. In this case, the returned value is a dictionary of all dataref values of that button.</p>"},{"location":"Reference/Button%20Value/#button-initial-value","title":"Button Initial Value","text":"<p>A Button can force its first, initial value to set its startup or original state.</p> <pre><code>\tinitial-value: 2\n</code></pre> <p>This value is assigned as the button's current value on startup.</p> <p>In case of a Button with multiple values, each value has a separate <code>initial-value</code> attribute.</p>"},{"location":"Reference/Button%20Value/#button-with-no-value","title":"Button with No Value","text":"<p>Some button may not maintain any state or use any value. Example of such button are simple push button with no feedback mean.</p>"},{"location":"Reference/Button%20Value/#summary","title":"Summary","text":"<p>The following depicts how a button's value is computed:</p> <p></p>"},{"location":"Reference/Button%20Value/#notes-about-value-re-computation","title":"Notes about Value (Re-)Computation","text":"<p>The value of a button is updated at the following moment:</p> <ol> <li>When the button is initialized, a first value is computed if not supplied.</li> <li>When a dataref on which the button depends has changed.</li> <li>After an activation.</li> </ol> <p>An activation only modifies its internal state and does not \"forward\" its modification to the button. It is the button's responsibility to fetch the value it needs in the activation, through, for example, a state variable:</p> <pre><code>formula: ${state:counter-clockwise-movement-count}\n</code></pre>"},{"location":"Reference/Button/","title":"Button","text":"<p>A button is the general term for a key, knob, rotary encoder, slider cursor, or even touch surface on a deck. On a given deck, each element that can be pressed, turned, swiped, or slid is a button.</p> <p>For a given deck, all buttons that are available and/or displayed at a moment in time are on the same Page, the collection of buttons currently usable on that deck. Hence, in the definition of a page, there is a mandatory <code>buttons</code> attributes that lists all buttons on that page.</p> <p>In that list, each button is defined by a list of attributes that will determine what it does and how it appears on the deck. The list of attributes that define a button is called a Button Definition.</p>"},{"location":"Reference/Button/#button-definition","title":"Button Definition","text":"<p>The Button Definition is a list of attributes that describe what the button will do when it is manipulated and how it will be represented on the deck if the deck can some how represent the state of that button.</p> <p>Button definition can be very simple and straightforward, but definitions can also be complex and refined.</p> <p>Here is an example of a simple definition of a button to toggle the map display in X-Plane.</p> <pre><code>index: 0\ntype: push\ncommand: sim/map/toggle_map_display\nicon: map\n</code></pre> <p>The definition of a button can be organised into 4 distinct parts:</p> <ol> <li>What the button is (and where it is on the deck)</li> <li>What it does (when the button is activated on the deck)</li> <li>What it displays (on the deck)</li> <li>Where does it get the value it displays from.</li> </ol> <p>Here is a complex definition of a button which exemplifies all above parts (in different colors):</p> <p></p> <p>Resulting button:</p> <p></p> <p>The following Sections describe the four button definition parts in detail.</p>"},{"location":"Reference/Button/#common-button-attributes","title":"Common Button Attributes","text":"<p>(In the Anatomy of a Button above, this refer to the blue part of the definition.)</p> Attribute Definition <code>index</code> Mandatory. There is no default value.Each Button on a deck is designated by its index. The index designate a very precise unique button on the deck.On a simple deck with a number of similar keys, the index of a button is its ordering number: 0, 1, 2\u2026 until the number of keys is reached. On a more complex deck, with button and knobs, knobs may be indexed with name like knob0, knob1, knob2\u2026 This is all defined in the Deck Type. <code>name</code> Optional. A button can be named to ease its identification.The name of a button on a page must be unique. If more than one button have the same name, an error is reported and the definition of the button is ignored.If no name is provided, a unique, long, technical name is created from deck name, page name, and index. <code>type</code> Mandatory.The type of a button defines what the button will do and how it will be used.The Activations describe button-type specific attributes. In other words, depending on the value of the type attribute, other button defining attributes will be expected.For example, if the value of a button type is <code>page</code> to change a page on a deck, it is expected to find the attribute named <code>page</code> which contains the name of the page to switch to when pressed. <code>label</code> The label of a button is a short reminder of what the button does. The text of the label is laid over the button image if any. The labelling of a button uses the attributes listed after.Note: The Button Label should not be confused with Button Text. The Label exist for all buttons, and is displayed according to its attributes if the underlying button is capable. The text of the label is defined as a button attribute and is static (cannot be changed dynamically).The Button Text is a text that is part of the Button representation. <code>label-color</code> See Resources <code>label-font</code> See Resources <code>label-size</code> In pixels. Internally, Cockpitdecks uses 256 \u00d7 256 pixel images. <code>label-position</code> The position of the label is a 2 letter code:1. l, c, or r for left, center, or right-justified on the image (horizontal alignment),2. t, m, or b, for top, middle, or bottom of the image (vertical alignment). <code>options</code> Regularly, buttons have additional parameters.The button options parameter is a string of comma separated options. An option is either a simple string or word, or a name=value string.Options are, by nature, not indispensable to the button\u2019s activation or rendering but rather add to it to alter behaviour or appearance. (Option may be replaced by explicit attributes in later releases.)"},{"location":"Reference/Button/#button-value","title":"Button Value","text":"<p>(In the Anatomy of a Button above, this refer to the yellow part of the definition.)</p> <p>A Button has a value that is maintained and used mainly for its representation.</p> <p>The value of a button can come from two sources:</p> <ul> <li>The simulator (i.e. some variable or parameter used and controlled by the simulator)</li> <li>The internal state of the button (read below)</li> </ul> <p>The following attributes are used to determine a button\u2019s value:</p> <p><code>dataref</code> : A single simulator variable value.</p> <p><code>formula</code>: An expression that contains variables, including datarefs (variables with values coming from the simulator software), and mathematical operations to combine and compute a single final value.</p> <p><code>multi-datarefs</code>: A list of two or more datarefs. The values of all datarefs in the list will be returned as the value of the button. In this case, the value will be a composite value. The representation that uses such a specific value will know how to use each part of the composite value.</p>"},{"location":"Reference/Button/#value-from-the-simulator","title":"Value from the Simulator","text":"<p>When the value of a button is computed from one or more values coming from the simulator, Cockpitdecks will request the values from the simulator, and each time one of these values changes, Cockpitdecks will notify the button of the changes so that it can adjust its representation.</p>"},{"location":"Reference/Button/#button-state","title":"Button State","text":"<p>Finally, in addition to the above attributes that can be used to specify the value of the button, a button has a set of internal attributes that can also be used to determine its value.</p> <p>Each button maintain an internal state: How many times it is pressed, released, turned clockwise or counter-clockwise, what is it current value, its previous, or last value, when it was last used or refreshed, etc. State information can be accessed by Button designer to control the button behavior and its representation, or its value.</p> <p>Examples of internal state attributes are:</p> <ol> <li><code>activation_count</code> (number of time button was \u00abused\u00bb)</li> <li><code>current_value</code></li> <li><code>previous_value</code></li> </ol> <p>Internal state attributes varies depending on the button activation. Each activation type returns its own set of particular state values.</p> <p>All these attributes can be used either individually or combined in a formula to determine the value of a button.</p> <p>Please head here for details about the computation of the value of a button.</p>"},{"location":"Reference/Button/#button-initial-value","title":"Button Initial Value","text":"<p>A Button can force its first, initial value to set its startup or original state.</p> <pre><code>\tinitial-value: 2\n</code></pre> <p>This value is assigned as the button's current value on startup.</p> <p>In case of a Button with multiple values, each value has a separate <code>initial-value</code> attribute in its own attribute list.</p>"},{"location":"Reference/Button/#button-activation","title":"Button Activation","text":"<p>(In the Anatomy of a Button above, this refer to the green part of the definition.)</p> <p>The <code>type</code> attribute of a button determine how the button will behave, what it will do when pressed, turned or slid.</p>"},{"location":"Reference/Button/#set-dataref","title":"Set-Dataref","text":"<p>A button definition can have a <code>set-dataref</code> attribute that points at a Dataref name.</p> <p>If present, Cockpitdecks will set the value of that dataref to the value of the button each time the value of the button changes.</p> <p>Here is example of use. If a button has a activation type of <code>updown</code> with let us say 3 stops, the value of the button can be 0, 1, or 2. Each time the user presses the button the value of the button cycles between those three values.</p> <pre><code>type: updown\nstops: 3\nset-dataref: toliss/NDmodeFO\n</code></pre> <p>If there is a <code>set-dataref</code> attribute, the current value of the dataref (<code>toliss/NDmodeFO</code>) in the simulator will be set to the value of the button: 0, 1, or 2.</p> <p>For some activations, the <code>set-dataref</code> attribute is a mandatory attribute.</p> <p>For some other activations that expects a command to be performed upon activation, the <code>set-dataref</code> attribute (or instruction) can be an alternative to the command. In other words, the commands that gets executed is very precisely the <code>set-dataref</code> instruction.</p>"},{"location":"Reference/Button/#button-representation","title":"Button Representation","text":"<p>(In the Anatomy of a Button above, this refer to the pink part of the definition.)</p> <p>The representation of a Button determine what and how the button will display on the deck device. This depends on the capabilities of the button on the deck: LED, image, coloured led button, sound\u2026</p> <p>The representation of a button is determined by the presence of a special attribute in the definition of the button. That attribute will determine how the button will be represented.</p> <p>For example, if a button definition contains an attribute named <code>annunciator</code>, the button representation will be an drawn image of an Annunciator. A button can only define one representation in its definition. Otherwise, a warning is reported and the button is ignored.</p> <p>Attributes related to the representation of the button are indented under the attributes that names the representation. This is done on purpose to clearly separate attributes dedicated to what the button does (activation), and how it provides feedback to the user (representation).</p> <p>A Page of 32 buttons (4 rows of 8 buttons) can quickly become quite large and difficult to read. Fortunately, recall that a Page can include other Pages to structure the creation of a layout. For example, it might be advisable to create a \u00ab\u00a0main\u00a0\u00bb page with global settings, and include four sub-pages, one for each row on the deck.</p> <p>Cockpitdecks provides numerous tricks and features to ease the development and maintenance of button definitions. Definition files can be documented to clarify options and settings.</p>"},{"location":"Reference/Cockpit/","title":"Cockpit","text":"<p>Cockpitdecks is an application that connect decks to the X-Plane flight simulator. On one side, the application scans for decks connected to the computer and prepare them for use with X-Plane. On the other side, Cockpitdecks connects to X-Plane through the network to issue instructions to the simulator and listen to changes to reflect those changes on the deck device if it allows it.</p> <p>To determine what to display on decks, which commands to issue to the simulator, etc. Cockpitdecks reads a set of configuration files on startup.</p> <p></p> <p>Configuration files are specific to an aircraft. Commands are different on a Cessna and on an Airbus. Things to display on the deck are different as well. That\u2019s why configuration files are located in the folder of the aircraft being used because they are specific to it. Numerous other software like X-Camera proceed in a similar way, locating their aircraft specific configuration there as well.</p> <p>The Cockpit is the Maestro component of the Cockpitdecks application.</p> <p>It starts up the entire Cockpitdecks application. It establishes connection to the simulator, scans for existing decks connected to the computer, and load the aircraft configuration files. It listen to interactions that occur on the decks and listen to simulator changes to reflect deck statuses. It also monitors which aircraft is currently loaded in the simulator, and if the user changes aircraft, it loads the new configuration if any.</p> <p>The following pages describe the necessary configuration files, their location and organisation, and their content. Configuration files are organized in structured folders, and this structure is explained as well.</p> <p>All configuration files for Cockpitdecks are Yaml-formatted files. Yaml file contains a structured list of (name, value) pairs. The name is referred to as an attribute. The value can be almost anything: A number, a string, a list of things, or a list of other attributes.</p>"},{"location":"Reference/Cockpit/#cockpitdecks-configuration-for-one-aircraft","title":"Cockpitdecks Configuration for one Aircraft","text":"<p>Decks are particular to one aircraft. All files necessary to Cockpitdecks are located in a single folder named <code>deckconfig</code> that is found in the folder of the X-Plane aircraft currently being used. In that folder, Cockpitdecks will find all its configuration files.</p>"},{"location":"Reference/Deck/","title":"Deck","text":"<p>A Deck represents a deck device connected to the computer, be it a</p> <ul> <li>Elgato Stream Deck (several models supported),</li> <li>Loupedeck Loupedeck Live, or</li> <li>Berhinger X-Touch Mini,</li> <li>A web deck represented in a web page,</li> </ul> <p>a device that will be used to interact with the X-Plane flight simulator.</p> <p>A Deck uses and displays a collection of buttons called a Page of buttons. A Deck can display different pages of buttons at different times; a button on a page can be assigned to load another page of buttons.</p> <p>Each Page  define the set of buttons on the deck device, what each button does when pressed or turned, and how it will appear on the deck device. The collection of pages that can be installed on a deck is called the Layout of the deck.</p> <p>In addition to the Layout and the Pages it contains, a Deck defines deck-level attributes, such as the overall brightness of the device, or how to fill unused or undefined buttons.</p>"},{"location":"Reference/Deck/#deck-definition","title":"Deck Definition","text":"<p>Decks are declared in the <code>config.yaml</code> file in the <code>deckconfig</code> folder in the <code>decks</code> attribute. The <code>decks</code> attributes contains one or more decks as defined by the following attributes:</p>"},{"location":"Reference/Deck/#deck-attributes","title":"Deck Attributes","text":"Attribute Definition <code>name</code> Mandatory. Name of the deck. Must match the entry in secret.yaml file, it any. <code>type</code> Mandatory. Type of deck. This points at a very precise deck brand and model. The value must match one of the deck types Cockpitdecks recognizes. The types of deck models Cockpitdecks recognizes is displayed upon startup of the Cockpitdecks application. <code>layout</code> Optional. Name of the layout for this deck. Default to name value <code>default</code>. See the next Section for more information. <code>brightness</code> Optional. Overall brightness of deck. Default to 100%. It might be necessary to adjust brightness at night or in low light environment. <code>disabled</code> Boolean value to tell whether the deck should be enabled or not for this aircraft. Useful during development process. <code>default-homepage-name</code> Optional. Name of the page to load first in the layout. Default to <code>index</code>. That's why layout folder often contains a <code>index.yaml</code> page. <code>default-*</code> Optional. Default attributes to use for deck. <p>Announce of available deck types on startup.</p> <pre><code>cockpit.py: loaded 19 deck types (Virtual Deck for Development, X-Touch Mini, Virtual X-Touch Mini, LoupedeckLive, virtual loupedeck.ct, virtual loupedeck.live.s, Virtual LoupedeckLive with Mosaic, Virtual LoupedeckLive, Stream Deck Original, Stream Deck Mini, Stream Deck Neo, Stream Deck +, Stream Deck XL, Streamdeck, Virtual Streamdeck Mini, Virtual Streamdeck MK.2, Virtual Stream Deck Neo, Virtual Streamdeck +, Virtual Streamdeck XL), 11 are virtual deck types\n</code></pre>"},{"location":"Reference/Deck/#deck-layout","title":"Deck Layout","text":"<p>For a given aircraft, a deck has a Layout. The Layout of a deck is the collection of Pages that will be used and displayed on the deck device for that aircraft. All these pages are grouped into a folder called a layout. A Layout is a folder in the <code>deckconfig</code> folder that contains pages.</p> <pre><code>XPlaneAircraftFolder\n  (...)\n  \u22a2 deckconfig\n    \u22a2 resources\n      \u22a2 fonts\n      \u22a2 icons\n      \u22a2 ...\n    \u22a2 layout1\n      \u22a2 config.yaml\n      \u22a2 page1.yaml\n      \u22a2 page2.yaml\n      ...\n    ...\n</code></pre> <p>The deck definition should contain a <code>layout</code> attribute that indicates which layout will be used for that deck. The default layout name, if not indicated is <code>default</code>. If no layout is found for the deck, a default, minimal layout is created.</p>"},{"location":"Reference/Deck/#web-decks","title":"Web Decks","text":"<p>No deck? We got you covered.</p> <p>If there is no physical deck device, Cockpitdecks can be used to replicate one of those on a web page.</p> <p>To use an emulation of a Stream Deck device for example, it is necessary to install the streamdeck component of Cockpitdecks. When done, it is possible to create virtual Stream Deck devices and display them in a web page.</p> <p>This is equally possible with other brands like Loupedeck or Behringer.</p>"},{"location":"Reference/Glossary/","title":"Deck","text":"<p>A Deck is a piece of hardware connected to a computer to provide some input by means of buttons, encoders, cursors\u2026 A Deck also provide some feedback to the user through colored LED lights, small LCD icon screens, or by emitting sound and vibration.</p>"},{"location":"Reference/Glossary/#button","title":"Button","text":"<p>A button is a piece of a deck a user can use to interact with it.</p> <p>It can be a simple button to press, a small LCD button, an encoder to turn, or a touch screen that can be swiped with one or multiple fingers.</p>"},{"location":"Reference/Glossary/#web-deck","title":"Web Deck","text":"<p>A Web Deck is an emulation of a deck in an internet browser window. Cockpitdecks provides a set of web decks that emulate existing decks.</p> <p>Originally, web decks where created to speed up deck page creation and arrangement. But web decks turned out to be so convenient that they are now part of Cockpitdecks. Some users actually only use web decks, without any physical ones.</p> <p>It is possible to design as create any web deck one can imagine, built from basic components like buttons, encoders, led, and LCD displays. As a proof of this concept, there is a entire overhead panel, fully reactive and responsive to the simulator changes.</p> <p>Cockpitdecks allow a designer to create and use any web deck, in the context of the Cockpitdecks application.</p> <p>Formerly, Web Decks were called Virtual Decks, in the context of Cockpitdecks, both names can be used interchangeably.</p>"},{"location":"Reference/Glossary/#page","title":"Page","text":"<p>A Page is a collection of buttons that are displayed on a deck at a moment.</p> <p>A deck can display different pages of buttons. A button on a page can be used to load another page.</p> <p>All pages that can be displayed on a deck are grouped in a folder called the Layout of the deck.</p>"},{"location":"Reference/Glossary/#layout","title":"Layout","text":"<p>A Layout is a collection of pages that can be displayed on a given deck. On startup, a deck must tell Cockpitdecks which Layout it is going to use.</p>"},{"location":"Reference/Glossary/#cockpitdecks","title":"Cockpitdecks","text":"<p>Cockpitdecks is the name of the application used to control decks connected to a computer. It is started with the command <code>cockpitdecks-cli</code>.</p>"},{"location":"Reference/Glossary/#cockpit","title":"Cockpit","text":"<p>The Cockpit is the main entity of Cockpitdecks that controls most parts of the application, from the start to its termination.</p>"},{"location":"Reference/Glossary/#activation","title":"Activation","text":"<p>An Activation is an action that is executed when interaction occurs on a deck.</p>"},{"location":"Reference/Glossary/#representation","title":"Representation","text":"<p>A Representation is an abstraction of an instruction sent to a deck to change its appearance. It can be turning a LED light on or off, playing a sound, or dynamically generating an iconic image and sending it for display on a deck LCD key.</p>"},{"location":"Reference/Glossary/#variable","title":"Variable","text":"<p>A Variable is a typed value. A Variable maintains a list of Variable Listeners that get notified whenever the value of the variable changes. There are mainly two types of Variables:</p> <ul> <li>Internal Variables are variables defined and used inside Cockpitdecks</li> <li>Simulator Variables are variables that represent a value inside the connected simulator. When the value of the variable changes in the simulation software, all listener of that variable get notified of the change.</li> </ul>"},{"location":"Reference/Glossary/#stringwithvariables","title":"StringWithVariables","text":"<p>A StringWithVariables is a (string) variable. Its value contains one or more variables that get substitued when fetching its value.</p>"},{"location":"Reference/Glossary/#formula","title":"Formula","text":"<p>A Formula is a StringWithVariables. In the case of the formula, the value of the StringWithVariables is a Reverse-Polish Notation expression that further gets evaluated. The result of this evaluation is a numeric value, hence, the value of a Formula is a number.</p>"},{"location":"Reference/Glossary/#value","title":"Value","text":"<p>A Value is a variable with elements associated with it, like a format (font, size, color\u2026).</p>"},{"location":"Reference/Glossary/#activity","title":"Activity","text":"<p>An Activity is a fact that occurred in the simulation software and that is communicated to Cockpitdecks.</p> <p>For example, X-Plane allows for command to report when they are activated. X-Plane reports such activation to Cockpitdecks through the Activity entity.</p> <p>Other simulation software have other means to report activity that occurs when used. For example, MS Flight Simulator can report when a button in the cockpit user interface is pressed. There events all lead to the report of an Activity to Cockpitdecks.</p> <p>The word Activity has been chosen to distinguish from events, actions, and activations.</p>"},{"location":"Reference/Glossary/#event","title":"Event","text":"<p>An Event is a structure internal to Cockpitdecks that is created to notify that something occurred. Events are handled (processed) by Cockpitdecks.</p>"},{"location":"Reference/Glossary/#simulator-event","title":"Simulator Event","text":"<p>Simulator events are either sent by the simulator software or created by Cockpitdecks when something occurred in the simulator. There are two major types of Simulator Events:</p> <ol> <li>An Activity has been triggered inside the simulation software.</li> <li>A value has changed.</li> </ol>"},{"location":"Reference/Glossary/#deck-event","title":"Deck Event","text":"<p>Deck Events are produced by deck driver software to notify Cockpitdecks that interaction occurred on the deck: A button was pressed, \u00e0 encoder was turned, a cursor was slid\u2026</p>"},{"location":"Reference/Glossary/#instruction","title":"Instruction","text":"<p>An Instruction is a request emitted by Cockpitdecks to perform an action.  It is expressed through a little structure that contains the name of the instruction to carry, an optional delay to wait before the instruction is carried over, and an optional condition to satisfy before the instruction is carried over.</p>"},{"location":"Reference/Glossary/#simulator-instruction","title":"Simulator Instruction","text":"<p>A Simulator Instruction is an order sent to the simulator to alter its behavior. There are two major types of instructions.</p>"},{"location":"Reference/Glossary/#command","title":"Command","text":"<p>A Command is an instruction to perform an action.</p>"},{"location":"Reference/Glossary/#long-press","title":"Long Press","text":"<p>A Long Press is an instruction that needs to be carried over while/as long as a button is pressed. It is a variant of a command.</p>"},{"location":"Reference/Glossary/#update-value-of-a-simulator-variable","title":"Update Value of a Simulator Variable","text":"<p>The other type of Simulator Instruction is a request to update a value made accessible by the simulator.</p>"},{"location":"Reference/Glossary/#cockpitdecks-instruction","title":"Cockpitdecks Instruction","text":"<p>Cockpit or Cockpitdecks Instructions are instructions triggered and used inside Cockpitdecks and are not forwarded to the simulator. Cockpitdecks instructions are:</p> <ul> <li>Change/load alternate deck page</li> <li>Reload decks</li> <li>Stop Cockpitdecks</li> <li>Load new aircraft configuration</li> <li>\u2026</li> </ul>"},{"location":"Reference/Glossary/#-macro-instruction","title":"\u00ab\u00a0Macro-\u00bbInstruction","text":"<p>A Macro Instruction is an Instruction that consists of set of two or more instructions. Whenever an instruction is required, it is possible to use a Macro Instruction and trigger not one instruction but a whole set of instructions. Each individual instruction in the set is defined in an instruction block.</p>"},{"location":"Reference/Glossary/#see-also","title":"See Also","text":"<p>History</p>"},{"location":"Reference/Layout/","title":"Layout","text":"<p>A Layout is a collection of Pages that will be displayed on that deck.</p> <p>Layouts were created to cope with different deck models. If you have a set of 30 commands, you can display them all on a 32 key deck on the same page. But you have to spread 30 commands on two pages of buttons if your deck can only display 16 buttons at a time. Same commands, but two different layouts.</p> <p>A Layout is a folder, inside the <code>deckconfig</code> main folder. The Layout is named and addressed by the name of that folder.</p> <p></p>"},{"location":"Reference/Layout/#layout-folder","title":"Layout Folder","text":"<p>The Layout folder contains the following files:</p> <pre><code>  \u22a2 live\n    \u22a2 config.yaml\n    \u22a2 page1.yaml\n    \u22a2 page2.yaml\n</code></pre> <p>The Layout name is <code>live</code>, it contains 2 pages.</p>"},{"location":"Reference/Layout/#layout-configyaml-file","title":"Layout <code>config.yaml</code> File","text":"<p>The <code>config.yaml</code> file inside a layout folder defines Layout-level attributes. The file is optional.</p> <pre><code># This is at layout level\ndefault-icon-color: (94, 111, 130)\ndefault-label-color: blue\ndefault-label-font: DIN Bold.ttf\ndefault-label-size: 13\ndefault-page-name: page1\n</code></pre>"},{"location":"Reference/Layout/#attributes","title":"Attributes","text":"Attribute Definition <code>default-icon-color: blue</code> Optional. Default color to use for icon background. <code>default-label-color: white</code> Optional. Default color to use for layout labels. <code>default-label-font: D-DIN.otf</code> Optional. Default font to use for layout labels. <code>default-label-size: 13</code> Optional. Default label size. <code>default-homepage-name</code> Optional. Default page name in layout. <p>The default values of attributes (like font, colors, and sizes) are fetched at the Cockpit level if they are not specified at the Layout level.</p> <p>Layout attributes are used for all pages in the layout, unless a Page refines the definition of one of these attribute.</p>"},{"location":"Reference/Layout/#pages","title":"Pages","text":"<p>All other Yaml files in the folder are considered to be Pages in the layout.</p>"},{"location":"Reference/Layout/#default-layout","title":"Default Layout","text":"<p>If a deck has no layout specified, Cockpitdecks will generate one with one default page that will display a logo image on the deck (if it is capable of displaying images\u2026) and use the first available push button to toggle X-Plane Map On or Off.</p>"},{"location":"Reference/Main%20config.yaml%20File/","title":"Main config.yaml File","text":"<p>documentation</p> <p>decks</p> <p>named-colors</p> <p>defaults</p> <p>themed-defaults</p> <p>special defaults:</p> <p>virtual-deck-defaults:</p> <p>dataref-roundings:</p> <p>dataref-fetch-frequencies: (currently unused)</p> <p>dataref-fetch-frequency: 3</p>"},{"location":"Reference/Observables/","title":"Observables","text":"<p>Observables are data that is constantly monitored. When the data matches a criteria, a set of actions is executed.</p> <p>For people familiar with the concept, it can be considered a if-this-then-that instruction. For example: If the weather data from the simulator indicates rain is falling on the aircraft, we can set the windshield wipers automatically.</p> <p>There are two types of observables.</p> <p>Permanent Observables are coded observable serving a very specific purpose. The purpose often includes complex data transformation before it can be used by Cockpitdecks. Permanent Observables are derived from the Observable class. When identified, they all are instantiated and started. Permanent observables are part of extensions.</p> <p>Example of a Permanent Observable convert (latitude, longitude) into the closest weather station ICAO code. This cannot be done by simple calculations in a Formula.</p> <p>Configured Observables, or simply Observables, are entities that monitor one or more variables and perform instructions when observable conditions are met. Configured Observables are defined at three levels:</p> <ol> <li>the cockpit level, available for the entire application, mostly all the time,</li> <li>the simulator level, available to monitor simulator-specific variables,</li> <li>the aircraft level, available to monitor aircraft-specific variables.</li> </ol> <p>Configured Observables are defined in <code>resources</code> folder of the entity in a <code>observables.yaml</code> file. All observables are loaded at once in an Observables entity which contains them all and report their use .</p>"},{"location":"Reference/Observables/#definition-of-observables","title":"Definition of Observables","text":"<p>The file <code>observables.yaml</code> is located in the <code>deckconfig/resources</code> folder of an aircraft. It is loaded on startup.</p> <pre><code>observables:\n  - name: example\n    trigger: onchange\n    dataref: some/dataref/to/check\n    actions:\n      - command: do/some/action\n        delay: 5\n</code></pre>"},{"location":"Reference/Observables/#attribute","title":"Attribute","text":""},{"location":"Reference/Observables/#observables","title":"Observables","text":"<p>The <code>observables</code> attribute is a list of individual observables.</p>"},{"location":"Reference/Observables/#observable","title":"Observable","text":""},{"location":"Reference/Observables/#attributes","title":"Attributes","text":""},{"location":"Reference/Observables/#type","title":"Type","text":"<p>What triggers the observable.</p>"},{"location":"Reference/Observables/#trigger","title":"Trigger","text":"<p><code>type: trigger</code></p> <p>The list of action is carried over when the value of the observable is True (or non zero).</p>"},{"location":"Reference/Observables/#value-changed","title":"Value Changed","text":"<p><code>type: onchange</code></p> <p>Another method to trigger the flow of action(s) is to select the\u00a0value changed mode. Actions get executed as the value of the dataref or of the computation has changed.</p>"},{"location":"Reference/Observables/#activity","title":"Activity","text":"<p><code>type: activity</code></p> <p>The observable will look for the <code>event</code> or <code>events</code> attributes and register interest in the events listed under these attributes.</p> <p>Each time the simulator software will report those events, the actions will be carried over.</p>"},{"location":"Reference/Observables/#repeat","title":"Repeat","text":"<p><code>type: repeat</code></p> <p>The observable will automatically be triggered every <code>replay</code> seconds after a <code>delay</code> seconds at the start</p>"},{"location":"Reference/Observables/#actions","title":"Actions","text":"<p>The <code>actions</code> attribute is a list of individual actions that gets carried out in sequence if the trigger attribute is True.</p>"},{"location":"Reference/Observables/#action","title":"Action","text":""},{"location":"Reference/Observables/#attributes_1","title":"Attributes","text":"<p>An action as the same attribute as a command carried out by a button:</p> <ul> <li>instruction</li> <li>delay</li> <li>condition</li> </ul>"},{"location":"Reference/Observables/#examples","title":"Examples","text":"<p>Here are a few examples of Observables, set from experience.</p>"},{"location":"Reference/Observables/#simulation-event","title":"Simulation Event","text":""},{"location":"Reference/Observables/#internal-changes","title":"Internal Changes","text":"<p>When a new aircraft is loaded, or when an aircraft livery is changed, \"internal\" events are generated by the simulator software so that external entities like Cockpitdecks can be notified.</p> <p>This is how Cockpitdecks detects aircraft or livery changes. Action triggered are very specific (to change the aircraft).</p> <p>So, internally, Cockpitdecks uses an Observable that monitors a simulator variable that changes when a new aircraft or mivery is loaded. This depends on the</p>"},{"location":"Reference/Observables/#aircraft-events","title":"Aircraft Events","text":""},{"location":"Reference/Observables/#auto-save-on-event","title":"Auto Save on Event","text":"<p>Most simulators or aircrafts provide a command to save the situation and restore it later.</p> <p>ToLiss aircrafts simulate Airbus which have the concept of flight phase.</p> <p>We devised an Observable to trigger a situation save on flight phase change. This allows to restart a flight right at the flight phase change.</p>"},{"location":"Reference/Observables/#complex-observables","title":"Complex Observables","text":"<p>A few packages come with special, coded Observables to serve very particular purpose. In most case, triggers or value changes are impossible to map with simple formula operation and require further coding.</p> <p>Complex Obervables are automatically loaded on startup and are accessible through the rendez-vous internal variable.</p>"},{"location":"Reference/Observables/#weather-station","title":"Weather Station","text":"<p>The Weather Station observable determine the ICAO code of the weather station that is the closest to the aircraft.</p> <p>The Observable receives the aircrat latitude and longitude and determine the closest weather station. The ICAO code is written in an internal variable <code>weather-station</code>.</p> <p>The Observable is available in the X-Plane package as it requires the aircraft location.</p>"},{"location":"Reference/Observables/#daytime","title":"Daytime","text":"<p>The Daytime obsrvable receives the simulated date, time, and position of the aircraft and determine whether it is day or night time. Day is assumed between sunrise and sunset as computed for the location and time of year. <code>Daytime</code> or <code>nighttime</code> keyword is written in an internal variable <code>daytime</code>.</p> <p>The internal variable can be used to declare another Observable that, for instance, changes the theme of the deck interfaces from light to day or vice-versa.</p> <p>The Observable is available in the X-Plane package as it requires the aircraft location and the currently simulated date and time.</p>"},{"location":"Reference/Observables/#command-activation","title":"Command Activation","text":"<p>The newer X-Plane Web API allows for reporting when a command is activated. It is possible to capture when some action was executed by the user and, through observable, start another set of commands.</p> <p>For exemple, when a warning alarm is triggered (an event that can be captured through dataref value change), when the pilot or co-pilot presses the warning button to acknowledge it, we can capture the press of the button and start new action like performing a situation save.</p>"},{"location":"Reference/Observables/#cockpitdecks-observables","title":"Cockpitdecks Observables","text":"<p>Cockpitdecks provides a set of pre-made observables that perform complex tasks.</p> <p>Inside the <code>xplane</code> extension, Cockpitdecks offer the following complex observables:</p> <ul> <li>ICAO of the weather station closest to the current aircraft position.</li> <li>Day or night indicator.</li> <li>Simulator Activity Detector</li> </ul> <p>These observables set interval variables available for buttons.</p> <p>Please note that the X-Plane extension need to be installed to get these observables.</p>"},{"location":"Reference/Page/","title":"Page","text":"<p>A Page is a Yaml file. It defines is a collection of button definitions that will be installed and used on the deck at a given moment.</p>"},{"location":"Reference/Page/#page","title":"Page","text":"<p>A deck displays one Page of buttons and allow end-users to press those buttons to trigger actions. Actions to be performed when a button is manipulated are defined in the button definition, together with the appearance of the button on the deck. Actions are constrained by the type of push button or encoder. A push button cannot be rotated. The appearance of the button is also constrained by the feedback ability of the deck: Image icon, LED, colored LED, or, sometimes, no display at all.</p>"},{"location":"Reference/Page/#attributes","title":"Attributes","text":"<p>A Page contains the following attributes:</p> <pre><code>name: Index\nbuttons:\n  - index: knobTL\n    name: FCU Airspeed\n    type: knob\n    commands:\n      - sim/autopilot/airspeed_down\n      - sim/autopilot/airspeed_up\n    options: dot, nostate\nincludes: views\nfill-empty-keys: true\n</code></pre> Attribute Definition <code>name</code> Name of the Page. Superceedes the file name. Case sensitive.If no name is given, the name of the page is the page file name (without the <code>.yaml</code> extension.)For a given layout, all pages must have different names, otherwise an error is reported, and the page with the same name is ignored. <code>buttons</code> Mandatory.A list of button definitions. Please refer to the Button Section for details about button definitions. If there is no buttons attribute, the page as no button to represent and is ignored. <code>includes</code> Includes is a list of other pages to include in this page.Included pages are first merged inside the main page, and then submitted for display and use. <code>fill-empty-keys</code> Optional, default to False, whether to fill unused keys with a default button definition as a placeholder.The default value of some attributes (like font, colors, and sizes) is fetched at the Layout level if they are not specified at the Page level. <code>default-*</code> Default values to be used at the Page-level for display."},{"location":"Reference/Page/#page-buttons","title":"Page Buttons","text":"<p>The <code>buttons</code> attributes contains all button definitions.</p>"},{"location":"Reference/Page/#default-page","title":"Default Page","text":"<p>If no Page is found in the Layout folder, Cockpit deck will create a default page which consists of a logo displayed on the deck (if the deck is capable of displaying images).</p> <p>The first available button will be programmed to toggle the X-Plane Map On or Off.</p>"},{"location":"Reference/Representations/","title":"Representations","text":"<p>The Representation of a button determine how it will be displayed on the deck device.</p> <p>The representation depends on the capabilities of the button on the deck. There is a list of valid representations or a given button on a deck. A image or icon cannot be displayed on a LED-only button.</p> <p>In the button definitions, the presence of a specific attribute with determine how the button gets represented on the deck. The name of that attribute is the key word of the representation. For example:</p> <ul> <li><code>icon</code>: To show a image image</li> <li><code>led</code>: To turn a LED on or OFF</li> <li><code>annunciator</code>: To display a complex image as an icon</li> <li>etc.</li> </ul> <p>The first attribute mentioned in each section below determines the type of Representation (<code>icon</code>, <code>text</code>, <code>multi-icons</code>, etc.) If more than one representation is found, or a representation that is not valid for the given button, a warning message is reported and the button does not render anything.</p> <p>If no Representation is found, a warning message is reported and the button is assumed having no representation. For example, a X-Touch Mini slider has no representation. To suppress the warning message, the <code>representation</code> attribute can be used and set to <code>false</code>.</p> <pre><code>  - index: slider\n    name: SLIDER\n    type: slider\n    representation: false\n</code></pre> <p>will not issue any warning message.</p>"},{"location":"Reference/Representations/#representation-attributes","title":"Representation Attributes","text":"<p>A representation often has attributes that customise its behavior.</p> <p>All representation-specific attributes must be declared under the attribute that declares the representation: (See attributes in pink in picture below.)</p> <p>This is a requirement to differentiate attributes at the button activation level (not indented, in blue or green), and button representation (indented, in pink)</p> <p></p>"},{"location":"Reference/Representations/#representations","title":"Representations","text":"<p>Here is a list of currently available, general purpose representations.</p>"},{"location":"Reference/Representations/#basic-button-representations","title":"Basic Button Representations","text":"<ul> <li>Basic#Icon</li> <li>Basic#MultiIcons</li> <li>Basic#IconText</li> <li>Basic#MultiTexts</li> <li>Basic#LED</li> <li>Basic#ColoredLED</li> </ul>"},{"location":"Reference/Representations/#drawn-representations","title":"Drawn Representations","text":"<ul> <li>Annunciator</li> <li>Drawn Buttons \u2013 Switches<ul> <li>Drawn Buttons \u2013 Switches#Switch</li> <li>Drawn Buttons \u2013 Switches#Circular Switch</li> <li>Drawn Buttons \u2013 Switches#Push Button and Knob</li> </ul> </li> <li>Other drawn representations<ul> <li>Drawn Buttons#Data</li> <li>Drawn Buttons#Decor</li> </ul> </li> </ul>"},{"location":"Reference/Representations/#more-complex-button-representations","title":"More complex Button Representations","text":"<ul> <li>Animations</li> <li>Reference/Button Representations/Weather</li> <li>Other<ul> <li>Aircraft</li> </ul> </li> </ul>"},{"location":"Reference/Representations/#deck-specific-displays-and-representations","title":"Deck Specific Displays and Representations","text":"<p>Please refer to the following pages for deck specific representtions.</p> <p>Deck specific means those representations on one deck will (probably) not work on another deck.</p> <ul> <li>Deck Specific \u2013 Stream Deck</li> <li>Deck Specific \u2013 Loupedeck</li> <li>Deck Specific \u2013 X-Touch Mini</li> </ul>"},{"location":"Reference/Representations/#aircraft--deck-specific-representations","title":"Aircraft / Deck Specific Representations","text":"<p>(To be used as model for alternate development.)</p> <ul> <li>Toliss Airbus FMA Display</li> <li>Toliss Airbus FCU</li> </ul>"},{"location":"Reference/Representations/#common-representation-attributes","title":"Common Representation Attributes","text":""},{"location":"Reference/Representations/#managed","title":"Managed","text":"<p><code>dataref: dataref-path</code></p> <p>Path to a dataref that is interpreted to determine whether the value is managed.</p> <p>If the value is managed, the value can be displayed as a text string in an alternative way depending on the <code>text-alternate</code> value.</p> <p><code>text-alternate: dash=4</code>: Represent managed value by a set of <code>-</code>. Default is 3 dashes.</p> <p><code>text-alternate: dot</code>: Represent managed value by a single dot <code>\u2022</code>.</p> <pre><code>  - index: 0\n    type: none\n    name: FCU Airspeed display\n    label: SPD\n    text: ${sim/cockpit2/autopilot/airspeed_dial_kts_mach}\n    text-format: \"{:3.2f}\"\n    text-color: khaki\n    text-size: 24\n    text-font: Seven Segment.ttf\n    text-position: cm\n    text-bg-color: (40, 40, 40)\n    managed:\n        dataref: AirbusFBW/SPDmanaged\n        text-alternate: dash\n</code></pre> <p>In example above, speed managed mode, if <code>AirbusFBW/SPDmanaged</code> dataref value is non zero, the text will display <code>---</code>. Otherwise, it will display the air speed.</p>"},{"location":"Reference/Representations/#guard","title":"Guard","text":"<p><code>dataref: dataref-path</code></p> <p>Path to a dataref that is interpreted to determine whether the button or key is guarded (protected against unintentional use by a cap or lock). If guarded, it can be displayed in an alternative way depending on the options value.</p> <p><code>type</code>: Protects the button with a full red cover (<code>type: full</code>) or a see-through grid (<code>type: grid</code>)(cover is the default).</p> <p><code>color</code>: Color of the guard. Default is red for cover, and translucent red for grid.</p> <pre><code>    label: RAM AIR\n    guard:\n      type: grid\n      color: black\n      dataref: ckpt/ramair/cover\n      # 0=closed, 1=opened\n</code></pre> <p>Guarded buttons or keys need to be pressed twice to activate, the first activation lifts the guard, the second one acts normally. To replace the guard, a long press of more than 2 seconds is necessary to replace (close) the guard.</p> <p>Long Press</p> <p>Make sure long press lasts 2 seconds or more, otherwise the button will be activated!</p>"},{"location":"Reference/Resources/","title":"Resources","text":""},{"location":"Reference/Resources/#fonts","title":"Fonts","text":"<p>Font files available to all decks are in the <code>deckconfig/resources/fonts</code> folder.</p> <p>Font files must be either Truetype fonts (TTF) or Opentype fonts (OTF).</p> <p>The name of the file is used to designate the font.</p> <p>Fonts are loaded on start up.</p> <pre><code>\ttext-font: DIN Condensed Black.otf\n</code></pre> <p>Cockpitdecks comes with a few fonts appropriate for aeronautical use: Standard formal fonts like DIN, fancier fonts like LED fonts, icon fonts like font-awesome and weather-icon.</p> <p>For Truetype font, it is not necessary to add the <code>.ttf</code> extension. For Opentype fonts it is necessary to add the <code>.otf</code> extension.</p> <p>About font files.</p> <p>Fonts placed in the resources/fonts folder are available for images on decks. They are not necessarily available as \u00ab\u00a0web fonts\u00a0\u00bb available in web decks. To be available directly, not through Cockpitdecks generated images, web decks fonts have to be made available in the asset folder and referenced in proper CSS files.</p> <p>Cockpitdecks provides the following licensed fonts in its distribution:</p> <ul> <li>D-DIN (4 variants),</li> <li>Overpass, especially Overpass Mono,</li> <li>Segment7Standard,</li> <li>Split flaps Skyfont and SplitFlap-TV,</li> <li>Icon fonts Font Awesome and weathericons.</li> </ul> <p>The following fonts are recommended:</p> <ul> <li>B612</li> <li>DSEG: Original 7-segment and 14-segment fonts</li> </ul> <p>Any Truetype or OpenType font can be added to Cockpitdecks.</p>"},{"location":"Reference/Resources/#icons","title":"Icons","text":"<p>Icon image files available to all decks need to be placed in the <code>deckconfig/resources/icons</code> folder.</p> <p>Image files must be either JPEG images (JPG, JPEG) or Portable Network Graphic (PNG).</p> <p>The name of the file is used to designate the icon.</p> <p>Icons are loaded on start up and optionally cached.</p> <p>Typical icon size should be (square) 128 to 256 pixels.</p> <p>Internally, Cockpitdecks use 256 pixel icons. Icons are resized to the deck requested size upon display.</p> <pre><code>\ticon: OFF_WHITE_FRAMED\n</code></pre>"},{"location":"Reference/Resources/#sounds","title":"Sounds","text":"<p>Sounds files can be provided very much like icons. Valid sound file formats are <code>wav</code> and <code>mp3</code>. Other sound file format may be added in the future, provided they can be played in a browser.</p>"},{"location":"Reference/Resources/#custom-decks","title":"Custom Decks","text":""},{"location":"Reference/Resources/#structure","title":"Structure","text":""},{"location":"Reference/Resources/#deck-type","title":"Deck Type","text":""},{"location":"Reference/Resources/#web-deck-background-image","title":"Web Deck Background Image","text":""},{"location":"Reference/Resources/#observables","title":"Observables","text":"<p>Observables</p>"},{"location":"Reference/Resources/#additional-configuration-attributes","title":"Additional Configuration Attributes","text":"<p><code>config.yaml</code></p>"},{"location":"Reference/Resources/#default-values","title":"Default Values","text":""},{"location":"Reference/Resources/#number-formatting","title":"Number Formatting","text":"<p>Cockpitdecks uses the same convention as python number to text formatting.</p>"},{"location":"Reference/Resources/#named-colors","title":"Named Colors","text":"<p>Named colors are defined at the highest aircraft level. They behave like a placeholder for a color, an alternate name.</p>"},{"location":"Reference/Resources/#definition","title":"Definition","text":"<p>In the main configuration file of the aircraft:</p> <pre><code>named-colors:\n\tCOCKPIT_BACKGROUND: skyblue\n\tCOCKPIT_NIGHT: slateblue\n\tHIGHLIGHT: coral\n</code></pre>"},{"location":"Reference/Resources/#usage","title":"Usage","text":"<p>In a button definition attributes:</p> <pre><code>label-color: HIGHLIGHT\n</code></pre>"},{"location":"Reference/Resources/#colors","title":"Colors","text":"<p>Color can either be expressed by their name, as defined in the Python PILLOW package, or by a tuple of 3 or 4 values, representing red, green, blue, and optionally the transparency.</p> <p>All values should be in the [0..255] range. For colors, 0 is black, 255 is pure color; for transparency, 0 is transparent, 255 is opaque.</p> <pre><code>    icon-color: (100, 40, 40, 200)\n    label-color: darkorange\n    text-color: mediumaquamarine\n</code></pre>"},{"location":"Reference/Resources/#theme","title":"Theme","text":"<p>Rendering themes is a features that allows a Cockpitdecks developer to provide different sets of default values for colors, fonts, and textures.</p>"},{"location":"Reference/Resources/#theme-declaration","title":"Theme Declaration","text":"<pre><code>cockpit-theme: night\n</code></pre> <p>Theme default value is an empty string (no theme).</p> <p>If a theme is used, its name is prepended to default attribute name when they are looked up:</p> <pre><code>\tnight-default-label-color: purple\n</code></pre> <p>If no such attribute is found, the <code>default-label-color</code> attribute name is looked up, without the <code>theme-</code> prepended.</p>"},{"location":"Reference/Resources/#theme-usage","title":"Theme Usage","text":"<p>When a theme is defined, its name is prepended to some default values.</p> <p>Default values affected by themes are:</p> <ul> <li><code>cockpit-color</code> and <code>cockpit-texture</code></li> <li>All attributes that end with <code>color</code>. Example <code>default-color</code>.</li> <li>All attributes that end with <code>texture</code>. Example <code>annunciator-bg-texture</code>.</li> <li>All attributes that end with or contain the word <code>font</code>. Example <code>label-font</code>.</li> </ul> <pre><code>theme: light\n# Alternate theme is 'dark'\ndefault-label-color: white\ndark-default-label-color: coral\n</code></pre> <p>It is advisable to define a light/day theme and a dark/night theme. There is an activation to change the theme. It also is possible to change the theme with an Observable. For example, it is possible to collect the simulation date, time, and location, and determine if it is a day-light or night time and set the theme accordingly.</p>"},{"location":"Reference/Resources/#documentation","title":"Documentation","text":"<p>Documentation files can be placed in the folder <code>resources/docs</code> in a textual form (including markdown), or as PDF.</p>"},{"location":"Reference/Simulator/","title":"Simulator","text":"<p>The Simulator entity represent the simulator software and contains all procedures necessary for interaction with the flight simulation software.</p> <p>There currently is only one type of flight simulation software supported and it is Laminar Research X-Plane (release 12.1.4 onwards, appeared early 2025).</p> <p>It is possible to create a new Simulator implementation for another software, like for example Microsoft Flight Simulator.</p> <p>In addition to the core simulation software, the Simulator also proposes a few entities that represent interactions with it.</p>"},{"location":"Reference/Simulator/#simulator-variable-values","title":"Simulator Variable Values","text":"<p>The simulation software presents to Cockpitdecks all its reachable \u00ab\u00a0values\u00a0\u00bb. Any value that is accessible in the simulation software is made available to Cockpitdecks through the SimulationVariable. A sophisticated mechanism updates the data in Cockpitdecks every time the data is modified in the simulator.</p> <p>For example, Laminar X-Plane extensively uses \u00ab\u00a0datarefs\u00a0\u00bb, while Microsoft Flight Simulator uses \u00ab\u00a0simvars \u00bb. They both are values coming from the simulator, and they both can be used in Cockpitdecks.</p>"},{"location":"Reference/Simulator/#simulator-activity","title":"Simulator Activity","text":"<p>A Simulator activity is the occurence of an event reported by the simulator software to an external entity, Cockpitdecks in our case.</p> <p>For exemple, X-Plane can report when a command is executed. When a given command is executed (activated) it reports when the command started (active=True) and ended (active=False). Microsoft Flight Simulator can similarly send notifications when a button is pressed on the cockpit.</p> <p>These events that occur in the simulation software and a \"broadcast\" on demand to external entities (external to the simulation software) are called Activities in Cockpitdecks. (The word was choosedn to distinguish from synonyms like events, action, trigger, etc.)</p>"},{"location":"Reference/Simulator/#instructions","title":"Instructions","text":"<p>Cockpitdecks offers the Instruction, an action that must be carried out in the simulator software, provided that the simulation software allows for \u00ab\u00a0external action\u00a0\u00bb to be accepted.</p> <p>Again, as an example, Laminar X-Plane has \u00ab\u00a0commands\u00a0\u00bb (offered in two modes of operation), and Microsoft Flight Simulator has \u00ab\u00a0idontknow\u00a0\u00bb.</p>"},{"location":"Reference/Simulator/#simulator-core","title":"Simulator Core","text":"<p>The Simulator entity is responsible for maintaining a connection to the Simulator software to collect simulator data values and issue instructions.</p>"},{"location":"Reference/deckconfig%20Folder/","title":"The <code>deckconfig</code> Folder","text":"<p>The overall structure of the files and sub-folders inside the <code>deckconfig</code> folder is as follow:</p> <pre><code>&lt;X-Plane Aircraft Folder&gt;/\n  (.. aircraft files ..)\n  deckconfig/\n    config.yaml\n    secret.yaml\n    resources/\n      icons/\n        icon-off.png\n      fonts/\n        B612-Regular.otf\n        DIN.ttf\n      decks/\n        images\n        types\n      docs/\n        README.md\n      other-resource.py\n    layout1/\n      config.yaml\n      page1.yaml\n      page2.yaml\n      ...\n    ...\n    layoutN\n      page1.yaml\n      page2.yaml\n      ...\n</code></pre> <p>The  <code>deckconfig</code> folder contains the following files and sub-folders:</p> Name Description <code>config.yaml</code> Main configuration file <code>secret.yaml</code> Serial numbers of decks used by Cockpitdecks resources Resource files used by this configuration. Resources are icons, fonts, images, etc. layout(s) A Layout is a folder that contains what is displayed on a deck. There can be as many Layout Folder as necessary for this aircraft. All remaining folders in the <code>deckconfig</code>folder are layout folders. There usually is one Layout folder per deck."},{"location":"Reference/deckconfig%20Folder/#configyaml-file","title":"<code>config.yaml</code> File","text":"<p>The file named <code>config.yaml</code> in the <code>deckconfig</code> folder it the main configuration file, It contains declarations for each Deck that will be used, and global, aircraft-level attributes.</p> <pre><code># Definition of decks for Toliss A321\n#\naircraft: Toliss \ndecks:\n  - name: XPLive\n    type: loupedeck\n    layout: live\n    brightness: 70\n# These attributes are default values at global level\nnamed-colors:\n    COCKPIT_BACKLIGHT: darkorange\ndefault-wallpaper-logo: Airbus-logo.png\ndefault-icon-color: (94, 111, 130)\ndefault-label-color: white\ndefault-label-font: DIN.ttf\ndefault-label-size: 14\ncockpit-color: lightblue\n</code></pre>"},{"location":"Reference/deckconfig%20Folder/#attributes","title":"Attributes","text":"<p>The following attributes apply to all decks for the given aircraft. Each individual deck will have the possibility to redefine these values if necessary.</p> Attribute Definition <code>aircraft</code> Optional information. The name of the aircraft for this set of deck. <code>named-colors</code> Allows to introduce your own named color. You can then use this name as a color. The value of the named color can either be a 3 or 4 value tuple (r, g, b, a), or the name of a Pillow color. (See Resources.) <code>cockpit-color</code> Color for the cockpit. This color is used as the default background color for icons. <code>cockpit-texture</code> Name of a image file (JPEG or PNG) that will be used as the (default) background of icons.The <code>cockpit-texture</code> file will be searched at different places depending on where it is specified.The <code>cockpit-texture</code> file can be specified at the Cockpit, Deck, Page, or Button level.Cockpit-level default textures will be seached in the following folders (in that order):- <code>resources</code>- <code>resources/icons</code>If the AIRCRAFT is specified, Cockpit-level textures and all other levels textures will be searched in the following folders:- <code>AIRCRAFT/resource</code>- <code>AIRCRAFT/icons</code>If no texture is found, a uniform <code>cockpit-color</code> icon is used. <code>default-wallpaper-logo</code> Name of image file, located in the <code>resource</code> folder, to be loaded when the deck is not used. <code>default-*</code> Name of default values of several parameters, defined at the aircraft-level. These values will be used for all missing values. They can be raffined at Layout and Page level if necessary.If no aircraft-level global parameter values are not provided, Cockpitdecks will use its own internal default values. decks A list of Deck structure, one per deck. <p>Yaml allow for other attributes in the file. They are ignored by Cockpitdecks. You may include other attributes like aircraft name, ICAO code, descriptions, notes, even change log of your file. Comments are also allowed in Yaml files.</p>"},{"location":"Reference/deckconfig%20Folder/#see-also","title":"See Also","text":"<p>Main config.yaml File</p>"},{"location":"Reference/deckconfig%20Folder/#secretyaml-file","title":"<code>secret.yaml</code> File","text":"<p>The <code>secret.yaml</code> file contains the serial numbers of your connected decks.</p> <p>If you have more than one deck of the same type (i.e. two Streamdecks, two X-TouchMini, etc.) this file is mandatory to distinguish between the two physical devices. Otherwise, it is optional.</p> <pre><code># My decks and their serial numbers.\n# Format:\n# DeckName: Serial number\n# DeckName must match name given in config.yaml.\nXPLive: AAA0000000000000000000A0000\n</code></pre> <p>Serial Numbers</p> <p>We experimentally noticed that serial numbers as displayed on the device and as reported by some software package do not always correspond. This also depends on the operating system. As a practical illustration, for HID devices, the request for its serial number throught HID specific protocol calls returns a value WA1234MHK0G, while the core operating system raw USB device probe returns A00WA1234MHK0G. Some device do not respond to serial number requests and in this case, an arbitrary software dependent value is returned, and not guaranteed to be unique(!). As a consequence, Cockpitdecks maintains a list of valid serial numbers for a given device.</p>"},{"location":"Reference/deckconfig%20Folder/#resources","title":"Resources","text":"<p>Resources are fonts, icons, other images, wallpapers, documentation, and texts used and related to that aircraft. All these elements are organized into the <code>resources</code> folder.</p> <p>Usually, the resources folder contains the following sub-folders:</p> Folder Content <code>icons</code> Folder containing all icon images for that aircraft. Images should be in JPEG or PNG format. Typical icon size is 256 \u00d7 256 pixels, RGB(A). Icons are named after their file name without the extension. <code>fonts</code> Folder containing all fonts for that aircraft. Fonts can be Truetype or Opentype. Fonts are named after their file name with the extension. <code>docs</code> Docs folder may contain documentation files, like explanatory images, and descriptive texts. Simpler text or markdown files are preferred. <code>decks</code> Cockpitdecks allow experienced users to create their own Web Decks specific to an aircraft."},{"location":"Reference/deckconfig%20Folder/#layout-folders","title":"Layout Folders","text":"<p>Next to the the above resources folder, there will be one folder per Layout for a deck.</p> <p>Layout folders are explained later.</p>"},{"location":"Reference/deckconfig%20Folder/#about-configuration-files-yaml","title":"About Configuration Files: Yaml","text":"<p>All configuration files are Yaml formatted. Yaml is simple, structured, and readable.</p> <p>Yaml is loaded and interpreted by the python Yaml parser. Users must be aware that some keywords are sometimes interpreted by some parser. To prevent this interpretation, keywords should be placed between quotes.</p> <p>For example:</p> <p><code>variable: on</code></p> <p>will be interpreted as boolean value true.</p> <p><code>variable: \"on\"</code></p> <p>will be interpreted as string <code>on</code>.</p> <p>The following keywords have been noticeably discovered:</p> <p>on, off, true, false, yes, no (all mapped to Boolean values True or False).</p> <p>Cockpitdecks uses a Yaml 1.2 compliant parser (ruamel.yaml) that refuse those interpretation as describe in the Yaml 1.2 specifications.</p>"},{"location":"Reference/Button%20Representations/Animations/","title":"Animations","text":"<p>Typical buttons display an information in a static way, an icon or a LED that is updated when a status or a value has changed.</p> <p>Animation is a button representation option that consists of continuously sending representation updates to continuously change the button's appearance.</p> <p>For example, in its simplest form, a icon animation consist of sending a different images to a key at regular interval, cycling to a list of images (vey much like a GIF animation\u2026).</p> <p>Another simple animation consists of making an icon \u00abblink\u00bb on or off. A more complex animation can consist of a parametrized drawing, an image is drawn at each iteration and sent to a key.</p> <p>Animations are automatic. They should not be confused with button appearance updates that occur automagically when underlying button values change.</p> <p>Most of the time, the value button determine if the animation runs. When the value of the button is On, the animation runs. When Off, the animation does not run and may displays an alternate representation.</p>"},{"location":"Reference/Button%20Representations/Animations/#--animationsiconanimation","title":"- Animations#IconAnimation","text":""},{"location":"Reference/Button%20Representations/Animations/#iconanimation","title":"IconAnimation","text":"<p>An icon-based animation is a procedure that changes the icon to display at regular internal.</p> <p>The icon to display is specified through its index value in the list of icons available to the button (through the <code>multi-icons</code> attribute).</p> <pre><code>icon-animation:\n  - ICON_FILE_1\n  - ICON_FILE_2\n</code></pre> <p>Multiple icon files are displayed in sequence automagically when the button is On.</p>"},{"location":"Reference/Button%20Representations/Animations/#attributes","title":"Attributes","text":"<p><code>icon-off: ICON_FILE_NAME</code></p> <p>The icon to display when the button is Off. If there is no icon-off, the first icon in the icon-animation list is used.</p> <p><code>speed</code></p> <p>Time in second an icon is displayed before displaying the next one.</p>"},{"location":"Reference/Button%20Representations/Animations/#blinking-animation","title":"Blinking Animation","text":"<p>A blinking animation is an procedure that forces some of all part of a Representation alternatively On and Off and provoque a rendering update after changes, leading to a blinking button effect.</p> <p>In this case, the animation controls and changes the value of the button, switching between On and Off states. The representation changes accordingly.</p>"},{"location":"Reference/Button%20Representations/Animations/#drawing-based-animation","title":"Drawing Based Animation","text":"<p>A Drawing animation is a parametrized drawing that uses a single parameter value (for exemple the button's value). When the value changes, the procedure optionally uses a tweening algorithm to progressively change the value from the old one to the new one.</p> <p>As a proof of this concept, the FollowTheGreens Representation displays a portion of taxiway centerline with \"flashing\" lead light when it is activated.</p> <p>Animations do not need to be fast. As another proof of concept, the Weather representation pictures a Metar report on a icon. The representation is updated each time the Metar is updated (about every 30 minutes). It is another form or use of animation.</p>"},{"location":"Reference/Button%20Representations/Annunciator/","title":"Annunciator","text":"<p>An Annunciator is a special image used for display on a deck key.</p> <p>An Annunciator image is build dynamically from its definition and from data coming from X-Plane. Airbus airliners extensively use annunciator buttons.</p> <p>Annunciator do not specify what they do, this is done by the button activation definition. Annunciator only address the representation of the button, the content of the image displayed on a deck key.</p> <p>On a deck, the representation of keys that accepts images can either be</p> <ol> <li>One or more icons, the icon being displayed at a given moment is determined by data provided by X-Plane,</li> <li>A switch, which is a dynamically built image of a switch or circular switch,</li> <li>An Annunciator, which is an alternate image, dynamically built from a definition and data provided by X-Plane or button status.</li> </ol>"},{"location":"Reference/Button%20Representations/Annunciator/#annunciator-shapes-and-sizes","title":"Annunciator Shapes and Sizes","text":""},{"location":"Reference/Button%20Representations/Annunciator/#annunciator-sizes","title":"Annunciator Sizes","text":"<p>Annunciators exits in 3 sizes:</p> <ol> <li>Large, square 1in \u00d7 1in.</li> <li>Medium, rectangular, \u215din \u00d7 1in, or smaller but in the 5:8 ratio.</li> <li>Small, rectangular, \u00bdin \u00d7 1in, or smaller but in the 1:2 ratio. (Or sometimes 3:8 ratio.) Given the limited size of deck key images (typically less that 100 pixels), annunciator always occupy the maximum space on the key. However, the above size of the annunciator govern the aspect ratio of the image: 1:1, 5:8, 1:2.</li> </ol> <p></p>"},{"location":"Reference/Button%20Representations/Annunciator/#annunciator-model","title":"Annunciator Model","text":"<p>Annunciator can display from 1 to 4 different data or information on a single key. Depending on the annunciator model, data is displayed on two rows, in two colums.</p> <p></p> <p>Each portion of an annunciator that can be used to display information is called an (annunciator) part. In an annunciator of type A, there is only one part called A0. In an annunciator of type E, there are three parts, E0, E1, and E2, arranged like shown on the above illustration.</p> <p>Annunciator of type F can display 4 different informations. The button underlying such an annunciator has therefore 4 distinct values.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#annunciator-parts","title":"Annunciator Parts","text":"<p>Each annunciator part is defined independently of the other parts.</p> <p>In a part, displayed information is either</p> <ol> <li>A Text, which can optionally be framed, or</li> <li>A LED of some kind: Block, bars, dot, or lgear (a small triangle) (Since Cockpitdecks provides icon fonts, (or you can load your own font,) it is possible to display any icon from a font with Text information and optionally frame it.)</li> </ol>"},{"location":"Reference/Button%20Representations/Annunciator/#annunciator-definition","title":"Annunciator Definition","text":"<pre><code>  - index: 5\n    name: A/THR\n    type: annunciator-push\n    annunciator:\n      size: medium\n      model: B\n      parts:\n        B0:\n          color: lime\n          led: bars\n          dataref-rpn: ${AirbusFBW/ATHRmode}\n        B1:\n          text: A/THR\n          color: white\n          size: 60\n          dataref-rpn: \"1\"\n    command: AirbusFBW/ATHRbutton\n</code></pre> <p>The Annunciator defintion starts at the <code>annunciator:</code> attribute.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#attributes","title":"Attributes","text":""},{"location":"Reference/Button%20Representations/Annunciator/#model","title":"model","text":"<p>Code letter from A to F to specify how annunciator parts are organised on the annunciator.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#size","title":"size","text":"<p>Annunciator size: large, medium or small. Full size is a large size that occupies the whole square button. Size mini exists but is practically not used.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#parts","title":"parts","text":"<p>The part attribute can be used to group all part definitions.</p> <p>Each part is addressed by the name of the part: A0, B0, B1, etc. The content is the part definition.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#part-definition","title":"Part Definition","text":"<pre><code>\t\t B0:\n\t\t\tcolor: lime\n\t        led: bars\n\t        dataref-rpn: ${AirbusFBW/ATHRmode}\n</code></pre>"},{"location":"Reference/Button%20Representations/Annunciator/#text-or-led","title":"Text or LED","text":"<p>The part definition must contain either a <code>text</code> attribute or a <code>led</code> attribute.</p> <p></p>"},{"location":"Reference/Button%20Representations/Annunciator/#status-on---off","title":"Status On - Off","text":"<p>Each part of a Annunciator has its own value. The value of a part is computed like the value of a Button, from datarefs and/or formula.</p> <p>A part is either lit or not, On or Off. Either status can be represented by supplying background and foreground colors.</p> <p></p> <p>About Off Color</p> <p>When off, Vivisun style annunciators remain black what ever is asked for dimmed or off-color. When off, Korry style annunciator will exhibit either a dimmed representation of the text (or LED, or what ever is displayed) or a \"off-color\" representation of it.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#attributes_1","title":"Attributes","text":""},{"location":"Reference/Button%20Representations/Annunciator/#text","title":"Text","text":""},{"location":"Reference/Button%20Representations/Annunciator/#text-format","title":"Text-format","text":""},{"location":"Reference/Button%20Representations/Annunciator/#font","title":"Font","text":""},{"location":"Reference/Button%20Representations/Annunciator/#size_1","title":"Size","text":""},{"location":"Reference/Button%20Representations/Annunciator/#color","title":"Color","text":""},{"location":"Reference/Button%20Representations/Annunciator/#invert-color","title":"Invert Color","text":""},{"location":"Reference/Button%20Representations/Annunciator/#off-color","title":"Off Color","text":""},{"location":"Reference/Button%20Representations/Annunciator/#led","title":"Led","text":""},{"location":"Reference/Button%20Representations/Annunciator/#part-data-value","title":"Part Data Value","text":"<p>Each part of a Annunciator has its own value. The value of a part is computed like the value of a Button, from datarefs and/or formula.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#dataref","title":"Dataref","text":"<p>Single dataref used for value.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#formula","title":"Formula","text":"<p>Formula used to determine the value of the part.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#annunciator-style","title":"Annunciator Style","text":"<p>There are two styles of annunciators. Both are named after major brands of annunciator manufacturer. Annunciators appears differently according to their style.</p> <p>The first style is Korry (<code>annunciator-style: k</code>), where the annunciator appears like a translucent window with back light. When the annunciator is not lit, the text or drawing is slightly readable on the display. When lit, the text appears to glow.</p> <p></p> <p>The second style is Vivisun (<code>annunciator-style: v</code>). When the annunciator is not lit, it has the color of the button (usually black) and no text is readable. When lit, displays on a Vivisun annunciator are sharp, very much like a \"retina display\" (high resolution display).</p> <p></p> <p>Both styles truthfully reproduce keys on decks. Combined with the adjustment of the intensity of the deck back light, they provide a real immersive experience.</p> <p><code>annnunciator-style</code> can be defined at the Cockpit, Deck, or Page level.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#guard","title":"Guard","text":"<p>Annunciators can optionally be protected by plastic cover guards.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#guards","title":"Guards","text":""},{"location":"Reference/Button%20Representations/Annunciator/#guards-as-drawn","title":"Guards as Drawn","text":""},{"location":"Reference/Button%20Representations/Annunciator/#attributes_2","title":"Attributes","text":"<p><code>dateref</code></p> <p>Dataref path to value driving the guard status (open or protected).</p> <p><code>type</code></p> <p>Cover or grid</p> <p><code>color</code></p> <p>Color of guard. Defaults to red.</p> <p>Translucent color (with alpha, or transparency channel) can be supplied.</p> <p><code>color: (255, 0, 0, 100)</code></p> <p>Is a translucent red color (r,g,b,a), a=0=transparent, a=255=full opaque.</p>"},{"location":"Reference/Button%20Representations/Annunciator/#design-examples","title":"Design Examples","text":""},{"location":"Reference/Button%20Representations/Basic/","title":"Basic","text":"<ul> <li>Basic#Icon</li> <li>Basic#MultiIcons</li> <li>Basic#IconText</li> <li>Basic#MultiTexts</li> <li>Basic#LED</li> <li>Basic#ColoredLED</li> </ul>"},{"location":"Reference/Button%20Representations/Basic/#icon","title":"Icon","text":"<p><code>icon: ICON_FILE_NAME</code></p> <p>An image file is loaded on the deck key if it is capable of displaying images.</p>"},{"location":"Reference/Button%20Representations/Basic/#attributes","title":"Attributes","text":""},{"location":"Reference/Button%20Representations/Basic/#frame","title":"frame","text":"<pre><code>icon: isi\nframe:\n\tframe: frame_image.png\n\tframe-size: [256, 256]\n\tcontent-size: [128, 128]\n\tcontent-offset: [64, 64]\n</code></pre> <p>A <code>frame</code> is a special \"background\" image that is first loaded, and  the icon itself is laid over the background image. In the above example, icon <code>isi</code> will be resized to 128x128px and placed (pasted, laid over) at position (64, 64) in the frame image.</p> <p></p> <p>The purpose of framed icon is to provide a uniform icon representation (the frame) with varying inner content (the icon itself).</p> <p>It is different from a textured background because it allows for icon placement and resizing before pasting over the underlying image frame.</p>"},{"location":"Reference/Button%20Representations/Basic/#icontext","title":"IconText","text":"<p><code>text: \"SOME\\nTEXT\"</code></p> <p>An image file is created with a uniform background color or texture and text laid over.</p> <p>The text laid over the button should not be confused with the label. The text laid over is additional to the label, and can be dynamic to display a changing value like the heading of the aircraft or the amount of fuel left in a tank.</p>"},{"location":"Reference/Button%20Representations/Basic/#attributes_1","title":"Attributes","text":"<p><code>text-bg-color: lime</code></p> <p>Background color of the image or icon where the text is displayed. Default background color is cockpit color.</p> <p><code>text-*: value</code></p> <p>Values for font, font size, color, and position of the text on the image.</p>"},{"location":"Reference/Button%20Representations/Basic/#text-substitution","title":"Text Substitution","text":"<p>It is possible to use subsitution of coded string in text values:</p> <ul> <li><code>${dataref-path}</code> is replaced by the scalar value of the dataref pointed by <code>dataref-path</code>.</li> <li><code>${formula}</code> is replaced by the value computed in the <code>formula</code> .</li> <li><code>${state:name}</code> is replaced by the scalar value of the button' state <code>name</code>.</li> </ul> <p>Note: A Text string value is not a formula and is not evaluated. Above strings are simply substituted.</p> <pre><code>text: ${formula}\ntext-format: 4.2f\nformula: 3.14 2 ${dataref-path} * *\n</code></pre> <p>Will produce an icon with text value \"<code>3.14</code>\"  text in the middle.</p>"},{"location":"Reference/Button%20Representations/Basic/#multiicons","title":"MultiIcons","text":"<p><code>multi-icons</code></p> <pre><code>multi-icons:\n  - ICON_FILE_1\n  - ICON_FILE_2\n</code></pre> <p>Multiple icon files are displayed according to the value of the button.</p> <p>For example, for an OnOff activation type there may be two icons for On and Off positions; for a UpDown activation type, there may be one icon for each stop position.</p> <p>No attribute.</p> <p>Multi</p> <p>Cockpitdecks offers representations like multi-icons, multi-texts, and even multi-buttons always on the same pattern. The multi- keyword means that there are several representations of the same type available in the button definition. The value of the button determine which one if chosen for representation. If the value of the button does not point at a valid index in the list, the representation is ignored.</p>"},{"location":"Reference/Button%20Representations/Basic/#multitexts","title":"MultiTexts","text":"<p><code>multi-texts</code></p> <pre><code>\tmulti-texts:\n\t\t- text: Option 1\n\t\t  text-color: green\n\t\t- text: Option 2\n\t\t  text-color: amber\n\t\t- text: ${aicraft/some_value}\n\t\t  text-format: \"Limit reached {4.1f}\"\n\t\t  text-color: red\n\t\t  text-font: DIN Bold\n\t\t  text-position: tr\n\tformula: ${dataref_for_text_selection}\n</code></pre> <p>A Multitext attributes contains a list of IconText-like attributes (a list of text block) where each text block can contain attributes like in an IconText text block.</p> <p>A single text block is selected according to the value of the button.</p> <p>In the above example, the formula <code>${dataref_for_text_selection}</code> return 2, the second text block</p> <pre><code>\t\t  text: ${aicraft/some_value}\n\t\t  text-format: \"Limit reached {4.1f}\"\n\t\t  text-color: red\n\t\t  text-font: DIN Bold\n\t\t  text-position: tr\n</code></pre> <p>will be selected and displayed as a IconText.</p>"},{"location":"Reference/Button%20Representations/Basic/#attributes_2","title":"Attributes","text":"<p>None</p>"},{"location":"Reference/Button%20Representations/Basic/#important-note","title":"Important Note","text":"<p>The selection of the text block must be performed by a formula and not a dataref.</p> <p>When a formula is present in the attributes of a button, it is always favored over a list of datarefs, even if the list contains only one dataref. (If there a button uses multiple datarefs and there is no formula, the value that is returned for that button is a dictionary of all dataref values.)</p>"},{"location":"Reference/Button%20Representations/Basic/#multi-buttons","title":"Multi-Buttons","text":"<p>See Multi-Buttons and Mosaic.</p>"},{"location":"Reference/Button%20Representations/Basic/#led","title":"LED","text":"<p><code>led: led</code></p> <p>Turns a single LED light On or Off depending on the button's value.</p>"},{"location":"Reference/Button%20Representations/Basic/#coloredled","title":"ColoredLED","text":"<p><code>led: colored</code></p>"},{"location":"Reference/Button%20Representations/Basic/#attributes_3","title":"Attributes","text":"<p><code>color: orange</code></p> <p>Turns a single LED light On or Off depending on the button's value. The color of the LED is determined by the color attribute.</p> <p>The <code>color</code> attribute can use a formula to determine the color (single hue value in 360\u00b0 circle.)</p>"},{"location":"Reference/Button%20Representations/Basic/#switches","title":"Switches","text":"<p>Switches are drawings often used by OnOff activations that can be used in replacement of icons.</p> <p>Switches is a drawing of a simple two or three-way switch. Circular switches are multi-value rotation switches or selectors. Push switches are simpler two state push button.</p>"},{"location":"Reference/Button%20Representations/Basic/#deck-specific-displays","title":"Deck Specific Displays","text":"<p>Some decks have particular LCD displays. Cockpitdecks designed specific activations and representations for those. See here:</p> <ul> <li>Deck Specific \u2013 Stream Deck</li> <li>Deck Specific \u2013 Loupedeck</li> <li>Deck Specific \u2013 X-Touch Mini</li> </ul>"},{"location":"Reference/Button%20Representations/Basic/#other-representations","title":"Other Representations","text":"<p>Above switches are special instances of dynamically drawn representations.</p> <p>There are other dynamically drawn represetations for displaying data, or weather information.</p> <p>The sky is the limit.</p>"},{"location":"Reference/Button%20Representations/Basic/#representation-validity","title":"Representation Validity","text":"<p>Each Representation has a <code>is_valid()</code> method that checks whether all necessary attributes or parameters are available to it and valid. If the validity function fails, a warning is reported and the button is not rendered. The inspect keyword used to verify the validity of the representation is <code>valid</code>.</p> <p>Each Representation has an <code>describe()</code> method that explains what it displays in plain English. The inspect keyword used to describe the representation is <code>what</code>.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/","title":"ColoredLed","text":"<p>ColoredLed buttons are color capable led behind a transparent or mask button.</p> <p>They are either on or off, with a RGB color.</p> <pre><code>colored-led: blue\n</code></pre>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#iconside","title":"IconSide","text":"<p><code>icon-side: ICON_FILE_NAME</code></p> <p>An IconSide is a special icon for LoupedeckLive devices, used on either side of the main panel. IconSide have particular display capabilities to cope with their specifics, sizes, and their positions that allow to display information regarding the nearby encoders.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#attributes","title":"Attributes","text":"<p><code>labels</code></p> <p>Labels that are displayed on the icon.</p> <p><code>label-positions</code></p> <p>Label anchor position expressed in percentage of the 100% height of the side image.</p> <p>Note: There might be similar icons to control the display of other, larger display like the Streamdeck Plus bottom LCD display.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#larger-displays","title":"Larger Displays","text":"<p>Some decks exhibit displays that are larger than a key with and iconic representation. Those displays often have touch and swipe capabilities. This led to design activations and representations specific to these larger displays to be used with your favourite flight simulation software.</p> <p>Please note, for example, that the LoupedeckLive deck has a unique central display screen accepting touches and swipes. A plastic grid cover gives the illusion that there are two vertical side screens and 12 \u00ab\u00a0keys\u00a0\u00bb in the middle, but underlying is a unique 480 \u00d7 360 pixel screen. Each key is a 90 \u00d7 90 pixel portion of that screen.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#usage","title":"Usage","text":"<p>Larger screens can be used in two different ways:</p> <ul> <li>As a whole, unique, larger display surface,</li> <li>As a set of adjacent buttons covering the entire surface.</li> </ul> <p>In the later case, the specificity of the display is not apparent, and resulting buttons are treated as regular keys with iconic image display (with different sizes sometimes.) This is called a Mosaic.</p> <p>When considered as a single larger display, it is difficult to remain generic since each display will have special size, location, and behavior. Cockpitdecks buttons assigned to those specific display are therefore also very specific.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#activations","title":"Activations","text":"<p>Having no activation at all to use those display solely for displaying purposes is always an option. However simple activations can make the passive display a lot more enjoyable.</p> <p>For exemple, if the display is capable, touching or swiping the display can be used to change its content. On startup, display heading, swipe left, display speed, swipe right display heading, etc.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#touch","title":"Touch","text":"<p>Touch is similar to button press activation and can be used as such.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#swipe","title":"Swipe","text":"<p>Swipe returns movement start and end position and timing. These values can be interpreted to model a limited set of movements like swipe left, right or up, down. Raw values can also be used as an increasing or decreasing sliding cursor.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#representations","title":"Representations","text":"<p>Given the sizes of each display, representations fitting those displays will always remain very specific.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#larger-horizontal-displays","title":"Larger Horizontal Displays","text":""},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#airbus-flight-control-unit","title":"Airbus Flight Control Unit","text":"<p>The highly specific Airbus FCU representation reproduces the central display with all possible modes.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#airbus-flight-mode-annunciators","title":"Airbus Flight Mode Annunciators","text":"<p>The Airbus FMA displays the five annunciators on top of the Primary Flight Display (PFD).</p> <p>There are two modes of display. The first one make use of a larger, horizontal display and shows all five annunciators next to each other. The second one use five keys with iconic display and show one annunciator on one key. In both cases, data necessary for display is fetched only once, the first annunciator being the master one with all data, other annunciators are slave ones and fetch their data from the master annunciator.</p> <p>Airbus FMA display is a pure display with no activation associated with it.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#larger-vertical-displays","title":"Larger Vertical Displays","text":"<p>On LoupedeckLive decks, vertical displays exploit their proximity to the lateral encoder dials to present direct encoder feedback. For example, next to the QNH adjustment encoder, the current atmospheric pressure is displayed. Pushing the encode switches between Standard pressure and local ambiant pressure.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Loupedeck/#icons","title":"Icons","text":"<p>Image or drawn icons (especially text messages) are also an alternative way to decorate those displays. One can imagine displaying ATC instructions on a tape display, with swipe actions to acknowledge messages.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/","title":"ColoredLed","text":"<p>ColoredLed buttons are color capable led behind a transparent or mask button.</p> <p>They are either on or off, with a RGB color.</p> <pre><code>colored-led: blue\n</code></pre> <p>The Elgato Stream Deck Neo has two small colored led on each side of the LCD display.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#larger-displays","title":"Larger Displays","text":"<p>Some decks exhibit displays that are larger than a key with and iconic representation. Those displays often have touch and swipe capabilities. This led to design activations and representations specific to these larger displays to be used with your favourite flight simulation software.</p> <p>Please note, for example, that the LoupedeckLive deck has a unique central display screen accepting touches and swipes. A plastic grid cover gives the illusion that there are two vertical side screens and 12 \u00ab\u00a0keys\u00a0\u00bb in the middle, but underlying is a unique 480 \u00d7 360 pixel screen. Each key is a 90 \u00d7 90 pixel portion of that screen.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#usage","title":"Usage","text":"<p>Larger screens can be used in two different ways:</p> <ul> <li>As a whole, unique, larger display surface,</li> <li>As a set of adjacent buttons covering the entire surface.</li> </ul> <p>In the later case, the specificity of the display is not apparent, and resulting buttons are treated as regular keys with iconic image display (with different sizes sometimes.) This is called a Mosaic.</p> <p>When considered as a single larger display, it is difficult to remain generic since each display will have special size, location, and behavior. Cockpitdecks buttons assigned to those specific display are therefore also very specific.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#activations","title":"Activations","text":"<p>Having no activation at all to use those display solely for displaying purposes is always an option. However simple activations can make the passive display a lot more enjoyable.</p> <p>For exemple, if the display is capable, touching or swiping the display can be used to change its content. On startup, display heading, swipe left, display speed, swipe right display heading, etc.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#touch","title":"Touch","text":"<p>Touch is similar to button press activation and can be used as such.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#swipe","title":"Swipe","text":"<p>Swipe returns movement start and end position and timing. These values can be interpreted to model a limited set of movements like swipe left, right or up, down. Raw values can also be used as an increasing or decreasing sliding cursor.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#representations","title":"Representations","text":"<p>Given the sizes of each display, representations fitting those displays will always remain very specific.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#larger-horizontal-displays","title":"Larger Horizontal Displays","text":""},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#airbus-flight-control-unit","title":"Airbus Flight Control Unit","text":"<p>The highly specific Airbus FCU representation reproduces the central display with all possible modes.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#airbus-flight-mode-annunciators","title":"Airbus Flight Mode Annunciators","text":"<p>The Airbus FMA displays the five annunciators on top of the Primary Flight Display (PFD).</p> <p>There are two modes of display. The first one make use of a larger, horizontal display and shows all five annunciators next to each other. The second one use five keys with iconic display and show one annunciator on one key. In both cases, data necessary for display is fetched only once, the first annunciator being the master one with all data, other annunciators are slave ones and fetch their data from the master annunciator.</p> <p>Airbus FMA display is a pure display with no activation associated with it.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#larger-vertical-displays","title":"Larger Vertical Displays","text":"<p>On LoupedeckLive decks, vertical displays exploit their proximity to the lateral encoder dials to present direct encoder feedback. For example, next to the QNH adjustment encoder, the current atmospheric pressure is displayed. Pushing the encode switches between Standard pressure and local ambiant pressure.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20Stream%20Deck/#icons","title":"Icons","text":"<p>Image or drawn icons (especially text messages) are also an alternative way to decorate those displays. One can imagine displaying ATC instructions on a tape display, with swipe actions to acknowledge messages.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20X-Touch%20Mini/","title":"EncoderLEDs","text":"<p><code>led: encoder-leds</code></p> <p>(Specific to the X-Touch Mini Encoders.)</p> <p>MultiLeds are LED-based display that use more than one LED for reporting information.</p> <p>X-Touch Mini encoders, for example, are surrounded by 11 LED that can be lit individually.</p> <p></p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20X-Touch%20Mini/#attributes","title":"Attributes","text":"<p><code>led-mode: fan</code> or <code>led-mode: 2</code>; name or number</p> <p>Valid modes are:</p> <ol> <li>Single</li> <li>Trim</li> <li>Fan</li> <li>Spread</li> </ol> <p>The value of the button determine how many leds will be displayed (0 to 11).</p> <p>X-Touch Mini MACKIE MODE</p> <p>To send feedback instruction to the deck, two modes of interactions are available: Direct mode, and Mackie Mode. Cockpitdecks uses Mackie Mode which makes deck interaction easier and standard through the MIDI protocol. However, in Mackie Mode, only 11 of the 13 available encoder LEDs are accessible. It is not possible to access LED 0 and 13, only 1 to 12.</p>"},{"location":"Reference/Button%20Representations/Deck%20Specific%20%E2%80%93%20X-Touch%20Mini/#value-mapping","title":"Value Mapping","text":"<p>If nothing is specified, raw button value is used.</p> <p>If <code>value_min</code> and <code>value_max</code> are specified in the encoder attribute, the Encoder representation performs a linear mapping between (<code>value_min</code>, <code>value_max</code>) and the range of valid values (0, 10).</p> <p>A Warning is issued if the value is out of the range 0-11.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/","title":"Drawn Buttons \u2013 Charts","text":"<p>Cockpitdecks allows to represent a dataref value on a simple chart, or rather, a simple Sparkline. Up to three Sparklines can be combined on a single chart icon.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#sparkline","title":"Sparkline","text":"<p>A Sparkline is a chart element that plot a single variable over time.</p> <p>A Sparkline keeps a number of points to be plotted.</p> <p>The maximum number of point that can be plotted is either directly supplied, or determined by the time width of the chart. (Points older that the oldest point on the chart are discarded.)</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#sparkline-representation","title":"Sparkline Representation","text":"<p>The list of time-series data can be plotted as</p> <ul> <li>Points: A marker at each position</li> <li>A Curve: A simple line</li> <li>An histogram: A set of vertical bars</li> </ul> <p></p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#data-acquisition","title":"Data Acquisition","text":"<p>A Sparkline is based on a value like a button value.</p> <p>The value is either fetched at regular interval or updated each time it changes.</p> <p>Therefore, a chart will be updated either at regular interval, if at least one of the data is fetched at regular internal, or whenever the dataref value has changed.</p> <p>There is a maximum update/refresh rate fixed at 4 Hz (\u00bc of a second.)</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#chart-width","title":"Chart Width","text":"<p>The horizontal axis of charts is always the time.</p> <p>The maximum time that is displayed on the total width of the chart can be determined either by directly supplying a maximum time width, or by supplying a number of points to keep, spaced at a regular interval.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#example","title":"Example","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#performance-notes","title":"Performance Notes","text":"<p>Charts a little icons that can involve a lot of CPU cycles, from dataref collection, change detection, graph data update and then graph update.</p> <p>We limit the update of graphs to 4 Hz maximum (that is 4 times per seconds).</p> <p>There is a limit on the number of Sparklines (graphs) in a single icon: 3.</p> <p>There is also a limit on the total number of Sparklines that can be use at one point in time: 10, all displayed decks combined.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#examples-of-use","title":"Examples of Use","text":"<ul> <li>Fuel per tank and fuel flow per engine.</li> <li>Autopilot heading vs. actual aircraft heading.</li> </ul>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#internal-uses","title":"Internal uses","text":"<ul> <li>Performance data like speed to UDP packet acquisition</li> <li>Speed of deck rendering</li> <li>and so on.</li> </ul>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Charts/#see-also","title":"See Also","text":"<p>Drawn Buttons \u2013 Gauges and Tapes</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Gauges%20and%20Tapes/","title":"Drawn Buttons \u2013 Gauges and Tapes","text":"<p>Cockpitdecks provides a few, drawing-based, icons and animations to complement your cockpit or dashboard.</p> <p>The following icons or animations provide each a limited set of customization attributes. Please recall that Cockpitdecks is not a drawing tool, but rather a template tool with custom icons ready to be used with a few customization attributes.</p> <p>In each case, we will detail its intended use and the limits of the icon provided.</p> <p>Also, these special icons exhibit particular design techniques that can be extended by Cockpitdecks Representation developers.</p> <p>Work In Progress</p> <p>These icons are currently basic but do provide their function. They have limited customization, but these can be added over time later if necessary or requested.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Gauges%20and%20Tapes/#display-tape","title":"Display Tape","text":"<p>A Tape is a type of display that appears like a tape being slid under the screen. Here are famous display tapes on an Airbus Primary Flight Display:</p> <ul> <li>Speed tape on the left,</li> <li>Altitude tape on the right,</li> <li>Vertical speed gauge indicator on the far right,</li> <li>Heading tape at the bottom.</li> </ul> <p></p> <p>Tapes are often fitted With colorful marks that represent critical values for the indication being displayed.</p> <p>Display tapes should not be confused with duct tapes, often used to fix aircrafts.</p> <p></p> <p>Duct tapes have one configuration attribute: <code>duct-tape-color</code>with default value <code>silver-grey</code>.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Gauges%20and%20Tapes/#gauge","title":"Gauge","text":"<p>Cockpitdecks provides a small set of customizable gauge. Since gauges are rendered on small, often square, LCD screens, they are very limited in detail.</p> <p>One gauge displays one value, and it updated when the value change.</p> <p>A special gauge is the heading gauge (called <code>rose</code>) which show the heading on a compass. Compass can be adjusted North, on autopilot value, or on actual aircraft value (compass or true).</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Gauges%20and%20Tapes/#charts","title":"Charts","text":"<p>Cockpitdecks provides a limited set of time-based display charts, also often called sparklines.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/","title":"Drawn Buttons \u2013 Switches","text":"<p>A few set of special buttons are dynamically drawn based on attributes.</p> <p>Attributes are numerous to allow for design flexibility, however default values will always provide a usable representation.</p> <p>The idea of drawn buttons came after the flexibility discovered when designing Annunciators. All annunciators are drawn buttons: Texts, frames, basic icons\u2026</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#switch","title":"Switch","text":"<p>A Switch is a drawing of a two or three-way switch on an image key.</p> <p>Switches are often used by On/Off activations.</p> <p>They can be used in replacement of an icon.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#attributes","title":"Attributes","text":"<p>Ticks are marks on the side of the switch to label corresponding positions. The tick underline is the visual line line that connect all ticks.</p> <pre><code>    switch:\n      switch-style: 3dot\n      tick-underline: true\n      tick-label-size: 36\n      tick-label-font: DIN Bold\n      tick-labels:\n        - \"ON\"\n        - \"MID\"\n        - \"OFF\"\n    options: 3way,horizontal\n</code></pre> <p>Switches, Circular Switches, and Push Switches have numerous attributes in common to control their appearance. See Circular Switches for a list.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#switch-model","title":"Switch Model","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#switches-as-drawn","title":"Switches as Drawn","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#options","title":"Options","text":"<p><code>options: 3way</code></p> <p>Defines a switch with 3 positions, 2 extremities, and one middle position.</p> <p><code>options: horizontal</code></p> <p>Draws and manipulates the switch horizontally rather than vertically.</p> <p><code>options: hexa</code></p> <p>Draws an hexagonal base to mimic Airbus switch inserts and fixation instead of a round base (default).</p> <p><code>options: invert</code></p> <p>Inverts On and Off positions.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#circular-switch","title":"Circular Switch","text":"<p>A Circular Switch is a rotating knob/switch used to represent a rotation switch. It is displayed on an image key. Circular switches are often used by Up/Down activation to cycle and bounce through the set of possible values.</p> <p>They can be used in replacement of multi-icons.</p> <pre><code>    circular-switch:\n      switch-style: normal\n      down: 20\n      left: 20\n      tick-from: 135\n      tick-to: 315\n      tick-space: 20\n      tick-underline-width: 12\n      tick-color: red\n      tick-underline-color: red\n      needle-color: lime\n      needle-length: 130\n      tick-labels:\n        - \"0\"\n        - \"1\"\n        - \"2\"\n        - \"3\"\n        - \"4\"\n        - \"5\"\n</code></pre>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#attributes_1","title":"Attributes","text":"<ul> <li>Button-size</li> <li>Button-stroke-color</li> <li>Button-fill-color</li> <li>Button-underline-color</li> <li>Button-underline-width</li> <li>Needle-color</li> <li>Needle-width</li> <li>Needle-underline-color</li> <li>Needle-underline-width</li> <li>Stops</li> <li>Tick-labels</li> <li>Label-font</li> <li>Label-color</li> <li>Label-size</li> <li>Tick-color</li> <li>Tick-width</li> <li>Thik-underline-color</li> <li>Thik-underline-width</li> <li>Label-space</li> <li>Thik-Space</li> <li>Top, bottom, left, right</li> </ul>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#circular-switch-models","title":"Circular Switch Models","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#circular-switches-as-drawn","title":"Circular Switches as Drawn","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#push-button-and-knob","title":"Push Button and Knob","text":"<ul> <li><code>button-size</code></li> <li><code>button-color</code></li> <li><code>button-off-color</code></li> <li><code>witness-fill-color</code></li> <li><code>witness-stroke-color</code></li> <li><code>witness-stroke-width</code></li> </ul> <p>A PushButton is a simple button that can be used to trigger a command. It can be On or Off, and it's state can be reflected graphically by adjusting its color for instance.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#push-button-models","title":"Push Button Models","text":"<p>Later.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#push-buttons-and-knob-as-drawn","title":"Push Buttons and Knob as Drawn","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#knob","title":"Knob","text":"<p>Knobs are circular rotating buttons used to set values by rotating the button clockwise or counterclockwise. Although they can be drawn and \u00ab\u00a0turn\u00a0\u00bb according to dataref values, they cannot currently be used with activations to trigger their rotation. Real, physical rotation knobs must be used instead. (Mimicking a rotation knob with a push button is a difficult task that requires awkward manipulations such as long pushes. We may later offer a possibility to allow for rotation knows on icon button, because the surface of some icon button (LoupedeckLive) reacts to touch and swipes. It would therefore be possible to detect precisely where the button was touched (left, right, up, center\u2026) and assign activations accordingly.)</p> <p>So we shall just say that Knob icons can be used as simple push button, with an alternative representation.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons%20%E2%80%93%20Switches/#see-also","title":"See Also","text":"<p>Switch Drawing Attributes</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/","title":"Drawn Buttons","text":"<p>A few set of special buttons are dynamically drawn based on attributes.</p> <p>Attributes are numerous to allow for design flexibility, however default values will always provide a usable representation.</p> <p>The idea of drawn buttons came after the flexibility discovered when designing Annunciators. All annunciators are drawn buttons: Texts, frames, basic icons\u2026</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#data","title":"Data","text":"<p>A DataButton is a particular case of a display only button.</p> <p></p> <p>A DataButton displays four informations:</p> <ol> <li>A single letter or icon from a character font, (we can use icon fonts,)</li> <li>A value, and optionally the trend of the value (rising, decreasing, statuquo)</li> <li>A unit short text (static)</li> <li>An optional percentage bar of the value relative to a 100% value</li> <li>A small text string (typically ~20 characters maximum) called the bottom line.</li> </ol> <pre><code>  - index: 4\n    name: Fuel Level\n    type: none\n    label: Fuel\n    label-size: 10\n    label-position: ct\n    data:\n      icon-name: \"gas-pump\"\n      data: 75.4256\n      data-format: \"{:02.0f}\"\n      data-font: DIN Condensed Light\n      data-size: 24\n      data-unit: \"%\"\n      data-progress: 100\n      data-trend: 0\n      dataref-rpn: ${sim/aircraft/fuel_level} 10 *\n      bottomline: Go Faster\n</code></pre> <p>Data button representation aims at providing a dashboard-like single value highlighted in a deck key image, very much like common web dashboards.</p> <p></p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#decor","title":"Decor","text":"<p>Decor representation displays simple connected lines to populate unused icons. They can be used to display visual helper lines that connect annunciators (bleed air, hydraulics, etc.) The idea behind Decor icons is to provide a quick alternative to blank icons when filling large decks with numerous keys.</p> <p>Decor icon are governed by two parameters <code>type</code> and <code>code</code>. The type is a category of drawings. The code determine which drawing will be made in that category.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#lines","title":"Lines","text":"<p><code>type: line</code></p> <p>Decor icons of type <code>line</code> display a single horizontal or vertical line, and corner angles. The <code>code</code> determine which line get drawn.</p> <p></p> <pre><code>type: line\ncode: H\n</code></pre> <p></p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#segments","title":"Segments","text":"<p><code>type: segment</code></p> <p>Decor icons of type <code>segment</code> display segments that are present in the <code>code</code> attribute.</p> <p></p> <p>For example:</p> <pre><code>type: segment\ncode: BGNSIL0123\n</code></pre> <p>will light (turn on) segments B, G, N\u2026 3, which correspond will result in a drawing like the one proposed by the <code>H</code> code in type <code>line</code> above.</p> <p></p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#common-decor-attributes","title":"Common Decor Attributes","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#line-width","title":"Line width","text":"<p><code>width: 10</code></p> <p>Width of the line.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#color","title":"Color","text":"<p><code>color: red</code></p> <p>Color of the line.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#aircraft","title":"Aircraft","text":"<p>The aircraft representation displays the name of the aircraft (ICAO type designator) located in the dataref: <code>sim/aircraft/view/acf_ICAO</code>. All 4 (or more) characters are fetched and displayed in the icon. (We currently limit fetching the first four characters only, which should be sufficient for ICAO aircraft code designator.)</p> <p>The representation attribute is</p> <pre><code>    aircraft:\n      text-font: B612-Bold\n      text-size: 32\n</code></pre> <p>If a <code>set-dataref</code> is present, the aircraft representation increases the value of that dataref by one each time the aircraft name changes in the <code>sim/aircraft/view/acf_ICAO</code>. This can be used by other button or by Cockpitdecks itself to be notified of an aircraft or aircraft model change.</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#weather","title":"Weather","text":"<p>(Please refer to the dedicated Weather Representation page.)</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#metar","title":"METAR","text":"<p>The WeatherButton is a special data button that displays METAR information of the station closest to the aircraft in a small, iconic representation.</p> <pre><code>  - index: 8\n    name: METAR\n    type: weather\n    station: OTHH\n</code></pre> <p></p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#taf","title":"TAF","text":"<p>(To do. Cycle through forecast each time button is pressed.)</p>"},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#current-x-plane-weather","title":"Current X-Plane Weather","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#region","title":"Region","text":""},{"location":"Reference/Button%20Representations/Drawn%20Buttons/#aircraft_1","title":"Aircraft","text":""},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/","title":"Multi Buttons and Mosaic","text":"<p>Multi-Buttons and Mosaic allow simultaneous representation of several buttons.</p> <p>Multi-buttons selects one button to represent from a list of buttons.</p> <p>Mosaic represent them all at once, simultaneously.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#mosaic","title":"Mosaic","text":"<p>A Mosaic is a trick used to split a large button into smaller ones.</p> <p>A Mosaic can, in some regards, be considered as a special case of a Page. Yes, a small page with its own set of individual buttons.</p> <p>Very much like a Page, a Mosaic contains buttons, with their own behavior (activation) and rendering (representation). However, at the end, all button rendering are sticked together, like tiles on a mosaic, to render on the larger button (the mosaic).</p> <p>Typical example of Mosaic are: LoupedeckLive side buttons: They are larger, 60x270 pixels, and can be \"split\" into smaller buttons, like a column of 4 60x60 buttons, with 10 pixels between each. A Streamdeck Plus touchscreen, which is 100x800 pixel in size, can either be split into 8 buttons of 100x100 each, or less buttons with more space between them.</p> <p></p> <p></p> <p></p> <p>Mosaic representation has been designed so that it requires the minimal adjustment to Cockpitdecks. Here are some design constraints.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#activation","title":"Activation","text":"<p>When touching the Mosaic, we need to know where the contact occurred because we have to determine which tile was activated. Therefore, the only valid activation for a Mosaic is swipe event, because the swipe event reports the coordinates (x, y) where the contact occurred.</p> <p>Similarly, for tiles, for simplicity, we will only allow push and long-push events. We may, in future releases, allow for more events but cases will be requested before we make Mosaic too complicated.</p> <p>In a nutshell, the swipe activation of the Mosaic gets transformed into a push, or long-push representation of a tile.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#representation","title":"Representation","text":"<p>The Mosaic representation will be an image. As its name says, it will be composed of smaller tiles, that are also images.</p> <p>Therefore the representation of a button inside a Mosaic, a tile, must produce an image, like icon, all drawing representations (that indirectly create images), etc.</p> <p>In a nutshell, the representation of the Mosaic is built from the representations of all tiles that are put together at their proper offset position.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#deck-type-definition","title":"Deck Type Definition","text":"<p>Here is an example of Deck Type definition of a mosaic for the LoupedeckLive left screen.</p> <pre><code>  - name: left\n    action:\n      - swipe\n    feedback: image\n    dimension:\n      - 60\n      - 270\n    layout:\n      offset:\n        - 120\n        - 59\n    options: corner_radius=4\n    # The left button is composed of 3 sub-buttons:\n    mosaic:\n      - name: 0\n        # prefix of mosaic buttons should match name of parent mosaic\n        # names will be left0, left1, left2\n        prefix: left\n        action:\n          - push\n        feedback: image\n        dimension:\n          - 60\n          - 60\n        repeat: [1, 3]\n        layout:\n          offset:\n            - 0\n            - 15\n          spacing:\n            - 0\n            - 30\n</code></pre> <p>In the above example, the left 60 \u00d7 270 pixel LCD screen will be split into 3 60 \u00d7 60 pixel icons with 30 pixels empty space between themselves.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#other-examples","title":"Other Examples","text":"<p>One Deck Type can define one or more mosaic for its large LCD displays. For example, a 800x100 pixel large LCD can propose a Mosaic of 4 x 200x100 pixels.</p> <p>If a user prefers an alternate Mosaic of 8 x 100x100 pixels, it is necessary to create another Deck Type, with another name, where the alternate mosaic is expressed.</p> <p>The same device, whether physical or \"virtual\" (through a Web Deck), can be declined in several Deck Types to offer a modular representation to Cockpitdecks.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#button-definition","title":"Button Definition","text":""},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#mosaic_1","title":"Mosaic","text":"<pre><code>  - index: left\n    type: mosaic\n    label: MosaiK\n    mosaic:\n      tiles:\n        - index: m0\n          (...)\n</code></pre> <p>The activation (<code>type</code>) must be <code>mosaic</code>. This activation transforms the swipe event into push events.</p> <p>The representation must be <code>mosaic</code>. The representation collects the representation of each tile and compose the final image that is sent for display.</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#tiles","title":"Tiles","text":"<pre><code>  - index: left\n    type: mosaic\n    label: MosaiK\n    mosaic:\n      tiles:\n        - index: m0\n          name: RELOAD\n          type: reload\n          icon: RELOAD\n          label: RELOAD\n          label-position: ct\n(more clever and realist button later, this is a working placeholder)\n</code></pre>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#representation_1","title":"Representation","text":"<p>(picture, later)</p>"},{"location":"Reference/Button%20Representations/Multi-Buttons%20and%20Mosaic/#multi-buttons","title":"Multi-Buttons","text":"<p>The multi-button representation defines a list of buttons.</p> <p>The value of the main hosting button determine which button gets chosen from the list (index value).</p>"},{"location":"Reference/Button%20Representations/Switch%20Drawing%20Attributes/","title":"Switch Drawing Attributes","text":"<p>Names are self explanatory \ud83d\ude09.</p> <pre><code>angular_step\nbase_fill_color\nbase_size\nbase_stroke_color\nbase_stroke_width\nbase_underline_color\nbase_underline_width\nbgcolor\nbutton_dent_extension\nbutton_dent_size\nbutton_dents\nbutton_fill_color\nbutton_name\nbutton_size\nbutton_stroke_color\nbutton_stroke_width\nbutton_underline_color\nbutton_underline_width\ncockpit_color\ncockpit_texture\ncode\ndatarefs\ndecor\ndecor_color\ndecor_width_horz\ndecor_width_vert\ndouble_icon\ndraw_labels\ndraw_left\ndraw_scale\ndraw_ticks\ndraw_up\nhandle_base_fill_color\nhandle_fill_color\nhandle_off_fill_color\nhandle_off_stroke_color\nhandle_off_stroke_width\nhandle_size\nhandle_stroke_color\nhandle_stroke_width\nhandle_tip_fill_color\nhexabase\nicon_color\nicon_texture\ninvert\nlabel_opposite\nmark_fill_color\nmark_off_fill_color\nmark_off_stroke_color\nmark_stroke_color\nmark_underline_color\nmark_underline_outer\nmark_underline_width\nmark_width\nmove_and_send\nneedle_color\nneedle_length\nneedle_start\nneedle_tip\nneedle_tip_size\nneedle_underline_color\nneedle_underline_width\nrotation\nscrew_rot\nswitch\nswitch_length\nswitch_style\nswitch_width\ntexture\nthree_way\ntick_color\ntick_from\ntick_label_color\ntick_label_size\ntick_label_space\ntick_labels\ntick_length\ntick_space\ntick_steps\ntick_to\ntick_underline_color\ntick_underline_width\ntick_width\ntop_fill_color\ntop_stroke_color\ntop_stroke_width\ntype\nvertical\n</code></pre>"},{"location":"Reference/Button%20Representations/Toliss%20Specific%20Representations/","title":"Toliss Specific Representations","text":"<p>Toliss Airbus Aircrafts A319, A320, A321, and A340 share numerous functions, with particularities or specialties. They share a common set of functions, displays, or dataref values. This has led to the development of very specific buttons representation.</p> <ul> <li>Flight Control Unit display (in both horizontal and vertical modes)</li> <li>Flight Management Annunciators display</li> </ul> <p>These buttons are highly specific and would probably not be usable in other aircrafts. However the very specific code used to produce these buttons is an example for alternative development.</p> <p>These Representations are more complex than they appear. While very comparable on appearance, numerous technical details and variant make these representations complex.</p>"},{"location":"Reference/Button%20Representations/Toliss%20Specific%20Representations/#toliss-airbus-fcu","title":"Toliss Airbus FCU","text":"<p>ToLiss FCU representation is actually a set of representations for Loupedeck LoupedeckLive side LCD display. As shown on the capture below, it vertically presents FCU data next to the encoders.</p> <p></p> <p>There also is a horizontal version for the Stream Deck + horizontal display.</p> <p></p>"},{"location":"Reference/Button%20Representations/Toliss%20Specific%20Representations/#toliss-airbus-fma-display","title":"Toliss Airbus FMA Display","text":"<p>The specific ToLiss FMA representation is made for long horizontal displays, like Stream Deck + (plus) LCD display.</p> <p></p> <p>Page Switch</p> <p>It is easy to configure the LCD screen to change page between \"FCU\" and \"FMA\" allowing both screen to co-exist.</p> <p>In the FMA page:</p> <pre><code>  - index: touchscreen\n    type: page\n    page: fcu\n</code></pre> <p>and in the FCU page:</p> <pre><code>  - index: touchscreen\n    type: page\n    page: fma\n</code></pre>"},{"location":"Reference/Button%20Representations/Toliss%20Specific%20Representations/#individual-fma","title":"Individual FMA","text":"<p>The FMA display can also be used to display a single FMA on a smaller square icon. 5 small square icons can be used to display all 5 FMAs.</p> <p></p> <p>It is also possible to display a single FMA (center), and loop through all FMAs by pressing on it.</p> <p>Examples of such configuration are provided for ToLiss aircraft and can be used to develop alternate display on smaller decks.</p>"},{"location":"Reference/Button%20Representations/Weather/","title":"Weather","text":"<p>Cockpitdecks offers different types of Weather Representation, mainly on icons.</p> <p>These Representations have led to development of highly customized activations and representations to exhibit the potentials of Cockpitdecks.</p> <p>While some Representations remain highly generic, like graphical representation of METAR at the closest station, some others are highly specific like those that represent X-Plane simulated weather.</p> <p>There are two sources of information for weather:</p> <ol> <li>External, real weather collected from aviation sources.</li> <li>X-Plane, using the weather as it currently is available in the simulation (called real weather inside X-Plane eco system.) </li> </ol>"},{"location":"Reference/Button%20Representations/Weather/#real-life-weather-now","title":"Real Life Weather (now)","text":"<p>The WeatherMetarIcon provides the real life Metar currently in use at a location in the simulator.</p> <p>If the location is provided through an attribute, it is used and never updated. If no location is provided, the current aircraft location is used. If the aircraft is cruising, the location is updated approximatively every 5 minutes, or when the closest Metar source changes.</p> <p>If no aircraft location is available, a default location is used (currently EBBR, Brussels Airport, Belgium).</p> <pre><code>weather-metar:\n\tstation: LFBO\n\tupdate: 30  # minutes\n</code></pre> <p>Reports the current real life weather at LFBO. If the location is not changed, the Metar updates every <code>update</code> minutes.</p> <p>Metar is from external source</p> <p>The WeatherMetarIcon reflects the real Metar at the time of collection. It does not necessarily reflect the weather as simulated in X-Plane. As a current limitation, only current METAR or TAF report is shown at the time the application runs. Historical data may be offered at a later stage.</p> <p>This Representation is provided as an extension in the cockpitdecks_wm package (wm=weather METAR).</p>"},{"location":"Reference/Button%20Representations/Weather/#terminal-area-forecast","title":"Terminal Area Forecast","text":"<pre><code>weather-taf:\n\tstation: EDDM\n\tupdate: 30  # minutes\n</code></pre> <p>Similarly to METAR, TAF is fetched and shown on an icon as a textual form of the forecast.</p> <p>A TAF usually consists of several forecasts that are presented in turn on \"pages\" of forecast. Each press of the button changes the page.</p>"},{"location":"Reference/Button%20Representations/Weather/#ground-weather-station-plot","title":"(Ground) Weather Station Plot","text":"<p>Station Model is a popular representation of the main weather elements: Weather, wind speed and direction, temperature, pressure, clouds, visibility, etc.</p> <pre><code>weather-station-plot:\n\tstation: LFBO\n\tupdate: 30  # minutes\n</code></pre> <p>The plot model is a graphical representation of the METAR. The same information is used for text and plot.</p>"},{"location":"Reference/Button%20Representations/Weather/#examples","title":"Examples","text":"<p>METAR, TAF and two \u00abStation Model\u00bb plots of weather. Left most icons (EBBR) uses the same METAR, only presentation differs.</p>"},{"location":"Reference/Button%20Representations/Weather/#weather-updates","title":"Weather Updates","text":"<p>If possible, METAR and TAF for a station are temporarily archived and used to present evolution, past and forecast information, very much like real METAR web site.</p> <p>METAR and TAF are updated every 30 minutes on average.</p>"},{"location":"Reference/Button%20Representations/Weather/#location-update","title":"Location Update","text":"<p>If the display of the weather is not fixed to a location, the position of the aircraft in X-Plane is used, although, the weather that is fetched is the real weather at the time of the the day (not the simulated date/time). In this case, the nearest weather station is used for the report. Station position changes if the aircraft moved more than a minimal distance, typically 50 kilometers.</p>"},{"location":"Reference/Button%20Representations/Weather/#x-plane--real-weather-","title":"X-Plane \u00ab Real Weather \u00bb","text":"<pre><code>xp-real-weather\n\tmode: region\n</code></pre> <p>Provides a detailed weather report from all weather-related datarefs.</p> <p>There are two modes: <code>aircraft</code> and <code>region</code>.</p> <p>This representation fetches all weather-related datarefs from the simulator (wind layers, cloud layers, weather conditions, more than 100 datarefs) for a location or region and attempt to automagically generate a METAR from the collected data.</p> <p>To collect and monitor such an amount of datarefs, Cockpitdecks uses the X-Plane Web API, only available from release 12.1.1 onwards.</p> <p>X-Plane Weather</p> <p>X-Plane Weather is currently heavily modified by Laminar. The following representation may not work reliably and may need revisions.</p> <p>This Representation is provided as an extension in the cockpitdecks_xp package (xp=X-Plane, since it is specific to weather as provided by X-Plane).</p>"},{"location":"Reference/Button%20Representations/Weather/#x-plane-weather-station-update","title":"X-Plane Weather Station Update","text":"<p>When using X-Plane flight simulator, a special Observable regularly monitors the position of the aircraft and deduces the closest weather station. The closest weather station ICAO code is stored in the internal variable named <code>weather-station</code>. By subscribing (listening) to that variable changes, a representation can adjust its weather information for the local station.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/","title":"Deck Type for Web Deck","text":"<p>Please read about Deck Type first.</p> <p>Deck Types for Web Decks are regular Deck Types with additional information necessary to draw the deck in a web page.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#web-deck-drawing","title":"Web Deck Drawing","text":"<p>A Web Deck is reproduced in a web page in a navigator window. It mainly consist of</p> <ol> <li>A background</li> <li>Images laid over the background.</li> </ol> <p>Without going into deep details, Cockpitdecks draws web deck elements using the pixel unit as the image sizing element.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#background","title":"Background","text":"<p>The background of the web deck can either be an image or a uniform color. If nothing is supplied, a default light or dark grey color is used.</p> <p>The background of the web deck can have one or two backgrounds, for \"light\" and \"dark\" modes.</p> <p>The attribute <code>background</code> is used for defining a web deck background.</p> <p>When using colors only, it is necessary to specify a size for the web deck. If no size is specified, a default size of 100 \u00d7 100 pixels is used. When using background image, the size of the image is used as the size of the web deck.</p> <pre><code>background:\n  color: \"#FF0000\"\n  alt_color: \"#0000FF\"\n  size: [500, 800]\n</code></pre> <p>The above defines a web deck of size 500 \u00d7 800 pixels, with a light background color of red, and a dark bacground color of blue (<code>#0000FF</code>). Values of color must be valid HTML/CSS color values. Attribute <code>alt_color</code> is optional. If it is not specified, there will be possibility to change light or dark mode.</p> <p>When using colors only, it is mandatory to supply the web deck size through the <code>size</code> attribute.</p> <pre><code>background:\n  image: mcdu.png\n  alternate: mcdu-night.png\n</code></pre> <p>The above defines a web deck with background image mcdu.png. That image will be used for light background. Attribute <code>alternate</code> defines another image that will be used for dark background. Attribute <code>alternate</code> is optional. If it is not specified, there will be possibility to change light or dark mode. Both images should be the same size. (There is no control of this.)</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#overlays","title":"\u00abOverlays\u00bb","text":"<p>Overlays are images laid over the background. There are two types of overlays that can be laid over a web deck background image.</p> <p>First, when a button has an image as a feedback mechanism, its image representation is sent to the web deck, sized according to the Deck Type definition and finally laid over the background at the supplied offset location. The representation of the button, its image, is sent to the web deck for display. It is the exact same image that is sent to the physical deck device, in case the web deck emulates an existing physical deck.</p> <p>Second, some existing physical deck feedback mechanism cannot simply be reproduced on a web deck, but they can easily be drawn. As a precise exemple, let us take a simple LED light. The representation of the physical deck is probably a binary value that is sent to the device to turn the LED on or off. This representation is meaningless for a web deck. However, it is possible to draw two images of the LED, one when it is lit, one when it is not, and send that image to the web deck for display (at the proper location, with the proper size). This image, that only exist for web deck, and that represent a feedback mechanism of a real physical deck is called a \"hardware\" representation.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#representation","title":"Representation","text":"<p>Representations that can be forwarded to a Web Deck are:</p> <ol> <li>Sounds, with certain limitations</li> <li>Images</li> </ol> <p>All representation that either produces a sound file or an image can be displayed on a Web Deck.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#sounds","title":"Sounds","text":"<p>Sounds produced by representation can be forwarded to a Web Deck if the sound file format can be played by the browser. Common format like <code>wav</code> or <code>mp3</code> are supported, other format aer not. A warning is issued by Cockpitdecks if the file format cannot be played on a Web Deck.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#images","title":"Images","text":"<p>All representations that produce an image can be forwarded to a web deck: Icon, multi-icons, all drawn representations like switches, annunciators, data and weather\u2026</p> <p>To do so, the web deck needs to know where it will place the image on the deck. Two additional parameters are necessary: <code>dimension</code> and <code>offset</code>. The <code>offset</code> attribute is placed in a <code>layout</code> attribute.</p> <pre><code>- name: screen\n  action:\n  - push\n  dimension:\n  - 335\n  - 310\n  feedback: image\n  layout:\n    offset:\n    - 76\n    - 62\n</code></pre> <p>If the <code>dimension</code> attribute is a single scalar value, it is assumed that the button is round, and the scalar value is the radius of the button.</p> <p>If an identical button is repeated, it is necessary to supply the additional <code>spacing</code> attribute that will give the space to leave horizontally and vertically between repreating buttons:</p> <pre><code>- name: 1\n  prefix: annunciator\n  action:\n  - push\n  dimension:\n  - 35\n  - 14\n  repeat:\n  - 5\n  - 1\n  feedback: image\n  layout:\n    offset:\n    - 117\n    - 11\n    spacing:\n    - 15\n    - 0\n</code></pre> <p>All sizes are in pixels.</p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#hardware-representation","title":"\u00abHardware\u00bb Representation","text":"<p>Some existing deck device buttons cannot be reproduced on web decks. For example, a button with a translucent sign with colored back light is driven on the deck by supplying a series of numeric values to set the color and intensity of the light. There numeric values cannot be forwarded to a Web Deck to produce the same effect on the web deck, since there is not such button.</p> <p>The idea behind \u00abHardware\u00bb Representations it do draw such a button on an image using the same numeric values provided by the regular representation, and send the image for display on the web deck. An Hardware Representation is an alternate representation for a regular representation that does not produce an image to allow it to be rendered on a Web Deck.</p> <p></p>"},{"location":"Reference/Extending/Deck%20Type%20for%20Web%20Deck/#hardware-image","title":"Hardware Image","text":"<p>A Hardware Representation is an image. Like regular representation it needs to get the position and size of the image on the web deck background through the <code>offset</code> and <code>dimension</code> attribute.</p> <pre><code>  - name: 0\n    prefix: b\n    repeat:\n      - 8\n      - 1\n    action: push\n    dimension: 24\n    feedback: colored-led\n    layout:\n      offset:\n        - 57\n        - 392\n      spacing:\n        - 39\n        - 0\n      hardware:\n        type: virtual-ll-coloredbutton\n</code></pre> <p>In addition, the <code>hardware</code> attribute supply additional data for drawing the representation.</p> <p>The hardware attribute has the following attributes:</p> <ul> <li><code>type</code> - Mandatory. Name of the hardware representation, i.e. the alternate representation for this button on a web deck.</li> <li><code>empty-button</code> - Optional. Button definition for this button without value.</li> </ul> <p>The <code>empty-button</code> attribute is used to create the skeleton of a dummy button that will be used to create the representation when no button uses it. It is only used in case a hardware representation has no button assigned to it, to create an hardware representation with no value.</p> <pre><code>      hardware:\n        type: virtual-xtm-encoderled\n        empty-button:\n          type: encoder-value\n          encoder-leds: 0\n</code></pre> <p>The above example is used to define the LoupedeckLive row of eight colored backlit buttons at the bottom of the deck device.</p>"},{"location":"Reference/Extending/Deck%20Type/","title":"Deck Type","text":"<p>A Deck Type is a small file that details the available features of a deck device.</p> <p>Some deck device have buttons, knobs, dials, some have slider or cursors, some have small screen for display of icons, some have just LED, sometimes coloured. The purpose of the Deck Type is to enumerates the features of the deck device to Cockpitdecks.</p>"},{"location":"Reference/Extending/Deck%20Type/#buttons","title":"Buttons","text":"<p>Different decks propose different means of interaction like keys to be pressed, dials, cursor, or sometimes even small touch screens. Inside Cockpitdecks, the generic term to designate these interaction means is the Button.</p> <p>A button is the general term for a key, knob, rotary encoder, slider cursor, or touch surface on a deck. On a given deck, each element that can be pressed, turned, swiped, or slid is a button.</p> <p>So a deck mainly consists of a collection of buttons. Describing a deck consists therefore in enumerating all available buttons on that deck with the particularities of each button.</p>"},{"location":"Reference/Extending/Deck%20Type/#button-identification","title":"Button Identification","text":"<p>Cockpitdecks will need to individually address each button on a deck. To do so, each button on a deck will have a unique name, called its index on the deck.</p> <p>Each button can either be named explicitly, or, if a deck has a row or an array of similar buttons, collectively with an numbered pattern.</p> <p>To name a button explicatively, use the <code>name</code> attribute:</p> <pre><code>name: touchscreen\n</code></pre> <p>To name a series of buttons collectively, use the <code>name</code> and <code>prefix</code> attributes:</p> <pre><code>name: 4\nprefix: key\n</code></pre> <p>The above naming will create buttons named <code>key4</code>, <code>key5</code>, etc. for as many button as required for the serie of identifical buttons.</p>"},{"location":"Reference/Extending/Deck%20Type/#button-repetition","title":"Button Repetition","text":"<p>If a deck contains a serie of identical buttons, the <code>repeat</code> attribute will tell how many buttons are available. The repeat attribute is 2 dimensional, width and height:</p> <pre><code>repeat: [4, 3]\n</code></pre> <p>The above repetition state that the deck offers a replication of an identical button across 3 rows of 4 buttons.</p> <p>If <code>repeat</code> attribute is specified, the identification of the button must use the <code>name</code> and <code>prefix</code> attributes.</p>"},{"location":"Reference/Extending/Deck%20Type/#button-description","title":"Button Description","text":"<p>Each button mainly has two key characteristics:</p> <ol> <li>How is it manipulated? Is it pressed? Turned? Swiped?</li> <li>What feedback means does it provide (as an individual button): A small LCD/TFT screen, one or more LED, may be colored LED, or feedback mean at all?</li> </ol>"},{"location":"Reference/Extending/Deck%20Type/#interaction-action","title":"Interaction: Action","text":"<p>Possible interaction means with a deck button is given through the <code>action</code> attribute:</p> <pre><code>action: push\n</code></pre> <p>The <code>action</code> attribute consist of one or more possible interaction means called actions.</p> <pre><code>action: [push, encoder]\n</code></pre> <p>The above attribute states that the button is capable of being pushed and turned with encoder steps.</p> <p>Possible interaction means are (in other words,  possible values for the <code>action</code> attribute):</p> <code>action</code> Description <code>none</code> There is no interaction with the button. It is only used for display purpose. (<code>none</code> interaction can be omitted.) <code>press</code> Simple press button that only reports when it is pressed (one event) <code>push</code> Press button that reports 2 events, when it is pushed, and when it is released. This optionally allow for \"long press\" events. <code>swipe</code> A surface swipe event, with a starting touch and a raise events. <code>encoder</code> A rotating dial, that can turn both clockwise and counterclockwise. Each small rotation of the dial produces a \"click\" (encoder) and reports the direction in which the dial was turned. <code>cursor</code> A cursor is either a round dial or a linear handle that produces a countinuous value between two limits. The produced value changes when the dial is turned or the handle moved along its axis."},{"location":"Reference/Extending/Deck%20Type/#feedback","title":"Feedback","text":"<p>Similarly, the <code>feedback</code>attribute is used to communication which feedback means an individual button offers to the user.</p> <pre><code>feedback: image\n</code></pre> <p>Opposite to the <code>action</code> attribute that allows for one or more interaction means, the <code>feedback</code> attribute must specify at most one feedback mean.</p> <p>Possible values for the <code>feedback</code>attribute are:</p> <code>feedback</code> Description <code>none</code> No feedback on device, or direct feedback provided by some marks on the deck device. (<code>none</code> feedback can be omitted.) <code>image</code> LCD/TFT image, often small and iconic sometimes even reduced in display color capacity. <code>led</code> On/Off LED light. <code>colored-led</code> A single LED that can be colored, or off. <code>multi-leds</code> Several monochrome LED on a ramp. <code>encoder-leds</code> Special encoder led ramp for X-Touch Mini (4 modes) <code>vibrate</code> Emit a buzzer sound. <code>sound</code> Capable of playing a sound, or even music (speaker)."},{"location":"Reference/Extending/Deck%20Type/#button-definition","title":"Button Definition","text":"<p>A button on a deck is described by a list of attributes. Here are some exemples:</p>"},{"location":"Reference/Extending/Deck%20Type/#single-key-button-with-led-light","title":"Single key button with LED light","text":"<pre><code>name: 4\naction: push\nfeedback: LED\n</code></pre>"},{"location":"Reference/Extending/Deck%20Type/#single-encoder-dial","title":"Single Encoder Dial","text":"<pre><code>name: enc0\naction: [push, encoder]\nfeedback: none\n</code></pre>"},{"location":"Reference/Extending/Deck%20Type/#array-of-idenfical-keys","title":"\u00abArray\u00bb of Idenfical Keys","text":"<pre><code>name: 0\nprefix: key\naction: push\nfeedback: image\nimage: [128, 128]\n</code></pre>"},{"location":"Reference/Extending/Deck%20Type/#touch-screen","title":"Touch Screen","text":"<pre><code>name: touchscreen\naction: swipe\nfeedback: image\n</code></pre> <p>The description of a button on a deck is called a Button Type Block.</p>"},{"location":"Reference/Extending/Deck%20Type/#deck-buttons","title":"Deck Buttons","text":"<p>A deck often consists of more than one button: Keys are combined with encoders, touchscreens, etc. Therefore the description of the deck consists of not one button definition but a list of button definition.</p> <pre><code>name: LoupedeckLive\ndriver: loupedeck\nbuttons:\n  - name: 0\n    repeat:\n      - 4\n      - 3\n    action: push\n    feedback: image\n    dimension:\n      - 90\n      - 90\n  - name: 0\n    prefix: e\n    repeat:\n      - 1\n      - 3\n    action:\n      - encoder\n      - push\n  - name: 3\n    prefix: e\n    repeat:\n      - 1\n      - 3\n    action:\n      - encoder\n      - push\n  - name: 0\n    prefix: b\n    repeat:\n      - 8\n      - 1\n    action: push\n    feedback: colored-led\n  - name: left\n    action:\n      - push\n      - swipe\n    feedback: image\n    dimension:\n      - 60\n      - 270\n  - name: right\n    action:\n      - push\n      - swipe\n    feedback: image\n    dimension:\n      - 60\n      - 270\n  - name: buzzer\n    feedback: vibrate\n</code></pre> <p>This is the Deck Type definition of the LoupedeckLive deck.</p>"},{"location":"Reference/Extending/Deck%20Type/#deck-attributes","title":"Deck Attributes","text":"<p>As seen above, the Deck Type also contains a few additional attributes necessary to identify the deck type, and its components (driver).</p> Attribute Definition <code>name</code> Name used inside Cockpitdecks to identifying the deck model. <code>driver</code> Keyword identifying the deck software driver class. <code>buttons</code> List of button descriptions (list of Button Type Blocks)."},{"location":"Reference/Extending/Deck%20Type/#correspondance","title":"Correspondance","text":"<p>When creating an Activation, the activation will specify which action it requires. For example, an activation that requires an encoder dial to work will require the <code>encoder</code> or <code>encoder-push</code> action on the button.</p> <p>Similarly, a Representation will specify which feedback it requires. A representation that displays an image (icon, drawing, animation\u2026) will require the <code>image</code> feedback in the button definition.</p>"},{"location":"Reference/Extending/Deck%20Type/#see-also","title":"See Also","text":"<p>Deck Type for Web Deck</p>"},{"location":"Reference/Extending/Deck/","title":"Deck","text":"<p>When a new deck device appears, it is necessary to introduce it to Cockpitdecks.</p> <p>First, the capabilities of the devices will need to be enumerated into a Deck Type.</p> <p>Second, it might be necessary to create a deck driver to interface the device with Cockpitdecks.</p> <p>Events produced on the device and reported by the driver will need to be transformed into Deck Events injected into Cockpitdecks.</p> <p>Reciprocally, when Cockpitdecks will generate a representation, the driver will transform it and install it on the deck device.</p>"},{"location":"Reference/Extending/Deck/#deck-type","title":"Deck Type","text":"<p>Please refer to Deck Type.</p>"},{"location":"Reference/Extending/Deck/#deck-driver","title":"Deck Driver","text":""},{"location":"Reference/Extending/Extending%20Cockpitdecks/","title":"Extending Cockpitdecks","text":"<p>Cockpitdecks can be extended in several directions.</p>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#new-button-appearances","title":"New Button Appearances","text":"<p>The most common extension will be adding custom Representations.</p> <p>A Cockpitdecks developer may add a new type of feedback, very much like the Reference/Button Representations/Weather buttons. Those buttons do not exist in aircrafts, they were created to artificially enhance the simulation experience and ease other parts of the simulation. Similarly, there are endless opportunities to create other types of buttons and materialize them on a deck though Cockpitdecks. In Cockpitdecks, this is performed by mainly creating new Representations.</p>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#new-deck-model-new-activations","title":"New Deck Model, New Activations","text":"<p>New deck models may appear. Adding a new deck model highlights necessary steps.</p> <p>In addition of defining a new deck model, it might be necessary to add a new method of interaction that this deck may provide. In this case, it might me necessary to develop specialized, custom activation mechanism not foreseen by the current Cockpitdecks version.</p>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#new-simulator-software","title":"New Simulator Software","text":"<p>Core class Simulator can also be extended to connect Cockpitdecks to another simulation software. In this case, interaction models imposed by Cockpitdecks (datarefs, commands, UDP connection) inspired by the X-Plane flight simulator software may have to be adjusted as well.</p>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#extensions-integration","title":"Extensions Integration","text":"<p>The above descriptions enumerates parts of Cockpitdecks that can be extended. To integrate those extensions into Cockpitdecks, there are two mechanisms.</p> <ol> <li>Simple addition of files (for new deck types)</li> <li>Addition of python packages (for code, etc.)</li> </ol>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#adding-custom-deck-types","title":"Adding Custom Deck Types","text":"<p>The first mechanism is limited to simpler extensions like providing new deck types or models. In this case, it is sufficient to create and provide a new Deck Type file. This also applies to defining new web decks.</p> <p>First, in normal operations, when an aircraft configuration is loaded, Cockpitdecks will search for deck types in the</p> <pre><code>&lt;Aircraft Folder&gt;/deckconfig/resources/decks\n</code></pre> <p>folder. If new deck types are found, they are loaded and made available.</p> <p>Second, if a new deck type is available for all aircrafts, it is possible to create a similar folder organisation at another location and to point the cockpitdecks environment variable to it.</p> <pre><code>COCKPITDECKS_EXTENSION_PATH:\n  - /Users/xplane/cockpitdecks/mydecktypes\n</code></pre> <p>On this case, Cockpitdecks will look for a folder named <code>decks/resources/types</code> at the above location and load deck types defined there.</p>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#adding-code","title":"Adding Code","text":"<p>The second extension mechanism requires adding (python) code to Cockpitdecks.</p> <p>In this case, the extension mechanism proceeds by providing extension packages to Cockpitdecks, either by pointing at a folder that contains the package, or by mentioning its name if the package has been loaded by another method.</p> <p>Providing extension by location:</p> <pre><code>COCKPITDECKS_EXTENSION_PATH: /Users/xplane/cockpitdekcs/myextension/mypackage\n</code></pre> <p>will loaded package named <code>mypackage</code> from the above folder. (In this case, the above folder path will be added to python <code>sys.path</code> and package will be discovered from there.)</p> <p>Providing extension name:</p> <pre><code>COCKPITDECKS_EXTENSION_NAME: customext\n</code></pre> <p>will load package <code>customext</code>.</p> <p>Cockpitdecks will recursively load the entire extension packages on startup, discover and add extensions provided by those packages.</p> <p>Depending on the extension provided, discovery is achieved as follow:</p> <ul> <li>New activations (python classes) needs to be derived from the <code>cockpitdecks.buttons.activation.Activation</code> class.</li> <li>New representations needs to be derived from the <code>cockpitdecks.buttons.representation.Representation</code> class.</li> <li>New deck (python classes) needs to be derived from the <code>cockpitdecks.Deck</code> class.</li> <li>New simulator software needs to be derived from the <code>cockpitdecks.Simulator</code> class.</li> </ul> <p>Cockpitdecks will discover daughter classes of the above core classes and add them to its collections of available resources.</p> <p>In addition to the above code, new deck types can be added like described above, by providing the following structure inside an extension package:</p> <pre><code>&lt;extension-name&gt;.decks.resources.types\n</code></pre> <p>Resources files located in that module will be loaded as Deck Types.</p>"},{"location":"Reference/Extending/Extending%20Cockpitdecks/#tools-for-developers","title":"Tools for Developers","text":"<p>Cockpitdecks incudes a few developer specific activations that can be used to introspect Cockpitdecks while running.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/","title":"Activations for Developers","text":"<p>Cockpitdecks offers a few special activations that are normally not called in regular use.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#reload","title":"Reload","text":"<p><code>type: reload</code></p> <p>No option. Provoke the reload of all decks from initialisation.</p> <p>The procedure first gracefull terminates the current setup, and then reloads the setup.</p> <p>If a page different than the home page was currently loaded, the process will try to reload the same page if available in the new setup.</p> <p>This activation is mainly used during development process to create buttons, alter their appearance and re-load the configuration to see the changes.</p> <p>(Please note that reloading decks is a complex process, since it involves the reset of all devices, reloading all configurations, and displaying pages as they used to be, if still present.)</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#stop","title":"Stop","text":"<p><code>type: stop</code></p> <p>No option. Gracefully stops all decks and terminates Cockpitdecks.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#inspect","title":"Inspect","text":"<p><code>type: inspect</code></p> <p>Provoke the output of information for all buttons of all pages or all decks.</p> <p>Mainly for development purpose.</p> <p>Inspection always starts at the Cockpit level and may or may not crawl down into its constituting parts like decks, layouts, pages, and buttons. Some inspection terminates earlier in the drill down. For example, <code>threads</code> inspection stops at the Deck level.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#attribute","title":"Attribute","text":"<p>Button Inspect has one attribute</p> <p><code>what</code></p> <p>The value of the <code>what</code> attribute determine what is displayed when activated.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#what-attribute-values","title":"what Attribute Values","text":"Value Description <code>threads</code> list Cockpitdecks and deck threads that are currently running. <code>datarefs</code> list datarefs and values (the page containing the buttons need to be loaded first before it can display values). <code>datarefs-listener</code> List all datarefs and which buttons (listeners) are using the dataref. <code>status</code> list internal variables and statuses of each button. <code>valid</code> check button validity and report invalid status. <code>desc</code> print a description of what each button does in plain English, both for activation and representation. <code>image</code> produces an image of each deck, images are saved in the Cockpitdecks home directory and named after the deck. <code>longpress</code> list Activations#ShortOrLongpress command that should have a couple of additional commands added to X-Plane through the plugin. <pre><code>index: 4\ntype: inspect\nwhat: desc\n</code></pre> <p>When button index 4 is pressed, it will display what each button does (description) in plain English on the output or debugging screen or file.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#notes-for-button-designers","title":"Notes for Button Designers","text":""},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#button-instantiation","title":"Button Instantiation","text":"<p>When a button is created, internal meta data are set first. Second, the Activation is installed and initialised. Third, the Representation is installed and initialized, as it may already use some activation information for rendering. Finally, the button is initialised. It will be rendered when the page that contains it is loaded on a deck.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#button-validity","title":"Button Validity","text":"<p>Each button has a validity function that ensures that all necessary attributes are provided in its definition. If the activation of the button is not valid, its activation function will never be triggered, because of missing or misconfigurated parameters. If its representation is not valid, it will not be rendered on the deck.</p> <p>If a button is not valid, a small red triangle appears in the lower right corner of the key icon if the button is capable of representing it. A small blue triangle appears in the lower right corner of the key icon if Cockpitdecks suspect the button is a placeholder.</p>"},{"location":"Reference/Extending/Development/Activations%20for%20Developers/#button-description-and-inspection","title":"Button Description and Inspection","text":"<p>Each button has an <code>describe()</code> method that prints in plain English what the button does and what it renders on the deck.</p> <p>Each button has an <code>inspect(what: str)</code> method that exposes internal values and state. The inspect method takes one parameter <code>what</code>  that determines what is displayed when invoked.</p> <p>These methods can be invoked from the Inspect button activation.</p>"},{"location":"Reference/Extending/Development/Adding%20Activations/","title":"Adding Activations","text":"<p>To add a new activation to Cockpitdecks, the developer has to create a new Activation sub-class derived from <code>cockpitdecks.buttons.activation.Activation</code> (or one of its subclass).</p> <pre><code>class SpecialAction(Activation):\n\n    ACTIVATION_NAME = \"special-action\"\n    REQUIRED_DECK_ACTIONS = [DECK_ACTIONS.PRESS, DECK_ACTIONS.LONGPRESS, DECK_ACTIONS.PUSH]\n\n    def __init__(self, config: dict, button: \"Button\"):\n</code></pre> <p>In the button definition:</p> <pre><code>index: 42\nname: ULTIMATE\ntype: special-action\n</code></pre>"},{"location":"Reference/Extending/Development/Adding%20Activations/#example-adding-an-activation-to-dim-deck-backlight","title":"Example: Adding an Activation to Dim Deck Backlight","text":"<p>The following python script adds a simple activation to adjust</p> <pre><code>import logging\nfrom cockpitdecks import DECK_ACTIONS\nfrom .activation import UpDown\n\nlogger = logging.getLogger(__name__)\n# logger.setLevel(logging.DEBUG)\n\nclass LightDimmer(UpDown):\n    \"\"\"Customized class to dim deck back lights according to up-down switch value\"\"\"\n\n    ACTIVATION_NAME = \"dimmer\"\n    REQUIRED_DECK_ACTIONS = [DECK_ACTIONS.PRESS, DECK_ACTIONS.LONGPRESS, DECK_ACTIONS.PUSH]\n\n    def __init__(self, config: dict, button: \"Button\"):\n        UpDown.__init__(self, config=config, button=button)\n        self.dimmer = config.get(\"dimmer\", [10, 90])\n\n    def activate(self, event):\n        currval = self.stop_current_value\n        if currval is not None and 0 &lt;= currval &lt; len(self.dimmer):\n            self.button.deck.set_brightness(self.dimmer[currval])\n        super().activate(event)\n</code></pre> <p>Its accompanying button definition:</p> <pre><code>  - index: 1\n    name: ANNUNCIATOR LIGHTS\n    label: ANN LT\n    type: dimmer\n    stops: 3\n    dimmer: [100, 80, 30]\n    switch:\n      switch-style: rect\n      button-fill-color: black\n      button-underline-width: 4\n      button-underline-color: coral\n      tick-labels:\n        - \"TEST\"\n        - \"BRT\"\n        - \"DIM\"\n      tick-space: 10\n      tick-label-size: 30\n      tick-label-font: DIN Bold\n    options: 3way,invert,hexa\n    dataref: AirbusFBW/AnnunMode\n    set-dataref: AirbusFBW/AnnunMode\n</code></pre> <p>When switch is moved to TEST, backlight is set to 100%, BTR sets it to 80%, and DIM to 30%.</p>"},{"location":"Reference/Extending/Development/Adding%20Activations/#activation-api","title":"Activation API","text":""},{"location":"Reference/Extending/Development/Adding%20Instruction/","title":"Adding Instruction","text":"<p>To add a new instruction to Cockpitdecks, the developer has to create a new ButtonInstruction sub-class derived from <code>cockpitdecks.ButtonInstruction</code> (or one of its subclass).</p> <pre><code>from cockpitdecks.button import Button, ButtonInstruction\n\n\nclass SpecialInstruction(ButtonInstruction):\n\n\tINSTRUCTION_NAME = \"button-special\"\n\n\tdef __init__(self, button: Button, config: dict):\n\t\tself._config = config\n</code></pre> <p>In the button definition:</p> <pre><code>index: 42\nname: ULTIMATE\ntype: push\ncommand: button-special\n</code></pre>"},{"location":"Reference/Extending/Development/Adding%20Instruction/#example-adding-a-buttoninstruction-to-print-information","title":"Example: Adding a ButtonInstruction to Print Information","text":"<p>The following python script adds a simple instruction to print some information</p> <pre><code>import logging\nfrom cockpitdecks.button import Button, ButtonInstruction\n\nlogger = logging.getLogger(__name__)\n# logger.setLevel(logging.DEBUG)\n\nclass PrintInstruction(ButtonInstruction):\n    \"\"\"Custom instruction to print a message\"\"\"\n\n    INSTRUCTION_NAME = \"button-print\"\n\n    def __init__(self, name: str, button: Button, config: dict) -&gt; None:\n        ButtonInstruction.__init__(self, name=name, button=button)\n        self._config = config\n        self.message = config.get(\"message\", \"Hello, world!\")\n\n    def _execute(self):\n        logger.info(f\"{self.message}\")\n</code></pre> <p>Its accompanying button definition:</p> <pre><code>  - index: 1\n    name: SAY HELLO\n    label: SAY HELLO\n    type: push\n    command: button-print\n    message: X-Plane rocks\n</code></pre> <p>When button is pressed, the message X-Plane rocks is printed on the console.</p>"},{"location":"Reference/Extending/Development/Adding%20Instruction/#instruction-api","title":"Instruction API","text":""},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/","title":"Adding New Deck Models","text":"<p>Adding a new deck model can be very simple or very difficult, depending on the deck's capabilities and software already available to access it (through the python language).</p> <p>Cockpitdecks does its best at isolating deck specifics into</p> <ul> <li>deck definition files (called a Deck Type)</li> <li>deck (device) drivers classes</li> </ul>"},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#deck-definition-file","title":"Deck Definition File","text":""},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#deck-abstraction-and-modeling","title":"Deck Abstraction and Modeling","text":"<p>Decks, in general, have been defined as devices containing buttons that can be pressed, dials, or encoders that can be turned, cursors, or sliders that can be slid, or even touch screens that can be touched or swiped.</p> <p>These buttons can be illuminated by one or more monochrome or color LED(s), or can sometimes even display an image on a small LCD. Some can vibrate, or even produce sound.</p> <p>Each of these interaction has led to the definition of standardized behavior. On one side, the deck expresses what is is capable of, on the other side, the Cockpitdecks designer tells which capabilities she or he wants to produce a result.</p> <p>Please refer to the Deck document to learn about how to express deck specifics in a Deck Type definition file.</p>"},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#definition-files","title":"Definition Files","text":"<p>A small file defines the deck layout and capabilities, what is available through it:</p> <pre><code># This is the description of a deck's capabilities for a Elgato Streamdeck Plus device\n#\n---\ntype: Streamdeck Plus\nbrand: Streamdeck\nmodel: Plus\ndriver: streamdeck\nbuttons:\n  - name: 0\n    action: push\n    feedback: image\n    image: [96, 96, 0, 0]\n    repeat: 8\n  - name: 0\n    prefix: e\n    action: encoder-push\n    feedback: none\n    repeat: 4\n  # touchscreen in streamdeck package vocabulary\n  - name: touchscreen\n    action: swipe\n    feedback: image\n    image: [800, 100, 0, 0]\n</code></pre> <p>Through this file, Cockpitdecks is capable to determine that there are 8 (repeat) LCD buttons, named <code>0</code>.. <code>7</code>, capable of being pushed (action), and capable of displaying a 96x96 pixel image (feedback, image). Similarly, there are 4 encoders and a swipe screen.</p> Attribute Definition type Name the precise deck model. Referenced in config.yaml file to tell which deck is connected to the system. driver Name of the driver software inside Cockpitdecks. See below. buttons Button capabilities are modeled in two categories:1. Actions, which specifies what a button is capable of,2. View, which specifies what a button can show as a feedback to the user."},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#button-capabilties","title":"Button Capabilties","text":"Attribute Definition action The following actions (means of interaction with a deck) have been identified and are available in Cockpitdecks:- <code>push</code>: ability to press a button, optionally pushing a long time,- <code>encoder</code>- <code>press</code>: ability to press a button, no timing information- <code>longpress</code>- <code>touch</code>- <code>swipe</code> feedback Similarly, decks defined the following feedback interactions:- <code>image</code>- <code>led</code>: simple on-off light- <code>colored-led</code>: colored light (that can also be off)- <code>encoder-led</code>: ramp of led lights for X-Touch Mini name Name and repeat will determine the index name of the buttons. repeat Number of time the same button needs repeating prefix Prefix is used to distinguish button capabilities. If a button has, for example, encoder and push capabilities, the push capabilities will use name <code>0</code> (name only), the corresponding encoder will be named <code>e0</code> (prefix + name). image In case of an <code>image</code> feedback, the image attribute sets the image size for this button, and its offset if the image is a portion of a larger display. vibrate If the device/button has a vibration capability sound If the device/button has a sound emission capability"},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#deck--driver-","title":"Deck \u00ab Driver \u00bb","text":""},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#deck-to-computer-interaction","title":"Deck to Computer Interaction","text":"<p>Depending on the button's action that is triggered, the deck will programmatically generate an Event. The type and content of the Event will depend on the action type.</p> <p><code>push</code>: produces an event with the identifier of the button that was pressed, and a flag indicating that the button was pressed or release.</p> <p><code>encoder</code>: will produce an Event of type encoder, with the identifier of the encoder, and a flag telling whether the encoder was turned clockwise or counter-clockwise.</p> <p><code>swipe</code>: will produce a complex swipe Event, with the position of the start of the swipe, the end of the swipe and some timing information (timestamps of start and end of swipe).</p> <p>Technically speaking, the deck will start a thread to listen to incoming events. Interaction will be decoded (which key was pressed, when, how, etc.) and presented to Cockpitdecks as a typed Event.</p> <p>Depending on the device driver's hardware access, events will either be presented directly to Cockpitdecks, or through a FIFO queue: Driver just enqueues events, Cockpitdecks dequeues events and does the work.</p>"},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#computer-to-deck-interaction","title":"Computer to Deck Interaction","text":"<p>Depending on the deck's view capabilities, the computer will send the appropriate information to the deck to produce the feedback: Send an image, turn a LED on or off, with the appropriate color, emit a sound or vibrate.</p> <p>This is performed directly through the deck's device driver, by calling the appropriate function. Most of the time, this call is direct.</p>"},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#correspondance","title":"Correspondance","text":"<p>When creating an Activation, the activation will specify which action it requires. For example, an activation that requires an encoder dial to work will require the <code>encoder</code> or <code>encoder-push</code> capability.</p> <p>Similarly, a Representation will specify which feedback it requires. A representation that displays an image (icon, drawing, animation\u2026) will require a <code>image</code> feedback for instance.</p>"},{"location":"Reference/Extending/Development/Adding%20New%20Deck%20Models/#see-also","title":"See Also","text":"<p>Deck</p>"},{"location":"Reference/Extending/Development/Adding%20Representations/","title":"Core Button","text":"<p>The core Button class is designed to isolate deck key specifics in two attribute classes:</p> <ol> <li>Activation, that represents the user's interaction with the deck, and</li> <li>Representation, that expresses what the deck communicates back to the user.</li> </ol> <p>In addition to these two attributes, the core Button class holds, keeps and maintains a set of other global, generic attributes made available to the two governing attributes.</p> <ul> <li>All datarefs accessed by the button,</li> <li>Guard, if any,</li> <li>Whether the button is \"managed\" and displays alternate representation,</li> </ul> <p>Last but not least, the button keeps a copy of its entire \"definition\", a dictionary of name, value pairs supplied through the configuration file of the Page. Again, some attributes are mandatory and/or imposed by Cockpitdecks, like</p> <ul> <li><code>type</code></li> <li><code>index</code></li> <li><code>options</code></li> <li><code>set-dataref</code></li> <li>\u2026</li> </ul> <p>Other attributes may already be defined by existing activations and representations, but any arbitrary name, value pair can be passed and stored in the button configuration dictionary and used by its activation and/or its representation.</p>"},{"location":"Reference/Extending/Development/Adding%20Representations/#new-representation","title":"New Representation","text":"<p>Creating a new representation, like sending some special information or custom image to a LCD key is more probable.</p> <p>To add a new representation to Cockpitdecks, the developer has to create a new Representation sub-class and derived it from <code>cockpitdecks.buttons.representation.Representation</code> or one of its subclass.</p> <pre><code>class SpecialtyIcon(Representation):\n\n    REPRESENTATION_NAME = \"specialty-icon\"\n    REQUIRED_DECK_FEEDBACKS = DECK_FEEDBACK.IMAGE\n\n    def __init__(self, config: dict, button: \"Button\"):\n        Representation.__init__(self, config=config, button=button)\n\n        self.param1_value = config.get(\"param1\")\n</code></pre> <p>In the button definition:</p> <pre><code>index: 42\nname: SPECIAL_ICON\ntype: push\nspecialty-icon:\n\tparam1: value\n</code></pre> <p>Abstract Representation.</p> <p>It is sometimes convenient to create a base class from which derived classes inherit. If the (abstract) base class cannot be instanciated, terminate its internal name with <code>-base</code>. By convention, activation and representation classes with internal names that terminates with <code>-base</code> are excluded from instanciable classes.</p> <pre><code>\t\tREPRESENTATION_NAME = \"do-not-instanciate-base\"\n</code></pre>"},{"location":"Reference/Extending/Development/Adding%20Representations/#representation-api","title":"Representation API","text":""},{"location":"Reference/Extending/Development/Adding%20a%20Simulator/","title":"Adding a Simulator","text":"<p>To add a new simulator to Cockpitdecks, the developer has to create a new Simulator sub-class derived from <code>cockpitdecks.Simulator</code> (or one of its subclass).</p> <pre><code>class SubLogicFlightSimulator(Simulator):\n\n    name = \"A2FS1\"\n\n    def __init__(self, cockpit, environ):\n</code></pre>"},{"location":"Reference/Extending/Development/Adding%20a%20Simulator/#simulator-api","title":"Simulator API","text":""},{"location":"Reference/Extending/Development/Hardware%20Representation/","title":"Hardware Representation","text":"<p>Hardware Representations only exist for web decks.</p> <p>When a web deck tries to reproduce on screen hardware elements only available on physical decks, it uses hardware representation.</p> <p>Let us take a very simple hardware representation: A translucent button with a colored led. The button has sign on it (letter, number, icon\u2026)</p> <p></p> <p>For the physical deck, the deck device driver will handle the rendering of the feedback on that deck through a dedicated representation and its accompanying driver software.</p> <p>Cockpitdecks uses a hardware representation to draw the same button on a web deck. A hardware representation is nothing more than an image used to represent a button on a web deck.</p> <p>Very much like the physical representation, Cockpitdecks uses dedicated software to create the image, but once created, the image of the hardware button is sent to the web deck for drawing like any other image, supplying the image of course, but also its position and size.</p> <p>Since a hardware representation is an image, all hardware representations are in fact particular icons image and treated as such.</p> <p>In the case of our translucent button, all we need is a image of that button when it is not lit. When lit with a given color and/or intensity, the hardware representation software will overlay the button sign to give the illusion that it is lit as requested. The resulting image is sent to the web deck to give the illusion of the lit button.</p>"},{"location":"Reference/Extending/Development/Hardware%20Representation/#important-note","title":"Important Note","text":"<p>Hardware representations are often specific to a deck model. Therefore the device driver of the corresponding deck model need to be installed to make some feature parameters available to the hardware representation.</p> <p>Here is an example of the demo deck, with a X-Touch Mini hardware representation for the right most encoder (circular ramp of 13 monochrome leds). In the picture below; on the left side, the encoder is not represented because <code>xtouchmini</code> driver software is not installed. On the right side, it is correctly represented.</p> <p></p>"},{"location":"Reference/Extending/Development/Instruction/","title":"Instruction","text":"<p>An Instruction is an action that will be performed when required through interaction with the deck or Cockpitdecks.</p>"},{"location":"Reference/Extending/Development/Instruction/#instruction-types","title":"Instruction Types","text":""},{"location":"Reference/Extending/Development/Instruction/#internal-instruction","title":"Internal Instruction","text":"<p>Internal Instruction are instruction used by Cockpitdecks for its internal control. Examples of such instructions are:</p> <ul> <li>Load a new page on a deck</li> <li>Stop Cockpitdecks</li> <li>Change theme</li> <li>\u2026 or for developers:</li> <li>Reload all decks</li> <li>Inspect Cockpitdecks components</li> </ul> <p>Internal instruction name starts with <code>cockpitdecks-</code> followed by the instruction itself.</p> <pre><code>    command: cockpitdecks-aircraft\n</code></pre> <p>is an internal instruction that is executed when Cockpitdecks notices a new aircraft has been loaded in the simulation.</p> <p>Internal Instruction name</p> <p>The name of an internal instruction starts with <code>cockpitdecks-</code>. It is a convention,and it is how internal instructions are detected and treated separately.</p>"},{"location":"Reference/Extending/Development/Instruction/#simulator-instruction","title":"Simulator Instruction","text":"<p>A Simulator Instruction is an instruction sent to the simulator to perform an action there. Example of such instructions are:</p> <ul> <li>Change a view</li> <li>Trigger a command in the Cockpit</li> </ul> <pre><code>    command: toliss_airbus/dispcommands/CaptWptPushButton\n</code></pre> <p>Simulator instruction has no prefix.</p>"},{"location":"Reference/Extending/Development/Instruction/#instruction-attribute","title":"Instruction Attribute","text":"<p>For historical reason, the attribute to specify an instruction is <code>command</code>.</p>"},{"location":"Reference/Extending/Development/Instruction/#simple-instruction","title":"Simple Instruction","text":"<p>In its simple form, a command is just the name of the instruction</p> <pre><code>     command: SRS/X-Camera/Select_View_ID_1\n</code></pre>"},{"location":"Reference/Extending/Development/Instruction/#instruction-block","title":"Instruction Block","text":"<p>Another form of instruction is the instruction block. The instruction block is an instruction with two additional attirbutes</p> <p>Condition: A condition to satisfy before the instruction is executed. The condition is evaluated first, each time the instruction is requested to run. If the result of the condition is True (not zero), the instruction is executed.</p> <p>Delay: The delay is the time to wait from the request to run to the actual moment of execution of the instruction.</p> <pre><code>      - command: AirbusFBW/PopUpSD\n        condition: ${AirbusFBW/PopUpStateArray[7]} not\n        delay: 2\n</code></pre>"},{"location":"Reference/Extending/Development/Instruction/#macro-instruction","title":"Macro Instruction","text":"<p>A Macro Instruction is a set of one or more commands that are executed one after the other.</p> <p>Each command can be specified either a simple instruction or an instruction block</p> <pre><code>    command:\n      - command: AirbusFBW/ECP/SelectElecACPage\n      - command: AirbusFBW/PopUpSD\n        condition: ${AirbusFBW/PopUpStateArray[7]} not\n        delay: 2\n      - command: AirbusFBW/PopUpSD\n        delay: 10\n</code></pre> <p>The above macro instruction has three commands. The second command occurs 2 seconds aftre the first one, and only if <code>AirbusFBW/PopUpStateArray[7]</code> is zero (i.e. not set). The third command call the same popup display to make it dissappear after 10 seconds.</p>"},{"location":"Reference/Extending/Development/Internal%20Datarefs/","title":"Internal Datarefs","text":"<p>These datarefs are created and maintained for statistical purpose. They should not be used for simulation, only for development and Cockpitdecks health monitoring.</p> <pre><code>class INTERNAL_DATAREF(Enum):\n    #\n    # C O C K P I T D E C K S\n    #\n\n    #\n    # C O C K P I T\n    #\n    # Number of cockpitdecks reloads\n    COCKPITDECK_RELOADS = \"reload_pages\"\n\n    #\n    # D E C K\n    #\n    # Number of page reloads\n    DECK_RELOADS = \"reload_page\"  # /&lt;deck-name&gt;\n\n    # Number of page reloads\n    PAGE_CHANGES = \"change_page\"  # /&lt;deck-name&gt;/&lt;page-name&gt;\n\n    RENDER_BG_TEXTURE = \"bg-texture\"\n    RENDER_BG_COLOR = \"bg-color\"\n    RENDER_CREATE_ICON = \"create_icon\"\n\n    #\n    # P A G E\n    #\n    DATAREF_REGISTERED = \"registered_dataref\"\n    PAGE_RENDER = \"page_render\"\n    PAGE_CLEAN = \"page_clean\"\n\n    #\n    # B U T T O N\n    #\n    BUTTON_ACTIVATIONS = \"activation\"\n    BUTTON_RENDERS = \"render\"\n    BUTTON_REPRESENTATIONS = \"representation\"\n    BUTTON_CLEAN = \"clean\"\n\n    #\n    # U D P\n    #\n    INTDREF_CONNECTION_STATUS = \"_connection_status\"\n    # Number of UDP packet received\n    UDP_BEACON_RCV = \"udp_beacon_received\"\n    UDP_BEACON_TIMEOUT = \"udp_beacon_timeout\"\n    STARTS = \"starts\"\n    STOPS = \"stops\"\n\n    UDP_READS = \"udp_rcv\"\n    LAST_READ = \"last_read_time\"\n    VALUES = \"values_read\"\n    UPDATE_ENQUEUED = \"value_change_enqueued\"\n\n    # Average number of reads per seconds (last 100 reads)\n    UDP_READS_PERSEC = \"cockpitdecks/udp/persec\"\n\n    # Time sice last read\n    UDP_CYCLE = \"cockpitdecks/udp/cycle\"\n\n    # Average number of dataref values recevied per seconds (last two minutes)\n    UDP_DATAREFS_PERSEC = \"cockpitdecks/udp/datarefs_persec\"\n\n    # Total number of dataref values recevied\n    UDP_DATAREF_COUNT = \"cockpitdecks/udp/dataref-count\"\n\n    #\n    # E V E N T\n    #\n    ENQUEUE_CYCLE = \"cockpitdecks/udp/enqueue/cycle\"\n\n    ENQUEUE_COUNT = \"cockpitdecks/udp/enqueue/count\"\n\n    ENQUEUE_PERSEC = \"cockpitdecks/udp/enqueue/persec\"\n\n    #\n    # X - P L A N E\n    #\n    # Zulu diff\n    # Time difference between zulu in sim and zulu on cockpitdecks host computer (in seconds and microseconds)\n    ZULU_DIFFERENCE = \"xplane/timedelay\"\n</code></pre>"},{"location":"Reference/Extending/Development/Packaging/","title":"Packaging","text":"<p>Cockpitdecks is \u00abpackaged\u00bb (in python's terminology) into a few packages to cleanly split dependencies and requirements.</p> <p>The main package contains Cockpitdecks core engine and virtual web decks.</p> <p>The following simulator packages are available:</p> <ul> <li>X-Plane (package named cockpitdecks_xp, named xplane)</li> </ul> <p>The following (physical) deck packages are availalble:</p> <ul> <li>Streamdeck (package cockpitdecks_sd, named streadeck)</li> <li>Loupedeck (package cockpitdecks_ld, named loupedeck)</li> <li>Behringer X-Touch Mini (packages cokpitdecks_bx, named xtouchmini)</li> </ul> <p>The following extension packages are also available:</p> <ul> <li>Weather and METAR (package cockpitdecks_wm, named weather), adds representation to display METAR information as an icon.</li> <li>Demo Extension (package cockpitdecks_ext, named demoext), add a few specialized representations, sometimes very dependent on a specific deck model.</li> </ul> <p>A single extension can be installed as such:</p> <pre><code>pip install 'cockpitdecks_ext @ git+https://github.com/devleaks/cockpitdecks_ext.git'\n</code></pre> <p>where cockpitdecks_ext is the extension package name</p> <p>or</p> <pre><code>pip install 'cockpitdecks[demoext] @ git+https://github.com/devleaks/cockpitdecks.git'\n</code></pre> <p>where demoext is the extension name.</p> <p>Each extension lives its own evolution and maintenance part. Requirements are precisely set and monitored regularly to ensure smooth cooperation between all packages.</p> <p>X-Plane Simulator Extension</p> <p>Currently, X-Plane simulator is the only simulator option available. As such, it is included in the core Cockpitdecks installation. It is not necessary to install it separately.</p>"},{"location":"Reference/Extending/Development/Packaging/#note-about-deck-extensions","title":"Note about Deck Extensions","text":"<p>Deck-specific extensions contain both physical deck and virtual web decks. The reason is that some virtual web deck extensions extensively rely on deck device drivers.</p>"},{"location":"Reference/Extending/Development/Packaging/#package-and-extension-discovery","title":"Package and Extension Discovery","text":"<p>There is no black magic in automatic discovery. Packages and extensions are discovered</p> <ul> <li>either because the extension inherit from a monitored class (example: Observables, Simulator, Deck, Activation, Representation),</li> <li>or because configuration files are found at expected rendez-vous location (example <code>resources/decks</code>).</li> </ul>"},{"location":"Reference/Extending/Development/Packaging/#class-extension","title":"Class Extension","text":"<p>Classes are found because they are loaded and inherit from a formal base class.</p>"},{"location":"Reference/Extending/Development/Packaging/#configuration-extension","title":"Configuration Extension","text":"<p>New resources are found because they are located in required folder structures. Nous resources are loaded and either added or merged with existing ones.</p>"},{"location":"Reference/Extending/Development/Rendez-Vous%20Variables/","title":"Rendez Vous Variables","text":"<p>Cockpitdecks uses a limited set of rendez-vous variables with special purpose attached to it.</p> <p>Rendez-vous variables are variables that are maintained by Cockpitdecks for convenience purpose. Other elements like buttons, observables, etc. can subscribe to these variables to be notified from situation changes.</p>"},{"location":"Reference/Extending/Development/Rendez-Vous%20Variables/#aircraft-name","title":"aircraft-name","text":"<p>The internal variable <code>aircraft-name</code>  is a string variable that expects the relative path to the currently used aircraft.</p> <p>When the value of the variable changes, it is assumed a new aircraft is being loaded and Cockpitdecks undergo its change aircraft procedure.</p>"},{"location":"Reference/Extending/Development/Rendez-Vous%20Variables/#livery-name","title":"livery-name","text":"<p>Similarly, he <code>livery-name</code> variable expects the relative path to the current livery. If the livery changes, Cockpitdecks undergoes the livery change procedure.</p>"},{"location":"Reference/Extending/Development/Rendez-Vous%20Variables/#aircraft-icao","title":"aircraft-icao","text":"<p>This variable contains the current aircraft ICAO code. It is used for information purpose. No Cockpitdecks behavior is affected by this variable. Several aircrafts May have the same code and it is not possible to determine which particular aircraft model/editor/publisher is being used.</p> <p>Other information-only variables are also provided for convenience:</p> <ul> <li>airport-departure</li> <li>airport-arrival</li> <li>metar-departure</li> <li>taf-arrival</li> <li>metar-arrival</li> <li>flight-level</li> <li>parking-departure</li> <li>parking-arrival</li> </ul> <p>All these variables are provided by Cockpitdecks in a Flight structure.</p> <p>Variable values are set if available through the simulator variables, otherwise, they remain empty.</p>"},{"location":"Reference/Extending/Development/Rendez-Vous%20Variables/#variables-from-simulator","title":"Variables from Simulator","text":"<ul> <li>date and time of simulation (local time simulated Zulu time)</li> <li>Simulation speed and replay status</li> <li>Location of aircraft</li> </ul> <p>From these \u00ab\u00a0raw\u00a0\u00bb values, the following convenience variables are also provided (through observables):</p> <ul> <li>closest weather station ICAO code</li> <li>daytime/night time (based on simulation time, location, etc.)</li> </ul>"},{"location":"Reference/Extending/Development/Variable/","title":"Variable","text":"<p>A Variable is a named value used by cockpitdecks.</p> <p>A Variable has listeners attached to it. Listeners are other parties interested in being notified when the variable has changed. Listeners are managed by Cockpitdecks.</p>"},{"location":"Reference/Extending/Development/Variable/#variable-types","title":"Variable Types","text":""},{"location":"Reference/Extending/Development/Variable/#cockpitdecks-internal-variable","title":"Cockpitdecks Internal Variable","text":"<p>Cockpitdecks internal variables are variables that are mainly used inside Cockpitdecks code for internal introspection. However, it is possible to declare and use an internal variable in the configuration files.</p> <p>The name of an internal variable start with <code>data:</code>.</p> <p>The attribute to declare variables are:</p> <ul> <li><code>dataref</code> for historical reasons,</li> <li><code>datarefs</code> or <code>multi-datarefs</code>,</li> <li><code>string-datarefs</code> for string-type variables (they must be declared BEFORE other type variables.)</li> </ul> <p>It can be declared as a string variable:</p> <pre><code>\tdataref: data:encoder0_value\n</code></pre> <p>Internal Variable name</p> <p>The name of an internal variable starts with <code>data:</code>. It is a convention, and it is how internal variables are detected and treated separately.</p>"},{"location":"Reference/Extending/Development/Variable/#simulator-variable","title":"Simulator Variable","text":"<p>Simulator variables are variables that are requested from the simulator.</p> <p>A special mechanism request the variable value from the simulator, and when the value changes, Cockpitdecks notifies variable listeners with the new value.</p> <pre><code>\tdataref: AirbusFBW/ExtPowOHPArray[0]\n</code></pre>"},{"location":"Reference/Extending/Development/Variable/#button-internal-state","title":"Button (Internal) State","text":"<p>Button internal states are special variables exposed by buttons. Their name starts with <code>state:</code>.</p> <pre><code>    dataref: state:activation_count\n</code></pre> <p>The name of the states available depend on the button, its activation and representation types.</p>"},{"location":"Reference/Extending/Development/Variable/#formula","title":"Formula","text":"<p>A Formula is a special variable made of other variables. The value of the formula results from the evaluation of a expression (hence the name formula) that combines the variables.</p> <p>Expression are written in Reverse Polish Notation.</p> <p>Formula are sometimes as simple as expression like:</p> <pre><code>    formula: ${sim/cockpit2/gauges/actuators/barometer_setting_in_hg_pilot} 33.86389 * round\n</code></pre> <p>to compute a new value based on another one.</p> <p>However, expression can be as complex as needed.</p> <pre><code>    formula: ${AirbusFBW/Pack1SwitchIllum} ${AirbusFBW/Pack1FCVInd} - abs\n</code></pre> <p>When the value of one of the constituing variable changes, the resulting value of the whole formula is changed.</p>"},{"location":"Reference/Extending/Development/Variable/#variable-value","title":"Variable Value","text":"<p>For practical reasons, variable values are mainly limited to two data types:</p> <ul> <li>String for character string variables, like for example the <code>sim/aircraft/view/acf_ICAO</code> X-Plane dataref that has the value of the ICAO code of the aircraft currently being used.</li> <li>Float for other, numeric variables. Float is the default data type.</li> </ul> <p>Variable a created when they are requested and accessed by their name. The first time a variable is requested it is created with the proper type (string or float). The data type of the variable cannot be changed.</p> <p>It is therefore very important to first declare the variable with its proper type before using it. This is particularly true with string variable, because if not explicitly declared as string variable before it is used, it will have the default float data type.</p>"},{"location":"Reference/Extending/Development/Variable/#variable-datase","title":"Variable Datase","text":"<p>When a variable is first requested, it is added to a database of all variables used by Cockpitdecks. If the same variable is requested at other places or time, the same instance of the variable is used. There is one and only one variable instance for a variable name.</p> <p>The variable database is located in the Cockpit.</p>"},{"location":"Reference/Extending/Development/API/","title":"Cockpitdecks API","text":"<p>Here are the main Cockpitdecks entities meant to be extended by developers</p> <ul> <li>Representation</li> <li>Deck</li> <li>Deck Type</li> <li>Instruction</li> <li>Activation</li> <li>Simulator</li> </ul>"},{"location":"Reference/Extending/Development/API/activation/","title":"Activation","text":"<p>Entities</p>"},{"location":"Reference/Extending/Development/API/activation/#cockpitdecks.buttons.activation.activation","title":"activation","text":"<p>Button action and activation abstraction</p> <p>Classes:</p> <ul> <li> <code>Activation</code>           \u2013            <p>Base class for all activation mechanism.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/activation/#cockpitdecks.buttons.activation.activation.Activation","title":"Activation","text":"<pre><code>Activation(button: Button)\n</code></pre> <p>Base class for all activation mechanism. Can be used for no-operation activation on display-only button.</p> <p>Methods:</p> <ul> <li> <code>activate</code>             \u2013              <p>Function that is executed when a button is activated (pressed, released, turned, etc.).</p> </li> <li> <code>describe</code>             \u2013              <p>Describe what the button does in plain English</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/activation/#cockpitdecks.buttons.activation.activation.Activation.activate","title":"activate","text":"<pre><code>activate(event) -&gt; bool\n</code></pre> <p>Function that is executed when a button is activated (pressed, released, turned, etc.). Default is to tally number of times this button was pressed. It should have been released as many times :-D. **** No command gets executed here **** except if there is an associated view with the button. It removes guard if it was present and closed.</p>"},{"location":"Reference/Extending/Development/API/activation/#cockpitdecks.buttons.activation.activation.Activation.describe","title":"describe","text":"<pre><code>describe() -&gt; str\n</code></pre> <p>Describe what the button does in plain English</p>"},{"location":"Reference/Extending/Development/API/deck/","title":"Deck","text":"<p>Entities</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck","title":"deck","text":"<p>Classes:</p> <ul> <li> <code>Deck</code>           \u2013            <p>A Deck represents a physical device or a virtual web deck.</p> </li> <li> <code>DeckWithIcons</code>           \u2013            <p>This type of deck is a variant of the above for decks with LCD capabilites,</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck","title":"Deck","text":"<pre><code>Deck(name: str, config: dict, cockpit: Cockpit, device=None)\n</code></pre> <p>A Deck represents a physical device or a virtual web deck. A Deck has a collection of Pages, and knows which one is currently being displayed. It maintains a link to the physical device driver and dispatches instruction to the driver to make representation work.</p> <p>Methods:</p> <ul> <li> <code>change_page</code>             \u2013              <p>Change the deck's page to the one supplied as argument.</p> </li> <li> <code>clean_empty</code>             \u2013              <p>Procedure to clean (remove previous) keys that do not contain any feedback rendering.</p> </li> <li> <code>fill_empty</code>             \u2013              <p>Procedure to fill keys that do not contain any feedback rendering.</p> </li> <li> <code>get_attribute</code>             \u2013              <p>Returns the default attribute value</p> </li> <li> <code>get_button_value</code>             \u2013              <p>Get the value of a button from its internal identifier name</p> </li> <li> <code>get_deck_button_definition</code>             \u2013              <p>Returns a deck's button definition from the deck type.</p> </li> <li> <code>get_id</code>             \u2013              <p>Returns deck identifier</p> </li> <li> <code>get_index_numeric</code>             \u2013              <p>Returns the numeric part of the index of a button index for this deck.</p> </li> <li> <code>get_index_prefix</code>             \u2013              <p>Returns the prefix of a button index for this deck.</p> </li> <li> <code>init</code>             \u2013              <p>Initialisation procedure</p> </li> <li> <code>inspect</code>             \u2013              <p>Triggered by the Inspect activation.</p> </li> <li> <code>load</code>             \u2013              <p>Loads pages during configuration. If none is found, create a simple,</p> </li> <li> <code>load_home_page</code>             \u2013              <p>Loads the home page, if any.</p> </li> <li> <code>make_default_page</code>             \u2013              <p>Generates a default home page for the deck,</p> </li> <li> <code>print_page</code>             \u2013              <p>Produces an image of the deck's layout in the current directory.</p> </li> <li> <code>reload_page</code>             \u2013              <p>Reloads page to take into account changes in definition</p> </li> <li> <code>render</code>             \u2013              <p>Main procedure to render a button on the deck</p> </li> <li> <code>set_deck_type</code>             \u2013              <p>Installs the reference to the deck type.</p> </li> <li> <code>set_home_page</code>             \u2013              <p>Finds and install the home page, if any.</p> </li> <li> <code>start</code>             \u2013              <p>Called at end of initialisation to start the deck interaction,</p> </li> <li> <code>terminate</code>             \u2013              <p>Called at end of use of deck to cleanly reset all buttons to a default, neutral state</p> </li> <li> <code>valid_activations</code>             \u2013              <p>Returns the valid activations for the button pointed by the index.</p> </li> <li> <code>valid_indices</code>             \u2013              <p>Returns the valid indices for this deck.</p> </li> <li> <code>valid_representations</code>             \u2013              <p>Returns the valid representations for the button pointed by the index.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.change_page","title":"change_page","text":"<pre><code>change_page(page: str | None = None) -&gt; str | None\n</code></pre> <p>Change the deck's page to the one supplied as argument.    If none supplied, load the default page.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>[str | None]: Name of page loaded or None.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.change_page(page)","title":"<code>page</code>","text":"(<code>[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Name of page to load (default: <code>None</code>)</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.clean_empty","title":"clean_empty","text":"<pre><code>clean_empty(key)\n</code></pre> <p>Procedure to clean (remove previous) keys that do not contain any feedback rendering. key ([str]): Key index to clean with empty/void feedback.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.fill_empty","title":"fill_empty","text":"<pre><code>fill_empty(key)\n</code></pre> <p>Procedure to fill keys that do not contain any feedback rendering. key ([str]): Key index to fill with empty/void feedback.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_attribute","title":"get_attribute","text":"<pre><code>get_attribute(attribute: str, default=None, propagate: bool = True, silence: bool = True) -&gt; Any or None\n</code></pre> <p>Returns the default attribute value</p> <p>..if avaialble at the deck level. If not, returns the parent's default attribute value (cockpit).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any or None</code>           \u2013            <p>[Any or None]: Value of attribute</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_attribute(attribute)","title":"<code>attribute</code>","text":"(<code>str</code>)           \u2013            <p>Attribute name</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_attribute(silence)","title":"<code>silence</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to complain if defalut value is not found (default: <code>False</code>)</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_button_value","title":"get_button_value","text":"<pre><code>get_button_value(name) -&gt; Any\n</code></pre> <p>Get the value of a button from its internal identifier name</p> <p>[description]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_button_value(name)","title":"<code>name</code>","text":"(<code>[type]</code>)           \u2013            <p>[description]</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_deck_button_definition","title":"get_deck_button_definition","text":"<pre><code>get_deck_button_definition(idx) -&gt; ButtonType\n</code></pre> <p>Returns a deck's button definition from the deck type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ButtonType</code>           \u2013            <p>[ButtonType | None]: The button type at index.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_deck_button_definition(idx)","title":"<code>idx</code>","text":"(<code>[str\u0131int]</code>)           \u2013            <p>Button index on deck</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_id","title":"get_id","text":"<pre><code>get_id() -&gt; str\n</code></pre> <p>Returns deck identifier</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>[str]: Deck identifier string</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_index_numeric","title":"get_index_numeric","text":"<pre><code>get_index_numeric(index)\n</code></pre> <p>Returns the numeric part of the index of a button index for this deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.get_index_prefix","title":"get_index_prefix","text":"<pre><code>get_index_prefix(index)\n</code></pre> <p>Returns the prefix of a button index for this deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Initialisation procedure</p> <p>Load deck type definition, load deck parameters, load layout, pages, and install and start deck software.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.inspect","title":"inspect","text":"<pre><code>inspect(what: str | None = None)\n</code></pre> <p>Triggered by the Inspect activation.</p> <p>This function is called on all pages of this Deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Loads pages during configuration. If none is found, create a simple, static page with one activatio.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.load_home_page","title":"load_home_page","text":"<pre><code>load_home_page()\n</code></pre> <p>Loads the home page, if any.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.make_default_page","title":"make_default_page  <code>abstractmethod</code>","text":"<pre><code>make_default_page(b: str | None = None)\n</code></pre> <p>Generates a default home page for the deck, in accordance with its capabilities.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.print_page","title":"print_page","text":"<pre><code>print_page(page: Page)\n</code></pre> <p>Produces an image of the deck's layout in the current directory. For testing and development purpose.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.reload_page","title":"reload_page","text":"<pre><code>reload_page()\n</code></pre> <p>Reloads page to take into account changes in definition</p> <p>Please note that this may loead to unexpected results if page was too heavily modified or interaction with other pages occurred.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(button: Button)\n</code></pre> <p>Main procedure to render a button on the deck</p> <p>The procedure mainly fetches information from the button, for example, gets an image for display in a neutral, generic format (PNG, JPEG\u2026), then format the image to the deck specific format (B646 format for example) and send it to the deck for display using the deck drive APIs. It also convert the button index to the specific index required by the deck.</p> <p>Args;     button ([Button]): Button to render on the deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.set_deck_type","title":"set_deck_type","text":"<pre><code>set_deck_type()\n</code></pre> <p>Installs the reference to the deck type.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.set_home_page","title":"set_home_page","text":"<pre><code>set_home_page()\n</code></pre> <p>Finds and install the home page, if any.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start()\n</code></pre> <p>Called at end of initialisation to start the deck interaction, both ways.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.terminate","title":"terminate","text":"<pre><code>terminate(disconnected: bool = False)\n</code></pre> <p>Called at end of use of deck to cleanly reset all buttons to a default, neutral state and stop deck interaction,</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.valid_activations","title":"valid_activations","text":"<pre><code>valid_activations(index=None)\n</code></pre> <p>Returns the valid activations for the button pointed by the index. If None is given, returns all valid activations.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.valid_indices","title":"valid_indices","text":"<pre><code>valid_indices(with_icon: bool = False)\n</code></pre> <p>Returns the valid indices for this deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.Deck.valid_representations","title":"valid_representations","text":"<pre><code>valid_representations(index=None)\n</code></pre> <p>Returns the valid representations for the button pointed by the index. If None is given, returns all valid representations.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons","title":"DeckWithIcons","text":"<pre><code>DeckWithIcons(name: str, config: dict, cockpit: Cockpit, device=None)\n</code></pre> <p>This type of deck is a variant of the above for decks with LCD capabilites, LCD being individual key display (like streamdecks) or a larger LCD with areas of interaction, like LoupedeckLive. This class complement the generic deck with image display function and utilities for image transformation.</p> <p>Methods:</p> <ul> <li> <code>change_page</code>             \u2013              <p>Change the deck's page to the one supplied as argument.</p> </li> <li> <code>clean_empty</code>             \u2013              <p>Fills a button pointed by index with an empty representation.</p> </li> <li> <code>create_icon_for_key</code>             \u2013              <p>Create a default icon for supplied key with proper texture or color</p> </li> <li> <code>fill_empty</code>             \u2013              <p>Fills all empty buttons with a default representation.</p> </li> <li> <code>get_attribute</code>             \u2013              <p>Returns the default attribute value</p> </li> <li> <code>get_button_value</code>             \u2013              <p>Get the value of a button from its internal identifier name</p> </li> <li> <code>get_deck_button_definition</code>             \u2013              <p>Returns a deck's button definition from the deck type.</p> </li> <li> <code>get_icon_background</code>             \u2013              <p>Returns a Pillow Image of size width x height with either the file specified by texture or a uniform color</p> </li> <li> <code>get_id</code>             \u2013              <p>Returns deck identifier</p> </li> <li> <code>get_image_size</code>             \u2013              <p>Gets image size for deck button index</p> </li> <li> <code>get_index_numeric</code>             \u2013              <p>Returns the numeric part of the index of a button index for this deck.</p> </li> <li> <code>get_index_prefix</code>             \u2013              <p>Returns the prefix of a button index for this deck.</p> </li> <li> <code>get_wallpaper</code>             \u2013              <p>Gets image size for deck button index</p> </li> <li> <code>init</code>             \u2013              <p>Initialisation procedure</p> </li> <li> <code>inspect</code>             \u2013              <p>Triggered by the Inspect activation.</p> </li> <li> <code>load</code>             \u2013              <p>Loads pages during configuration. If none is found, create a simple,</p> </li> <li> <code>load_home_page</code>             \u2013              <p>Loads the home page, if any.</p> </li> <li> <code>make_default_page</code>             \u2013              <p>Generates a default home page for the deck,</p> </li> <li> <code>print_page</code>             \u2013              <p>Produces an image of the deck's layout in the current directory.</p> </li> <li> <code>reload_page</code>             \u2013              <p>Reloads page to take into account changes in definition</p> </li> <li> <code>render</code>             \u2013              <p>Main procedure to render a button on the deck</p> </li> <li> <code>set_deck_type</code>             \u2013              <p>Installs the reference to the deck type.</p> </li> <li> <code>set_home_page</code>             \u2013              <p>Finds and install the home page, if any.</p> </li> <li> <code>set_key_icon</code>             \u2013              <p>Access to lower level, raw function to install an image on a deck display</p> </li> <li> <code>start</code>             \u2013              <p>Called at end of initialisation to start the deck interaction,</p> </li> <li> <code>terminate</code>             \u2013              <p>Called at end of use of deck to cleanly reset all buttons to a default, neutral state</p> </li> <li> <code>valid_activations</code>             \u2013              <p>Returns the valid activations for the button pointed by the index.</p> </li> <li> <code>valid_indices</code>             \u2013              <p>Returns the valid indices for this deck.</p> </li> <li> <code>valid_representations</code>             \u2013              <p>Returns the valid representations for the button pointed by the index.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.change_page","title":"change_page","text":"<pre><code>change_page(page: str | None = None) -&gt; str | None\n</code></pre> <p>Change the deck's page to the one supplied as argument.    If none supplied, load the default page.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>[str | None]: Name of page loaded or None.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.change_page(page)","title":"<code>page</code>","text":"(<code>[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Name of page to load (default: <code>None</code>)</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.clean_empty","title":"clean_empty","text":"<pre><code>clean_empty(key)\n</code></pre> <p>Fills a button pointed by index with an empty representation.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.create_icon_for_key","title":"create_icon_for_key","text":"<pre><code>create_icon_for_key(index, colors, texture)\n</code></pre> <p>Create a default icon for supplied key with proper texture or color</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.fill_empty","title":"fill_empty","text":"<pre><code>fill_empty(key)\n</code></pre> <p>Fills all empty buttons with a default representation.</p> <p>If clean is True, removes the reprensetation rather than install a default one. Removing a representation often means installing a default, neutral one.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_attribute","title":"get_attribute","text":"<pre><code>get_attribute(attribute: str, default=None, propagate: bool = True, silence: bool = True) -&gt; Any or None\n</code></pre> <p>Returns the default attribute value</p> <p>..if avaialble at the deck level. If not, returns the parent's default attribute value (cockpit).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any or None</code>           \u2013            <p>[Any or None]: Value of attribute</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_attribute(attribute)","title":"<code>attribute</code>","text":"(<code>str</code>)           \u2013            <p>Attribute name</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_attribute(silence)","title":"<code>silence</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to complain if defalut value is not found (default: <code>False</code>)</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_button_value","title":"get_button_value","text":"<pre><code>get_button_value(name) -&gt; Any\n</code></pre> <p>Get the value of a button from its internal identifier name</p> <p>[description]</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_button_value(name)","title":"<code>name</code>","text":"(<code>[type]</code>)           \u2013            <p>[description]</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_deck_button_definition","title":"get_deck_button_definition","text":"<pre><code>get_deck_button_definition(idx) -&gt; ButtonType\n</code></pre> <p>Returns a deck's button definition from the deck type.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ButtonType</code>           \u2013            <p>[ButtonType | None]: The button type at index.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_deck_button_definition(idx)","title":"<code>idx</code>","text":"(<code>[str\u0131int]</code>)           \u2013            <p>Button index on deck</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_icon_background","title":"get_icon_background","text":"<pre><code>get_icon_background(name: str, width: int, height: int, texture_in, color_in, use_texture=True, who: str = 'Deck')\n</code></pre> <p>Returns a Pillow Image of size width x height with either the file specified by texture or a uniform color</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_id","title":"get_id","text":"<pre><code>get_id() -&gt; str\n</code></pre> <p>Returns deck identifier</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>[str]: Deck identifier string</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_image_size","title":"get_image_size","text":"<pre><code>get_image_size(index)\n</code></pre> <p>Gets image size for deck button index</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_index_numeric","title":"get_index_numeric","text":"<pre><code>get_index_numeric(index)\n</code></pre> <p>Returns the numeric part of the index of a button index for this deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_index_prefix","title":"get_index_prefix","text":"<pre><code>get_index_prefix(index)\n</code></pre> <p>Returns the prefix of a button index for this deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.get_wallpaper","title":"get_wallpaper","text":"<pre><code>get_wallpaper(index)\n</code></pre> <p>Gets image size for deck button index</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Initialisation procedure</p> <p>Load deck type definition, load deck parameters, load layout, pages, and install and start deck software.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.inspect","title":"inspect","text":"<pre><code>inspect(what: str | None = None)\n</code></pre> <p>Triggered by the Inspect activation.</p> <p>This function is called on all pages of this Deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.load","title":"load","text":"<pre><code>load()\n</code></pre> <p>Loads pages during configuration. If none is found, create a simple, static page with one activatio.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.load_home_page","title":"load_home_page","text":"<pre><code>load_home_page()\n</code></pre> <p>Loads the home page, if any.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.make_default_page","title":"make_default_page  <code>abstractmethod</code>","text":"<pre><code>make_default_page(b: str | None = None)\n</code></pre> <p>Generates a default home page for the deck, in accordance with its capabilities.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.print_page","title":"print_page","text":"<pre><code>print_page(page: Page)\n</code></pre> <p>Produces an image of the deck's layout in the current directory. For testing and development purpose.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.reload_page","title":"reload_page","text":"<pre><code>reload_page()\n</code></pre> <p>Reloads page to take into account changes in definition</p> <p>Please note that this may loead to unexpected results if page was too heavily modified or interaction with other pages occurred.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(button: Button)\n</code></pre> <p>Main procedure to render a button on the deck</p> <p>The procedure mainly fetches information from the button, for example, gets an image for display in a neutral, generic format (PNG, JPEG\u2026), then format the image to the deck specific format (B646 format for example) and send it to the deck for display using the deck drive APIs. It also convert the button index to the specific index required by the deck.</p> <p>Args;     button ([Button]): Button to render on the deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.set_deck_type","title":"set_deck_type","text":"<pre><code>set_deck_type()\n</code></pre> <p>Installs the reference to the deck type.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.set_home_page","title":"set_home_page","text":"<pre><code>set_home_page()\n</code></pre> <p>Finds and install the home page, if any.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.set_key_icon","title":"set_key_icon","text":"<pre><code>set_key_icon(key, image)\n</code></pre> <p>Access to lower level, raw function to install an image on a deck display pointed by th index key.</p> <p>Parameters:</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.set_key_icon(key)","title":"<code>key</code>","text":"(<code>[type]</code>)           \u2013            <p>[description]</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.set_key_icon(image)","title":"<code>image</code>","text":"(<code>[type]</code>)           \u2013            <p>[description]</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start()\n</code></pre> <p>Called at end of initialisation to start the deck interaction, both ways.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.terminate","title":"terminate","text":"<pre><code>terminate(disconnected: bool = False)\n</code></pre> <p>Called at end of use of deck to cleanly reset all buttons to a default, neutral state and stop deck interaction,</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.valid_activations","title":"valid_activations","text":"<pre><code>valid_activations(index=None)\n</code></pre> <p>Returns the valid activations for the button pointed by the index. If None is given, returns all valid activations.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.valid_indices","title":"valid_indices","text":"<pre><code>valid_indices(with_icon: bool = False)\n</code></pre> <p>Returns the valid indices for this deck.</p>"},{"location":"Reference/Extending/Development/API/deck/#cockpitdecks.deck.DeckWithIcons.valid_representations","title":"valid_representations","text":"<pre><code>valid_representations(index=None)\n</code></pre> <p>Returns the valid representations for the button pointed by the index. If None is given, returns all valid representations.</p>"},{"location":"Reference/Extending/Development/API/instruction/","title":"Instruction","text":"<p>Entities</p>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction","title":"instruction","text":"<p>Classes:</p> <ul> <li> <code>Instruction</code>           \u2013            <p>An Instruction to execute an action by a Performer.</p> </li> <li> <code>InstructionFactory</code>           \u2013            <p>An InstructionFactory is an entity capable of generating instructions</p> </li> <li> <code>InstructionPerformer</code>           \u2013            <p>An InstructionFactory is an entity capable of generating instructions</p> </li> <li> <code>MacroInstruction</code>           \u2013            <p>A Macro Instruction is a collection of individual Instruction.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction.Instruction","title":"Instruction","text":"<pre><code>Instruction(name: str, performer: InstructionPerformer, factory: InstructionFactory | None = None, delay: float = 0.0, condition: str | None = None)\n</code></pre> <p>An Instruction to execute an action by a Performer. Often, the Performer is an InstructionFactory and generates the Instruction it will later execute.</p> <p>Methods:</p> <ul> <li> <code>all_subclasses</code>             \u2013              <p>Returns the list of all subclasses.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction.Instruction.all_subclasses","title":"all_subclasses  <code>staticmethod</code>","text":"<pre><code>all_subclasses() -&gt; list\n</code></pre> <p>Returns the list of all subclasses.</p> <p>Recurses through all sub-sub classes</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>[list]: list of all subclasses</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If invalid class found in recursion (types, etc.)</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction.InstructionFactory","title":"InstructionFactory","text":"<p>An InstructionFactory is an entity capable of generating instructions Often, the entity generates instruction it will perform.</p>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction.InstructionPerformer","title":"InstructionPerformer","text":"<p>An InstructionFactory is an entity capable of generating instructions Often, the entity generates instruction it will perform.</p>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction.MacroInstruction","title":"MacroInstruction","text":"<pre><code>MacroInstruction(name: str, performer: InstructionPerformer, factory: InstructionFactory, instructions: dict, delay: float = 0.0, condition: str | None = None)\n</code></pre> <p>A Macro Instruction is a collection of individual Instruction. Each instruction comes with its condition for execution and delay since activation. (Could have been called Instructions (plural form))</p> <p>Methods:</p> <ul> <li> <code>all_subclasses</code>             \u2013              <p>Returns the list of all subclasses.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/instruction/#cockpitdecks.instruction.MacroInstruction.all_subclasses","title":"all_subclasses  <code>staticmethod</code>","text":"<pre><code>all_subclasses() -&gt; list\n</code></pre> <p>Returns the list of all subclasses.</p> <p>Recurses through all sub-sub classes</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>[list]: list of all subclasses</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If invalid class found in recursion (types, etc.)</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/representation/","title":"Representation","text":"<p>Entities</p>"},{"location":"Reference/Extending/Development/API/representation/#cockpitdecks.buttons.representation.representation","title":"representation","text":"<p>Button display and rendering abstraction. All representations are listed at the end of this file.</p> <p>Classes:</p> <ul> <li> <code>Representation</code>           \u2013            <p>Base class for all representations</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/representation/#cockpitdecks.buttons.representation.representation.Representation","title":"Representation","text":"<pre><code>Representation(button: Button)\n</code></pre> <p>Base class for all representations</p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              <p>This is the main rendering function for all representations.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/representation/#cockpitdecks.buttons.representation.representation.Representation.render","title":"render","text":"<pre><code>render()\n</code></pre> <p>This is the main rendering function for all representations. It returns what is appropriate to the button render() function which passes it to the deck's render() function which takes appropriate action to pass the returned value to the appropriate device function for display.</p>"},{"location":"Reference/Extending/Development/API/simulator/","title":"Simulator","text":"<p>Entities</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator","title":"simulator","text":"<p>Classes:</p> <ul> <li> <code>NoSimulator</code>           \u2013            <p>Dummy place holder Simulator class for demonstration purposes</p> </li> <li> <code>Simulator</code>           \u2013            <p>Abstract class for execution of operations and collection of data in the simulation software.</p> </li> <li> <code>SimulatorActivity</code>           \u2013            <p>An activity is something that happened in the simulator.</p> </li> <li> <code>SimulatorEvent</code>           \u2013            <p>Simulator event base class.</p> </li> <li> <code>SimulatorInstruction</code>           \u2013            <p>An Instruction to be submitted to and performed by the simulator:</p> </li> <li> <code>SimulatorVariable</code>           \u2013            <p>A specialised variable to monitor in the simulator</p> </li> <li> <code>SimulatorVariableEvent</code>           \u2013            <p>Data Update Event</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator","title":"NoSimulator","text":"<pre><code>NoSimulator(cockpit, environ)\n</code></pre> <p>Dummy place holder Simulator class for demonstration purposes</p> <p>Methods:</p> <ul> <li> <code>activity_factory</code>             \u2013              <p>Returns data or create a new internal variable</p> </li> <li> <code>add_simulator_events_to_monitor</code>             \u2013              <p>Adds supplied data to Simulator monitoring.</p> </li> <li> <code>clean_simulator_event_to_monitor</code>             \u2013              <p>Removes all data from Simulator monitoring.</p> </li> <li> <code>clean_simulator_variable_to_monitor</code>             \u2013              <p>Removes all data from Simulator monitoring.</p> </li> <li> <code>datetime</code>             \u2013              <p>Returns the current simulator date and time</p> </li> <li> <code>get_internal_variable</code>             \u2013              <p>Returns the InternalVariable or creates it if it is the first time it is accessed.</p> </li> <li> <code>get_simulator_variable_value</code>             \u2013              <p>Gets the value of a SimulatorVariable monitored by Cockpitdecks</p> </li> <li> <code>get_variable</code>             \u2013              <p>Returns data or create a new one, internal if path requires it</p> </li> <li> <code>inc</code>             \u2013              <p>Increment a SimulatorVariable</p> </li> <li> <code>inc_internal_variable</code>             \u2013              <p>Incretement an InternalVariable</p> </li> <li> <code>register</code>             \u2013              <p>Registers a SimulatorVariable to be monitored by Cockpitdecks.</p> </li> <li> <code>remove_all_simulator_event</code>             \u2013              <p>Removes all data from Simulator.</p> </li> <li> <code>remove_all_simulator_variable</code>             \u2013              <p>Removes all data from Simulator.</p> </li> <li> <code>remove_simulator_events_to_monitor</code>             \u2013              <p>Removes supplied data from Simulator monitoring.</p> </li> <li> <code>set_internal_variable</code>             \u2013              <p>Sets the value of an InternalVariable. If the data does not exist, it is created first.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.activity_factory","title":"activity_factory","text":"<pre><code>activity_factory(name: str, creator: str = None) -&gt; Activity\n</code></pre> <p>Returns data or create a new internal variable</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.add_simulator_events_to_monitor","title":"add_simulator_events_to_monitor","text":"<pre><code>add_simulator_events_to_monitor(simulator_events: set, reason: str = None)\n</code></pre> <p>Adds supplied data to Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.clean_simulator_event_to_monitor","title":"clean_simulator_event_to_monitor","text":"<pre><code>clean_simulator_event_to_monitor()\n</code></pre> <p>Removes all data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.clean_simulator_variable_to_monitor","title":"clean_simulator_variable_to_monitor","text":"<pre><code>clean_simulator_variable_to_monitor()\n</code></pre> <p>Removes all data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.datetime","title":"datetime","text":"<pre><code>datetime(zulu: bool = False, system: bool = False) -&gt; datetime\n</code></pre> <p>Returns the current simulator date and time</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.get_internal_variable","title":"get_internal_variable","text":"<pre><code>get_internal_variable(name: str, is_string: bool = False) -&gt; Variable\n</code></pre> <p>Returns the InternalVariable or creates it if it is the first time it is accessed. Args:     name (str): [description]     is_string (bool): [description] (default: <code>False</code>)</p> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.get_simulator_variable_value","title":"get_simulator_variable_value","text":"<pre><code>get_simulator_variable_value(simulator_variable: SimulatorVariable, default=None) -&gt; Any | None\n</code></pre> <p>Gets the value of a SimulatorVariable monitored by Cockpitdecks Args:     simulator_variable (SimulatorVariable): Variable to get the value from.     default (Any): DEfault value if variable value is None.</p> <p>Returns:</p> <ul> <li> <code>Any | None</code>           \u2013            </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str, is_string: bool = False) -&gt; InternalVariable | SimulatorVariable\n</code></pre> <p>Returns data or create a new one, internal if path requires it</p> <p>Important note: is_string has precedence over whatever type has the variable. If is_string is true, and the variable is not of type string, it is forced to type string. This is (probably) due to a first request to create the variable without being able to determine its data type. Then later, another request to create the variable happens with the proper requested type, so we adjust it. Parent objects always know what data type their variable is. (float is default, string is explicit.)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.inc","title":"inc","text":"<pre><code>inc(path: str, amount: float = 1.0, cascade: bool = False)\n</code></pre> <p>Increment a SimulatorVariable</p> <p>Parameters:</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.inc(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>[description]</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.inc(amount)","title":"<code>amount</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>[description] (default: <code>1.0</code>)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.inc(cascade)","title":"<code>cascade</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[description] (default: <code>False</code>)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.inc_internal_variable","title":"inc_internal_variable","text":"<pre><code>inc_internal_variable(name: str, amount: float, cascade: bool = False)\n</code></pre> <p>Incretement an InternalVariable Args:     name (str): [description]     amount (float): [description]     cascade (bool): [description] (default: <code>False</code>)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.register","title":"register","text":"<pre><code>register(variable: Variable) -&gt; Variable\n</code></pre> <p>Registers a SimulatorVariable to be monitored by Cockpitdecks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Variable</code> (              <code>Variable</code> )          \u2013            <p>Registered variable</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.register(variable)","title":"<code>variable</code>","text":"(<code>Variable</code>)           \u2013            <p>Variable to register</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.remove_all_simulator_event","title":"remove_all_simulator_event","text":"<pre><code>remove_all_simulator_event()\n</code></pre> <p>Removes all data from Simulator.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.remove_all_simulator_variable","title":"remove_all_simulator_variable","text":"<pre><code>remove_all_simulator_variable()\n</code></pre> <p>Removes all data from Simulator.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.remove_simulator_events_to_monitor","title":"remove_simulator_events_to_monitor","text":"<pre><code>remove_simulator_events_to_monitor(simulator_events: set, reason: str = None)\n</code></pre> <p>Removes supplied data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.NoSimulator.set_internal_variable","title":"set_internal_variable","text":"<pre><code>set_internal_variable(name: str, value: float, cascade: bool)\n</code></pre> <p>Sets the value of an InternalVariable. If the data does not exist, it is created first.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator","title":"Simulator","text":"<pre><code>Simulator(cockpit, environ)\n</code></pre> <p>Abstract class for execution of operations and collection of data in the simulation software.</p> <p>Methods:</p> <ul> <li> <code>activity_factory</code>             \u2013              <p>Returns data or create a new internal variable</p> </li> <li> <code>add_simulator_events_to_monitor</code>             \u2013              <p>Adds supplied data to Simulator monitoring.</p> </li> <li> <code>add_simulator_variables_to_monitor</code>             \u2013              <p>Adds supplied data to Simulator monitoring.</p> </li> <li> <code>clean_simulator_event_to_monitor</code>             \u2013              <p>Removes all data from Simulator monitoring.</p> </li> <li> <code>clean_simulator_variable_to_monitor</code>             \u2013              <p>Removes all data from Simulator monitoring.</p> </li> <li> <code>datetime</code>             \u2013              <p>Returns the current simulator date and time</p> </li> <li> <code>get_internal_variable</code>             \u2013              <p>Returns the InternalVariable or creates it if it is the first time it is accessed.</p> </li> <li> <code>get_simulator_variable_value</code>             \u2013              <p>Gets the value of a SimulatorVariable monitored by Cockpitdecks</p> </li> <li> <code>get_variable</code>             \u2013              <p>Returns data or create a new one, internal if path requires it</p> </li> <li> <code>inc</code>             \u2013              <p>Increment a SimulatorVariable</p> </li> <li> <code>inc_internal_variable</code>             \u2013              <p>Incretement an InternalVariable</p> </li> <li> <code>is_night</code>             \u2013              <p>Returns whether simulator is night time</p> </li> <li> <code>register</code>             \u2013              <p>Registers a SimulatorVariable to be monitored by Cockpitdecks.</p> </li> <li> <code>remove_all_simulator_event</code>             \u2013              <p>Removes all data from Simulator.</p> </li> <li> <code>remove_all_simulator_variable</code>             \u2013              <p>Removes all data from Simulator.</p> </li> <li> <code>remove_simulator_events_to_monitor</code>             \u2013              <p>Removes supplied data from Simulator monitoring.</p> </li> <li> <code>remove_simulator_variables_to_monitor</code>             \u2013              <p>Removes supplied data from Simulator monitoring.</p> </li> <li> <code>replay_event_factory</code>             \u2013              <p>Recreates an Event from data included in the value.</p> </li> <li> <code>set_internal_variable</code>             \u2013              <p>Sets the value of an InternalVariable. If the data does not exist, it is created first.</p> </li> <li> <code>start</code>             \u2013              <p>Starts Cockpitdecks Simulator class, that is start data monitoring and instruction</p> </li> <li> <code>terminate</code>             \u2013              <p>Terminates Cockpitdecks Simulator class, stop monitoring SimulatorVariable and stop issuing</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.activity_factory","title":"activity_factory","text":"<pre><code>activity_factory(name: str, creator: str = None) -&gt; Activity\n</code></pre> <p>Returns data or create a new internal variable</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.add_simulator_events_to_monitor","title":"add_simulator_events_to_monitor","text":"<pre><code>add_simulator_events_to_monitor(simulator_events: set, reason: str = None)\n</code></pre> <p>Adds supplied data to Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.add_simulator_variables_to_monitor","title":"add_simulator_variables_to_monitor","text":"<pre><code>add_simulator_variables_to_monitor(simulator_variables: dict, reason: str = None)\n</code></pre> <p>Adds supplied data to Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.clean_simulator_event_to_monitor","title":"clean_simulator_event_to_monitor","text":"<pre><code>clean_simulator_event_to_monitor()\n</code></pre> <p>Removes all data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.clean_simulator_variable_to_monitor","title":"clean_simulator_variable_to_monitor","text":"<pre><code>clean_simulator_variable_to_monitor()\n</code></pre> <p>Removes all data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.datetime","title":"datetime","text":"<pre><code>datetime(zulu: bool = False, system: bool = False) -&gt; datetime\n</code></pre> <p>Returns the current simulator date and time</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.get_internal_variable","title":"get_internal_variable","text":"<pre><code>get_internal_variable(name: str, is_string: bool = False) -&gt; Variable\n</code></pre> <p>Returns the InternalVariable or creates it if it is the first time it is accessed. Args:     name (str): [description]     is_string (bool): [description] (default: <code>False</code>)</p> <p>Returns:</p> <ul> <li> <code>Variable</code>           \u2013            </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.get_simulator_variable_value","title":"get_simulator_variable_value","text":"<pre><code>get_simulator_variable_value(simulator_variable: SimulatorVariable, default=None) -&gt; Any | None\n</code></pre> <p>Gets the value of a SimulatorVariable monitored by Cockpitdecks Args:     simulator_variable (SimulatorVariable): Variable to get the value from.     default (Any): DEfault value if variable value is None.</p> <p>Returns:</p> <ul> <li> <code>Any | None</code>           \u2013            </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: str, is_string: bool = False) -&gt; InternalVariable | SimulatorVariable\n</code></pre> <p>Returns data or create a new one, internal if path requires it</p> <p>Important note: is_string has precedence over whatever type has the variable. If is_string is true, and the variable is not of type string, it is forced to type string. This is (probably) due to a first request to create the variable without being able to determine its data type. Then later, another request to create the variable happens with the proper requested type, so we adjust it. Parent objects always know what data type their variable is. (float is default, string is explicit.)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.inc","title":"inc","text":"<pre><code>inc(path: str, amount: float = 1.0, cascade: bool = False)\n</code></pre> <p>Increment a SimulatorVariable</p> <p>Parameters:</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.inc(path)","title":"<code>path</code>","text":"(<code>str</code>)           \u2013            <p>[description]</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.inc(amount)","title":"<code>amount</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>[description] (default: <code>1.0</code>)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.inc(cascade)","title":"<code>cascade</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[description] (default: <code>False</code>)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.inc_internal_variable","title":"inc_internal_variable","text":"<pre><code>inc_internal_variable(name: str, amount: float, cascade: bool = False)\n</code></pre> <p>Incretement an InternalVariable Args:     name (str): [description]     amount (float): [description]     cascade (bool): [description] (default: <code>False</code>)</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.is_night","title":"is_night  <code>abstractmethod</code>","text":"<pre><code>is_night() -&gt; bool\n</code></pre> <p>Returns whether simulator is night time</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.register","title":"register","text":"<pre><code>register(variable: Variable) -&gt; Variable\n</code></pre> <p>Registers a SimulatorVariable to be monitored by Cockpitdecks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Variable</code> (              <code>Variable</code> )          \u2013            <p>Registered variable</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.register(variable)","title":"<code>variable</code>","text":"(<code>Variable</code>)           \u2013            <p>Variable to register</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.remove_all_simulator_event","title":"remove_all_simulator_event","text":"<pre><code>remove_all_simulator_event()\n</code></pre> <p>Removes all data from Simulator.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.remove_all_simulator_variable","title":"remove_all_simulator_variable","text":"<pre><code>remove_all_simulator_variable()\n</code></pre> <p>Removes all data from Simulator.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.remove_simulator_events_to_monitor","title":"remove_simulator_events_to_monitor","text":"<pre><code>remove_simulator_events_to_monitor(simulator_events: set, reason: str = None)\n</code></pre> <p>Removes supplied data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.remove_simulator_variables_to_monitor","title":"remove_simulator_variables_to_monitor","text":"<pre><code>remove_simulator_variables_to_monitor(simulator_variables: dict, reason: str = None)\n</code></pre> <p>Removes supplied data from Simulator monitoring.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.replay_event_factory","title":"replay_event_factory  <code>abstractmethod</code>","text":"<pre><code>replay_event_factory(name: str, value)\n</code></pre> <p>Recreates an Event from data included in the value.</p> <p>Parameters:</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.replay_event_factory(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>Name of event to replay</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.replay_event_factory(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>value of event to replay</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.set_internal_variable","title":"set_internal_variable","text":"<pre><code>set_internal_variable(name: str, value: float, cascade: bool)\n</code></pre> <p>Sets the value of an InternalVariable. If the data does not exist, it is created first.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start()\n</code></pre> <p>Starts Cockpitdecks Simulator class, that is start data monitoring and instruction execution if instructed to do so.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.Simulator.terminate","title":"terminate  <code>abstractmethod</code>","text":"<pre><code>terminate()\n</code></pre> <p>Terminates Cockpitdecks Simulator class, stop monitoring SimulatorVariable and stop issuing instructionsto the simulator..</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorActivity","title":"SimulatorActivity","text":"<pre><code>SimulatorActivity(simulator: Simulator, name: str, value: Any | None = None)\n</code></pre> <p>An activity is something that happened in the simulator.</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent","title":"SimulatorEvent","text":"<pre><code>SimulatorEvent(sim: Simulator, autorun: bool = True)\n</code></pre> <p>Simulator event base class.</p> <p>Defines required capability to handle event. Keeps a timestamp when event was created</p> <p>[description]</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>handled</code>             \u2013              <p>Called when event has been processed</p> </li> <li> <code>handling</code>             \u2013              <p>Called before event is processed</p> </li> <li> <code>is_processed</code>             \u2013              <p>Returns whether event has been processed and marked as such</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>delay</code>               (<code>float</code>)           \u2013            <p>Returns event handling duration in seconds</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>Returns event handling duration in seconds</p> </li> <li> <code>event</code>               (<code>str</code>)           \u2013            <p>Event type</p> </li> <li> <code>timestamp</code>               (<code>float</code>)           \u2013            <p>Event creation timestamp</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent(sim)","title":"<code>sim</code>","text":"(<code>Simulator</code>)           \u2013            <p>Simulator that produced the event</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent(autorun)","title":"<code>autorun</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the event</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.delay","title":"delay  <code>property</code>","text":"<pre><code>delay: float\n</code></pre> <p>Returns event handling duration in seconds</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Returns event handling duration in seconds</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.event","title":"event  <code>property</code>","text":"<pre><code>event: str\n</code></pre> <p>Event type</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: float\n</code></pre> <p>Event creation timestamp</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.handled","title":"handled","text":"<pre><code>handled()\n</code></pre> <p>Called when event has been processed</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.handling","title":"handling","text":"<pre><code>handling()\n</code></pre> <p>Called before event is processed</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorEvent.is_processed","title":"is_processed","text":"<pre><code>is_processed() -&gt; bool\n</code></pre> <p>Returns whether event has been processed and marked as such</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorInstruction","title":"SimulatorInstruction","text":"<pre><code>SimulatorInstruction(name: str, simulator: Simulator, delay: float = 0.0, condition: str | None = None)\n</code></pre> <p>An Instruction to be submitted to and performed by the simulator:</p> <p>Methods:</p> <ul> <li> <code>all_subclasses</code>             \u2013              <p>Returns the list of all subclasses.</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorInstruction.all_subclasses","title":"all_subclasses  <code>staticmethod</code>","text":"<pre><code>all_subclasses() -&gt; list\n</code></pre> <p>Returns the list of all subclasses.</p> <p>Recurses through all sub-sub classes</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>[list]: list of all subclasses</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If invalid class found in recursion (types, etc.)</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariable","title":"SimulatorVariable","text":"<pre><code>SimulatorVariable(name: str, simulator: Simulator, data_type: str = 'float', physical_unit: str = '')\n</code></pre> <p>A specialised variable to monitor in the simulator</p> <p>Methods:</p> <ul> <li> <code>value_formatted</code>             \u2013              <p>Format value if format is supplied</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariable.value_formatted","title":"value_formatted","text":"<pre><code>value_formatted()\n</code></pre> <p>Format value if format is supplied Returns:     formatted value</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent","title":"SimulatorVariableEvent","text":"<pre><code>SimulatorVariableEvent(sim: Simulator, name: str, value: float | str, cascade: bool, autorun: bool = True)\n</code></pre> <p>Data Update Event</p> <p>Args:</p> <p>Methods:</p> <ul> <li> <code>handled</code>             \u2013              <p>Called when event has been processed</p> </li> <li> <code>handling</code>             \u2013              <p>Called before event is processed</p> </li> <li> <code>is_processed</code>             \u2013              <p>Returns whether event has been processed and marked as such</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>delay</code>               (<code>float</code>)           \u2013            <p>Returns event handling duration in seconds</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>Returns event handling duration in seconds</p> </li> <li> <code>event</code>               (<code>str</code>)           \u2013            <p>Event type</p> </li> <li> <code>timestamp</code>               (<code>float</code>)           \u2013            <p>Event creation timestamp</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.delay","title":"delay  <code>property</code>","text":"<pre><code>delay: float\n</code></pre> <p>Returns event handling duration in seconds</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Returns event handling duration in seconds</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.event","title":"event  <code>property</code>","text":"<pre><code>event: str\n</code></pre> <p>Event type</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: float\n</code></pre> <p>Event creation timestamp</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.handled","title":"handled","text":"<pre><code>handled()\n</code></pre> <p>Called when event has been processed</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.handling","title":"handling","text":"<pre><code>handling()\n</code></pre> <p>Called before event is processed</p>"},{"location":"Reference/Extending/Development/API/simulator/#cockpitdecks.simulator.SimulatorVariableEvent.is_processed","title":"is_processed","text":"<pre><code>is_processed() -&gt; bool\n</code></pre> <p>Returns whether event has been processed and marked as such</p>"},{"location":"Reference/Extending/Development/API/resources/","title":"Cockpitdecks API - Resources","text":"<p>Entities</p> <ul> <li>Deck Types</li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/","title":"Deck Type","text":"<p>Entities &gt; Resources</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype","title":"decktype","text":"<p>Classes:</p> <ul> <li> <code>ButtonBlock</code>           \u2013            <p>Defines a button on a deck, its capabilities, its representation.</p> </li> <li> <code>ButtonType</code>           \u2013            <p>Defines a button on a deck, its capabilities, its representation.</p> </li> <li> <code>DeckType</code>           \u2013            <p>Description of a deck capabilities, including its representation for web decks</p> </li> <li> <code>DeckTypeBase</code>           \u2013            <p>Description of a deck capabilities, including its representation for web decks</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.ButtonBlock","title":"ButtonBlock","text":"<pre><code>ButtonBlock(config: dict)\n</code></pre> <p>Defines a button on a deck, its capabilities, its representation.</p> <p>For web decks, adds position and sizes information.</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.ButtonType","title":"ButtonType","text":"<pre><code>ButtonType(config: dict, button_block: ButtonBlock)\n</code></pre> <p>Defines a button on a deck, its capabilities, its representation.</p> <p>For web decks, adds position and sizes information.</p> <p>Methods:</p> <ul> <li> <code>desc</code>             \u2013              <p>Returns a flattened description of the button</p> </li> <li> <code>display_size</code>             \u2013              <p>Parses info from resources.decks.*.yaml</p> </li> <li> <code>get_offset</code>             \u2013              <p>Parses info from resources.decks.*.yaml</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.ButtonType.desc","title":"desc","text":"<pre><code>desc() -&gt; dict\n</code></pre> <p>Returns a flattened description of the button</p> <p>Ready to be used by web deck</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>ButtonDeck description, simply flattened for web decks</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.ButtonType.display_size","title":"display_size","text":"<pre><code>display_size() -&gt; Tuple[int, int] | None\n</code></pre> <p>Parses info from resources.decks.*.yaml</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.ButtonType.get_offset","title":"get_offset","text":"<pre><code>get_offset(return_offset: bool = False) -&gt; Tuple[int, int] | None\n</code></pre> <p>Parses info from resources.decks.*.yaml</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType","title":"DeckType","text":"<pre><code>DeckType(filename: str)\n</code></pre> <p>Description of a deck capabilities, including its representation for web decks</p> <p>Reads and parse deck template file</p> <p>Methods:</p> <ul> <li> <code>desc</code>             \u2013              <p>Returns a flattened description of the deck</p> </li> <li> <code>get_empty_button_config</code>             \u2013              <p>Returns a dummy working button config for \"empty\" hardware representation</p> </li> <li> <code>init</code>             \u2013              <p>Parses a deck definition file and build a list of what's available.</p> </li> <li> <code>is_virtual_deck</code>             \u2013              <p>Validate consistency between virtual deck parameters.</p> </li> <li> <code>parse_deck_button_block</code>             \u2013              <p>Parses a deck button definition block</p> </li> <li> <code>special_displays</code>             \u2013              <p>Returns name of all special displays (i.e. not \"keys\")</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType.desc","title":"desc","text":"<pre><code>desc() -&gt; dict\n</code></pre> <p>Returns a flattened description of the deck</p> <p>Ready to be used by web deck</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>[dict]: Deck description (DeckType), simply flattened for web decks</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType.get_empty_button_config","title":"get_empty_button_config","text":"<pre><code>get_empty_button_config(key)\n</code></pre> <p>Returns a dummy working button config for \"empty\" hardware representation</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Parses a deck definition file and build a list of what's available.</p> <p>Mainly a list of buttons, what can be done with each (action), and what the button can provide as a feedback.</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType.is_virtual_deck","title":"is_virtual_deck","text":"<pre><code>is_virtual_deck() -&gt; bool\n</code></pre> <p>Validate consistency between virtual deck parameters.</p> <p>Virtual decks need to provide additional information (like layout). We check for consistency between layout (used by user interface to create deck) and information for Cockpitdecks.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>Virtual deck definition is consistent or not</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType.parse_deck_button_block","title":"parse_deck_button_block","text":"<pre><code>parse_deck_button_block(button_block) -&gt; Dict[str | int, ButtonType]\n</code></pre> <p>Parses a deck button definition block</p> <p>A ButtonType block defines either a single deck button (no repeat attribute) or a collection of similar buttons if there is a repeat attribute.</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckType.special_displays","title":"special_displays","text":"<pre><code>special_displays()\n</code></pre> <p>Returns name of all special displays (i.e. not \"keys\")</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase","title":"DeckTypeBase","text":"<pre><code>DeckTypeBase(config: dict)\n</code></pre> <p>Description of a deck capabilities, including its representation for web decks</p> <p>Reads and parse deck template file</p> <p>Methods:</p> <ul> <li> <code>desc</code>             \u2013              <p>Returns a flattened description of the deck</p> </li> <li> <code>get_empty_button_config</code>             \u2013              <p>Returns a dummy working button config for \"empty\" hardware representation</p> </li> <li> <code>init</code>             \u2013              <p>Parses a deck definition file and build a list of what's available.</p> </li> <li> <code>is_virtual_deck</code>             \u2013              <p>Validate consistency between virtual deck parameters.</p> </li> <li> <code>parse_deck_button_block</code>             \u2013              <p>Parses a deck button definition block</p> </li> <li> <code>special_displays</code>             \u2013              <p>Returns name of all special displays (i.e. not \"keys\")</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase.desc","title":"desc","text":"<pre><code>desc() -&gt; dict\n</code></pre> <p>Returns a flattened description of the deck</p> <p>Ready to be used by web deck</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>[dict]: Deck description (DeckType), simply flattened for web decks</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase.get_empty_button_config","title":"get_empty_button_config","text":"<pre><code>get_empty_button_config(key)\n</code></pre> <p>Returns a dummy working button config for \"empty\" hardware representation</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Parses a deck definition file and build a list of what's available.</p> <p>Mainly a list of buttons, what can be done with each (action), and what the button can provide as a feedback.</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase.is_virtual_deck","title":"is_virtual_deck","text":"<pre><code>is_virtual_deck() -&gt; bool\n</code></pre> <p>Validate consistency between virtual deck parameters.</p> <p>Virtual decks need to provide additional information (like layout). We check for consistency between layout (used by user interface to create deck) and information for Cockpitdecks.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>Virtual deck definition is consistent or not</p> </li> </ul>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase.parse_deck_button_block","title":"parse_deck_button_block","text":"<pre><code>parse_deck_button_block(button_block) -&gt; Dict[str | int, ButtonType]\n</code></pre> <p>Parses a deck button definition block</p> <p>A ButtonType block defines either a single deck button (no repeat attribute) or a collection of similar buttons if there is a repeat attribute.</p>"},{"location":"Reference/Extending/Development/API/resources/decktype/#cockpitdecks.decks.resources.decktype.DeckTypeBase.special_displays","title":"special_displays","text":"<pre><code>special_displays()\n</code></pre> <p>Returns name of all special displays (i.e. not \"keys\")</p>"},{"location":"Reference/Extending/Development/Internals/About%20Internals/","title":"About Internals","text":"<p>Internals are custom notes, schema, drawing that help understanding how Cockpitdecks work.</p> <p>Some document have evolved with time, some other have been abadoned.</p> <p>There is no garantee of useful information, juste ideas, concepts and notes.</p>"},{"location":"Reference/Extending/Development/Internals/Activation%20Mechanism/","title":"Activation Mechanism","text":"<p>Activation occurs when a Button is requested to handle an Event.</p> <p>A first step consists of the Activation preparation and initialization. This occurs when the deck is installed and each page created.</p> <p>Initialization of the Activation will result in the creation of one or more Instructions. In the process, the  Performer entity responsible for executing the Instruction is clearly identified. For example, CockpitInstruction are performed by the Cockpit entity, while SimulatorInstructions are executed by the simulator software.</p> <p>The initialization of the Activation result in a global status is_valid() that returns True if the Activation contains all information necessary for handling events.</p> <p>When the Button receives the event, it calls the activate() function on its activation, supplying the event.</p> <pre><code>\t# In the Button class\n\tdef activate(self, event) -&gt; bool:\n\t\tresult = self._activation.activate(event)\n\t\tif result:\n\t\t\tself.render()\n\t\telse:\n\t\t\tlogger.warning(\"there was an issue handling the event\")\n</code></pre> <p>Activate() functions return the status of the execution, True if all instructions were carried out without error.</p> <p>The Activation activate() function always proceeds in similar patterns:</p> <ol> <li>It first checks whether the Activation is capable of handling the event.</li> <li>Depending on the event type, it executes one or more Instructions, collecting the result of the execution.</li> <li>When all Instructions have completed, it returns a global status for the entire Activation.</li> </ol> <p>Here is a pseudo-code that handles button press events:</p> <pre><code>\t# In the Activation class\n    def activate(self, event: PushEvent) -&gt; bool:\n\t    status = False\n        if not self.can_handle(event):\n            return False\n        if not super().activate(event):\n            return False\n        if event.pressed:\n            status = self.instruction.execute()\n        return status  # Normal termination\n</code></pre> <p>From then on, the Button must decide what to do next, including if necessary regenerating its appearance.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/","title":"Cockpitdecks Internals","text":"<p>As simple as it may appears when working, Cockpitdecks is a complex piece of software that relies on numerous technologies, systems, and interfaces to provide, ultimately, a confortable user experience.</p> <p>First of all, Cockpitdecks tries to provide a uniform representation of different deck models. Each deck model, from different manufacturers, has its own way of doing things. Different decks are accessed differently, some through basic serial (USB) interfaces, some through application programming interfaces, and some other through existing \"protocols\" made to talk to devices like HID or MIDI. Some device even allow several methods to be used.</p> <p>Cockpitdecks uses the appropriate method to hide the complexity of accessing the deck devices, to hide their particularities, at the expense of a complex and modular installation process. Some will use a single device, some other will use more than one, combining different models and brands to suit their needs.</p> <p>Cockpitdecks communicates with X-Plane through the new web API. This offers the advantage that Cockpitdecks and X-Plane do not necessarily need to run on the same computer, as long as both computer are on the same local network.</p> <p>Through the web aPI, X-Plane reports some of its internal parameter values (called datarefs), and accepts commands to execute.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#architecture","title":"Architecture","text":""},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#cockpitdecks-software-entities","title":"Cockpitdecks Software Entities","text":"<p>Cockpitdecks proceeds by starting autonomous threads of execution that monitor different aspects of the interaction of decks with X-Plane.</p> <p>Cockpitdecks threads are often created in start() procedures and terminated in terminate() procedures. Communication with the thread is performed through synchronous Queues.</p> <p>In addition, each deck has its own, internal, mechanism to capture user interactions.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#execution-of-actions","title":"Execution of Actions","text":"<p>As today, things that occurs on a deck are captured by a lower level computer software module. In the case of Cockpitdecks and its Streamdeck, Loupedeck and Berhinger devices, each of those lower level software module is designed to use a user-provided callback function that is called each time something occurs on the deck. That's how event enters Cockpitdecks.</p> <p>During initialization of a deck, Cockpitdecks installs a small, minimalist callback function in the deck software module. This callback function processes data provided from the deck and immediately converts it into an Event (a Deck Event) that gets enqueued right away for later handling. This process is optimized to be as minimal and as fast as possible. The Queue where events are then enqueued is called the Event Queue.</p> <p>The Event Queue that receives all events from all decks connected to the system is unique for a Cockpit. It is the entry point for all interactions into Cockpitdecks. It behaves like a clean separator between lower level interaction handling at the device and Cockpitdecks. The callback function is responsible for decoding the information received from the device and crafting a typed Event that correspond to the interaction that occurred. The event also carries the necessary complementary information and data like, for instance, the precise button that was pressed or turned.</p> <p></p> <p>Inside Cockpitdecks' Cockpit, a thread of execution receives the event from the Event Queue and immediately executes them to perform the action they carry.</p> <p>The action is executed in a separate thread of execution from those of the lower level physical interactions. Should execution of the action fail, the thread of execution of the capture is not affected.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#dataref-monitoring","title":"Dataref Monitoring","text":"<p>There is a similar mechanism for dataref values capture and processing.</p> <p>In the Simulator entity, a thread monitors datarefs by collecting them as they arrive on UDP port. It compare each value with the last one captured and enqueue a \"value changed\" event into the Event Queue if it was updated.</p> <p></p> <p>Each dataref maintains a list of buttons that use/rely on it, and each of those buttons gets notified of the change to adjust. When a button receives the message that one of its dataref has changed, it can adjust its internal state, and if it is currently rendered on a deck, adjust its display.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#thread-for-connection-to-x-plane","title":"Thread for Connection to X-Plane","text":"<p>In the Simulator, a thread permanently monitors the connection of Cockpitdecks to X-Plane. When there is no connection, the thread attempt to initiate a new connection until it succeeds.</p> <p>When a new connection is created, it immediately request dataref updates and update all decks with all dataref values.</p> <p>If the connection breaks, it restarts its attempts to connect.</p> <p>When there is no connection to X-Plane, Cockpitdecks works as expected, however, no command get issued to X-Plane, and no dataref value gets collected, hence, no deck icon gets updated to reflect the state changes.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#internal-datarefs","title":"Internal Datarefs","text":"<p>Datarefs whose name starts with a prefix (currently <code>data:</code>) behave like any other datarefs but are neither forwarded to X-Plane, nor read from it. They can be set, read, etc. like any other datarefs allowing for a kind of inter-button communication: one button sets it, another one adjust its appearance based on it, even buttons on another deck!</p> <p>Truly, the sky is the limit. Enjoy.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#internal-resource-folder","title":"Internal Resource Folder","text":"<p>In addition to aircraft specific definitions, Cockpitdecks contains in its core, a default configuration used as a fall back if no value is found at the aircraft specific level. These global core configuration is found in a <code>resources</code> folder inside Cockpitdecks software package. This folder should never be changed since it affects the entire Cockpitdecks application. It contains the following files and subfolders:</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#configyaml","title":"config.yaml","text":"<p>This is a global level configuration file. It always is loaded first and can be overwritten by aircraft, deck, or page-specific variants.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#icons","title":"icons","text":"<p>Icons in this folder are available to all aircrafts.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#fonts","title":"fonts","text":"<p>Fonts in this folder are available to all aircrafts.</p> <p>Cockpitdecks provides a few fonts found here and there together with their respective copyright files.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#docs","title":"docs","text":"<p>A copy of Cockpitdecks documentation is included there. The documentation folder produced in the GitHub wiki of Cockpitdecks.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#image-files","title":"Image files","text":"<p>The resource folder contains a few image files used as logos and wallpapers.</p> <p>There is also an image with color names that can be used in <code>color</code> attributes.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#iconfontspy","title":"iconfonts.py","text":"<p>This file defines icon fonts. Icon fonts are fonts that are used to display iconic characters often named intuitively. Cockpitdecks comes with a copy of Font Awesome icons, and Weather Icons.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20Internals/#constantspy","title":"constants.py","text":"<p>Defines a few constants that should never be changed. Change at your own risk.</p>"},{"location":"Reference/Extending/Development/Internals/Cockpitdecks%20as%20a%20Framework/","title":"Cockpitdecks as a Framework","text":"<p>Cockpitdecks was created to solve the specific problem of connecting desktop decks devices to a flight simulator software. It appears in the code vocabulary.</p> <p>However, with an additional level of abstraction, the simulation software is connects to:</p> <ul> <li>does not need to be a flight simulation software. It could be train simulation, truck, car, boat, you name it.</li> <li>does not need to be a simulation software.</li> </ul> <p>Any \u00ab\u00a0external\u00a0\u00bb software that can be driven by desktop deck and that provides feedback through an API can be used with Cockpitdecks. Conditions remain on the software Cockpitdecks connects to that it offers an interface to issue instructions and to read feedback from.</p>"},{"location":"Reference/Extending/Development/Internals/Configuration%20Files%20and%20Attributes/","title":"Configuration Files and Attributes","text":"<p>Config files are kept in a Config structure which allows for easy access to attribute values.</p> Attribute Content cockpit._config deckconfig/config.yaml file cockpit._resources_config resources/config.yaml global file deck._config portion of the deckconfig/config.yaml file for this deck deck.deck_type Deck Type file for this deck deck._layout_config layout/config.yaml file decktype._config decktype.yalm file page._config page.yaml file button._config portion of the buttons attribute above for this button button._def portion of the decktype buttons for this button"},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/","title":"Dataref Scanning","text":"<p>Button definitions contains several attributes where datarefs can be used. Cockpitdecks needs to parse those attributes to create a list of datarefs to monitor.</p> <p>This page is an attempt to specify formally where datarefs are to be found.</p> <p>Dataref and Variable SCanning</p> <p>This is \u00ab Work In Progress \u00bb</p>"},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#button-level","title":"Button-Level","text":""},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#button-value","title":"Button Value","text":""},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#formula","title":"Formula","text":""},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#single-dataref","title":"Single dataref","text":""},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#multiple-datarefs","title":"Multiple Datarefs","text":"<p>(Dataref list, or dictionary.)</p>"},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#single-dataref-with-multiple-value-array","title":"Single Dataref with Multiple Value (Array)","text":"<p>(List of values)</p>"},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#multiple-datarefs_1","title":"Multiple Datarefs","text":"<p>(\u00abDictionary\u00bb of values)</p>"},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#annunciator-specific","title":"Annunciator Specific","text":""},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#guard","title":"Guard","text":""},{"location":"Reference/Extending/Development/Internals/Dataref%20Scanning/#managed-mode","title":"\u00abManaged\u00bb Mode","text":""},{"location":"Reference/Extending/Development/Internals/Deck%20Event%20Processing/","title":"Deck Event Processing","text":"<p>From the parameter supplied in the callback function, Cockpitdecks determine the type of interaction that occurred (pushed, turned, swiped\u2026). For that interaction, an Event of a precise type is created, with all detailed parameters available to it. The callback function does not execute the activation but rather enqueues the event for later processing.</p> <p>In Cockpitdecks, another thread of execution reads events from the queue and perform the required action. This cleanly separate event collection and event \"execution\" in two separate process threads.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Event%20Processing/#activation","title":"Activation","text":"<p>The activation is the piece of code that will process the event.</p> <pre><code>class Push(Activation):\n    \"\"\"\n    Defines a Push activation.\n    The supplied command is executed each time a button is pressed.\n    \"\"\"\n    ACTIVATION_NAME = \"push\"\n    REQUIRED_DECK_ACTIONS = DECK_ACTIONS.PUSH\n</code></pre> <p>Activation usually leads to either</p> <ul> <li>one or more command sent to the simulator for execution</li> <li>internal changes of the deck, like loading a new page of buttons</li> <li>or both</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Deck%20Event%20Processing/#representation","title":"Representation","text":"<pre><code>class Annunciator(DrawBase):\n    \"\"\"\n    All annunciators are based on this class.\n    See docs for subtypes and models. \n    \"\"\"\n    REPRESENTATION_NAME = \"annunciator\"\n    def __init__(self, config: dict, button: \"Button\"):\n        self.button = button\n</code></pre> <p>Similarly, when a Representation code is created, it must mention its identification keyword <code>REPRESENTATION_NAME</code> that will be searched in the button definition attribute.</p> <p>The <code>REQUIRED_DECK_FEEDBACKS</code> determine which of the deck's definition <code>feedback</code> type is requested to be able to use the Representation().</p> <p>In the above case, Annunciator is a DrawBase, which is a Icon, which is an IconBase, and the IconBase class has:</p> <pre><code>\tclass IconBase(Representation):\n    \"\"\"\n    All images are based on this class.\n    \"\"\"\n    REPRESENTATION_NAME = \"icon-base\"\n    REQUIRED_DECK_FEEDBACKS = \"image\"\n    def __init__(self, config: dict, button: \"Button\"):\n        self.button = button\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Deck%20Event%20Processing/#button-definition","title":"Button Definition","text":"<p>The <code>ACTIVATION_NAME</code> is the string that the button definition must use to trigger that activation (<code>type</code> attribute):</p> <pre><code>  - index: 1\n    name: MASTER CAUTION\n    type: push\n    command: sim/annunciator/clear_master_caution\n    annunciator:\n      text: \"MASTER\\nCAUT\"\n      text-color: darkorange\n      text-font: DIN Condensed Black.otf\n      text-size: 72\n      dataref: AirbusFBW/MasterCaut\n    vibrate: RUMBLE5\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/","title":"Deck Internals","text":"<p>Deck Internals explains how Cockpitdecks discovers about miscellaneous deck hardware capabilities and how user interactions on a physical deck device enter Cockpitdecks.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#how-deck-user-interactions-enter-cockpitdecks","title":"How Deck User Interactions Enter Cockpitdecks","text":"<p>When a user want to use a deck with Cockpitdecks, it is necessary to have a python package available to interact with it. This python package is not provided by Cockpitdecks but by other developers who bridged the physical deck hardware with the python language.</p> <p>By design and co\u00efncidence, all three deck brands currently used by Cockpitdecks (Elgato, Loupedeck, and Berhinger) proceed with a similar mechanism: The python package that interfaces the physical deck to the python language request to supply a callback function. That function is called each time an interaction occurs on the physical deck device.</p> <p>When Cockpitdecks is started, its scans for available devices, checks whether the interfacing software package is available, and if it is, installs its callback function into the python package for that deck.</p> <p>From that moment on, each time something occurs on the physical deck device, Cockpitdecks' callback function gets called. In that callback function, Cockpitdecks tries to spend a minimum time. From the data it receives from the interfacing python package, it creates an Event with all necessary data and enqueues it in Cockpitdecks for later processing. The Event the callback function creates is aptly called a Deck Event.</p> <p>The Deck Event contains information about the deck, of course, but also the precise button, knob, encoder, slider, screen\u2026 that was manipulated and the type of interaction that occurred (pushed, turned, swiped\u2026) All that information is in the Deck Event and is sent to Cockpitdecks.</p> <p>That's how physical deck interaction enters Cockpitdecks.</p> <p>Cockpitdecks processes events that enter its queue. Cockpitdecks instruct the event to run. That's how and when actions are actually performed, like sending a command to the simulator or changing the value of a dataref.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#deck-type","title":"Deck Type","text":"<p>Cockpitdecks discovers about deck capabilities through a Deck Type structure.</p> <p>A deck is presented to Cockpitdecks through a deck definition file called a Deck Type. The deck definition file describes the deck capabilities:</p> <ul> <li>How many buttons and how they can be manipulated,</li> <li>How many dials, if they can be turned, or pushed</li> <li>Feedback LCD screens for icons</li> <li>Feedback LED, optionally colored</li> <li>Ability to emit vibration or sound</li> <li>etc.</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#deck-definition","title":"Deck Definition","text":"<p>Here is for example, a deck configuration file for a Loupedeck LoupedeckLive device.</p> <pre><code># This is the description of a deck's capabilities for a Loupedeck LoupedeckLive device\n#\n---\nname: LoupedeckLive\ndriver: loupedeck\nbuttons:\n  - name: 0\n    action: push\n    feedback: image\n    image: [90, 90, 0, 0]\n    repeat: 12\n  - name: left\n    action: swipe\n    feedback: image\n    image: [60, 270, 0, 0]\n  - name: right\n    action: swipe\n    feedback: image\n    image: [60, 270, 420, 0]\n  - name: 0\n    prefix: e\n    action: [encoder, push]\n    feedback: none\n    repeat: 6\n  - name: 0\n    prefix: b\n    action: push\n    feedback: colored-led\n    repeat: 8\n  - name: buzzer\n    action: none\n    feedback: vibrate\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#attributes","title":"Attributes","text":"Attribute Definition name Name used inside Cockpitdecks to identifying the deck model. driver Keyword identifying the deck software driver class. (See main drivers class above.) background The <code>background</code> attribute is an optional attribute only used by web decks. It specifies a background color and/or image to use for web deck representation. See explanation and exemple below. buttons The <code>Buttons</code> contains a list of Deck Button Type Block descriptions.This attribute is named Buttons, with Button having the same meaning as in Cockpitdecks. A Deck Type Button is a generic term for all possible means of interaction on the deck:1. Keys to press,2. Encoders to turn,3. Touchscreens to tap or swipe4. Cursors to slideA list of button types, each ButtonType leading to one or more individual buttons identified by their index, built from the <code>prefix</code>, <code>repeat</code>, and <code>name</code> attribute. See below."},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#deck-type-button-block","title":"Deck Type Button Block","text":"<p>A Deck Type Button Block defines either a single button, or a group of identical buttons. For example, if a deck has a special, unique, \u00abEscape\u00bb button, it can be defined alone in a Deck Type Button Block. Similarly, if a deck consist of a grid of regularly spaced 6 by 4 keys that are all the same, they can also be defined in a single Deck Type Button Block.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#attributes_1","title":"Attributes","text":"Attribute Defintion name Name of the button type.The name of the button type is- either the final name of the button, like <code>touchscreen</code>, when there is a single button with that name on the deck,- or an integer value that will be used to build the button names, in the case the block defines a sets of identical buttons. actions Interaction with the button. Interaction can be:- <code>none</code>: There is no interaction with the button. It is only used for display purpose. (<code>none</code> interaction can be omitted.)- <code>press</code>: Simple press button that only reports when it is pressed (one event)- <code>push</code>: Press button that reports 2 events, when it is pushed, and when it is released. This allow for \"long press\" events.- <code>swipe</code>: A surface swipe event, with a starting touch and a raise events.- <code>encoder</code>: A rotating encoder, that can turn both clockwise and counter-clockwise- <code>cursor</code>: A linear cursor (straight or circular) delivering values in a finite range.Action can ba a single interaction or an array of interactions like <code>[encoder, push]</code> if a button combines both ways of interacting with it. feedbacks Feedback ability of the button. Feedback can be:- <code>none</code>: No feedback on device, or direct feedback provided by some marks on the deck device. (<code>none</code> feedback can be omitted.)- <code>image</code>: Small LCD iconic image.- <code>led</code>: Simple On/Off LED light.- <code>colored-led</code>: A single LED that can be colored.- <code>multi-leds</code>: Several, single color, LED on a ramp.- <code>encoder-leds</code>: Special encoder led ramp for X-Touch Mini (4 modes)- <code>vibrate</code>: emit a buzzer sound. repeat In case of a set if identical buttons, <code>repeat</code> if the number of time the same button is replicated along width (x) and height (y) axis.If only one value is supplied, it is supposed to be <code>[value, 1]</code> array. For vertical layout, specify <code>[1, value]</code> instead."},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#examples-of-button-names","title":"Examples of button names","text":"<p>In the case of a single button, the name of the button will be <code>touchscreen</code> and that name needs to be unique for the deck type.</p> <pre><code>name: touchscreen\n</code></pre> <p>In the case of a set of identical buttons, the name of the button will be built from other attributes:</p> <pre><code>name: 5\nprefix: k\nrepeat: [4, 3]\n</code></pre> <p>Names of buttons will be: <code>k5</code>, <code>k6</code>, <code>k7</code>, \u2026 <code>k16</code>.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#feedback-trick","title":"Feedback Trick","text":"<p>Trick</p> <p>If a deck has a vibrate capability, it is advisable to declare it as a separate button of interaction, and use that button like any other. Vibrate is a feedback mechanism.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#deck-type-button-block-additional-attributes-for-web-decks","title":"Deck Type Button Block: Additional Attributes for Web Decks","text":"<p>The above Deck Type Button Block attributes are necessary for all decks, both physical and web decks. Web Decks also contain an additional series of attributes that drive the drawing of the deck in a web navigator window.</p> <p>Web Deck Drawings</p> <p>For simplicity, Web Deck Drivers are drawn on an HTML Canvas, which is a pixel-driven drawing space. Web Decks are drawn with images and drawing instructions that use the pixel as a unit for display.</p> <p>Web decks can have the following types of interactive buttons:</p> <ol> <li>Keys (simple press, long press, etc.)</li> <li>Encoders (turned clockwise, counter clockwise)</li> <li>Touchscreen (pressed, swiped)</li> <li>Slider (slid between 2 range values)</li> </ol> <p>When rendered in a browser window, web deck interaction means are materialised through a changing pointer cursor (arrow, curved arrow (encode), single dot (push), double dot (pull), etc.)</p> <p>Background Deck Type Attribute</p> <p>Please read above in this page the <code>background</code> Deck Type attribute used to specify a background image to use for web deck display.</p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#attributes_2","title":"Attributes","text":"Attribute Definition dimension The dimension attribute can be a single integer value or a list of two values.It determine the size of the button has drawn on the Web deck.If the feedback visualisation is an <code>image</code>, the <code>image</code> attribute specifies the characteristics of the image. <code>X</code>is horizontal and correspond to the <code>width</code>, <code>Y</code> is vertical and correspond to the <code>height</code>. layout Layout of the buttons on the web deck canvas.- Offset- SpacingButtons will be arranged at regular interval, starting from Offset, with supplied spacing between the buttons. Button sizes are specified in the Dimension attribute. hardware Configuration information for a specific drawing representation of this hardware button. empty-button Minimal Button definition to create an empty, dummy button. This dummy button will becreated and used to generate an \"empty\" hardware representation (completely <code>off</code>). (In other words, if a button with hardware representation is not defined, this definition will be used to create a button.) See below. options Comma-separated list of options, a single option can either be a name=value, or just a name, in which case the value is assumed to be True.<code>options: count=8,active</code>sets options <code>count</code>to value 8, and <code>active</code> to True. <code>active</code> is equivalent to <code>active=true</code>."},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#deck-type-background","title":"Deck  Type <code>background</code>","text":"<p>In addition to the above button definitions, a deck type may contain a <code>background</code> attribute. This attribute is only used by web decks. The background attribute defines the background of the web page where the web deck will be rendered. The background can either be</p> <ol> <li>A PNG image,</li> <li>A solid color and size information. In the case of a PNG image, the size is deduced from the size of the image.</li> </ol>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#attributes_3","title":"Attributes","text":"Attribute Definition <code>image</code> Name of a PNG image, with extension. No default. <code>color</code> Color of the background of the web page. No default. <code>size</code> Array of two values with width and height of the web canvas. Defaults to (200, 100) pixels. <code>overlay</code> Static text or image overlay. Not implemented yet."},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#special-button--hardware--representation","title":"Special Button \u00ab Hardware \u00bb Representation","text":"<p>Some deck buttons need a special representation or drawing to visually reproduce the physical deck equivalent button. Examples of such special representations are</p> <ul> <li>LoupedeckLive \u00ab\u00a0colored\u00a0\u00bb numbered buttons,</li> <li>X-Touch Mini LEDs around the encoders.</li> </ul> <p>These highly specific \u00ab\u00a0drawings\u00a0\u00bb are performed on side representations called Hardware Representations.</p> <p>Technically speaking, they behave very much like LCD representations:</p> <ul> <li>Some screen space is reserved on the canvas to host the representation,</li> <li>The hardware representation driver produces an image that mimics the hardware button on the send,</li> <li>Cockpitdecks \u00ab\u00a0sends\u00a0\u00bb the hardware representation image to the web deck for display in the reserved space,</li> <li>Like any other representation, the hardware representation gets updated each time the underlying values gets updated. Hardware representation only exists for web decks to draw a very specific button.</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#empty-button-definition","title":"Empty Button Definition","text":"<p>Hardware Representations need to know how to represent themselves in case they are not used or defined on a page. To present nicely, Cockpitdecks needs to know how to draw an \"undefined\", unused Hardware Representation. To do this, Cockpitdecks uses a trick: It dynamically create an dummy placeholder button from the Empty Button Definition for its Hardware Representation. Basically, only two attributes need to be defined: A type (often set to none) and an attribute that tells its Hardware Representation. Optionally, a default, initial value can be supplied. Sometimes, some mandatory or optional Hardware Representation attributes need to be supplied as well. Here is an exemple of a simple LED representation.</p> <pre><code>hardware:\n\ttype: virtual-xtm-led\n\tempty-button:\n\t\ttype: none\n\t\tled: single\n\t\tinitial-value: 1\n</code></pre> <p></p>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#examples-of-deck-type-button-definition-block","title":"Examples of Deck Type Button Definition Block","text":""},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#single-button-definition","title":"Single Button Definition","text":"<pre><code>name: Virtual Deck\ndriver: virtualdeck\nbuttons:\n  - name: left\n    action: [push, swipe]\n    feedback: image\n    dimension: [52, 270]\n    layout:\n      offset: [96, 78]\n    options: corner_radius=4\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#multiple-button-definition","title":"Multiple Button Definition","text":"<pre><code>name: Virtual Deck\ndriver: virtualdeck\nbuttons:\n  - name: 0\n    prefix: e\n    repeat: [1, 3]\n    action: [encoder, push]\n    dimension: 27\n    layout:\n      offset: [45, 115]\n      spacing: [0, 41]\n  - name: 3\n    prefix: e\n    repeat: [1, 3]\n    action: [encoder, push]\n    dimension: 27\n    layout:\n      offset: [624, 115]\n      spacing: [0, 41]\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#installed-deck-types","title":"Installed Deck Types","text":"<p>On startup, Cockpitdecks reports which deck types are available:</p> <pre><code>Cockpitdecks 12.7.2.20241209 \u00a9 2022-2024 Pierre M &lt;pierre@devleaks.be&gt;\nElgato Stream Decks, Loupedeck decks, Berhinger X-Touch Mini, and web decks to X-Plane 12.1+\n\nINFO MainThread start.py:&lt;module&gt;:315: Initializing Cockpitdecks..\nINFO MainThread cockpit.py:add_extensions:610: loaded extensions cockpitdecks_xp, cockpitdecks_wm, cockpitdecks_ld, cockpitdecks_ext, s_sd, cockpitdecks_bx\nINFO MainThread cockpit.py:init:466: available simulators: X-Plane\nINFO MainThread cockpit.py:init:469: available deck drivers: virtualdeck, loupedeck, xtouchmini, streamdeck\nWARNING MainThread xplane.py:add_datarefs_to_monitor:1189: no connection\nINFO MainThread xplane.py:add_cockpit_datarefs:819: monitoring 1 cockpit datarefs\nWARNING MainThread xplane.py:add_datarefs_to_monitor:1189: no connection\nINFO MainThread xplane.py:add_simulator_datarefs:832: monitoring 7 simulator datarefs\nINFO MainThread cockpit.py:init_simulator:497: simulator driver XPlane 1.4.0 installed\nINFO MainThread cockpit.py:init_simulator:501: COCKPITDECKS_PATH=/Users/xplane/X-Plane 12/Aircraft/Laminar Research:/Users/xplane/X-Plane 12xtra Aircraft\nINFO MainThread cockpit.py:load_cd_fonts:1494: 18 fonts loaded, default font=D-DIN.otf, default label font=D-DIN.otf\nINFO MainThread cockpit.py:load_cd_icons:1369: 18 icons loaded from cache\nINFO MainThread cockpit.py:load_cd_sounds:1543: 8 sounds loaded\nDEBUG MainThread observable.py:init:130: observable Aircraft loaded: listening to {'sim/aircraft/view/acf_livery_path'}\nINFO MainThread cockpit.py:load_cd_observables:1284: loaded 1 observables\nINFO MainThread cockpit.py:load_deck_types:1336: loaded 19 deck types (Virtual Deck for Development, LoupedeckLive, virtual loupedeck.ct, pedeck.live.s, Virtual LoupedeckLive with Mosaic, Virtual LoupedeckLive, Stream Deck Original, Stream Deck Mini, Stream Deck Neo, Stream eam Deck XL, Streamdeck, Virtual Streamdeck Mini, Virtual Streamdeck MK.2, Virtual Stream Deck Neo, Virtual Streamdeck +, Virtual XL, X-Touch Mini, Virtual X-Touch Mini), 11 are virtual deck types\nINFO MainThread cockpit.py:scan_devices:800: device drivers installed for virtualdeck (included), loupedeck 1.4.5, xtouchmini 1.3.6, 0.9.6; scanning for decks and initializing them (this may take a few seconds)..\nINFO MainThread cockpit.py:scan_devices:825: found 1 loupedeck\nINFO MainThread cockpit.py:scan_devices:825: found 1 xtouchmini\nINFO MainThread cockpit.py:scan_devices:825: found 3 streamdeck\nINFO MainThread start.py:&lt;module&gt;:317: ..initialized\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Deck%20Internals/#deck-driver","title":"Deck Driver","text":"<p>A particular deck will come with software that interfaces it with the python language. That piece of software is a deck device driver. It is necessary to</p> <ol> <li>Collect interactions from the device (which button has been pressed, how long?, which encoder has been turned, how fast?)</li> <li>Send feedback visualisation instruction to the device to reflect the state change, instruct to draw an image, emit a sound, etc. Device drivers are very specific and particular software. To further isolate their specificities, Cockpitdecks uses a Deck Driver interface, a bridge between Cockpitdecks and the device driver that controls the deck.</li> </ol> <p>Currently, this require the coding of a single python class derived from the <code>cockpitdecks.deck</code> class, with the following functions:</p> <p>General:</p> <ul> <li>make_default_page</li> <li>render</li> </ul> <p>Interaction control:</p> <ul> <li>key_change_callback</li> </ul> <p>In some drivers, there sometimes is a callback function per interaction type:</p> <ul> <li>key_change_call_back,</li> <li>dial_change_callback</li> <li>touch_callback\u2026</li> </ul> <p>Feedback:</p> <p>If the deck has image capabilities:</p> <p>See list below.</p> <p>If the deck has sound and/or vibrating capabilities:</p> <ul> <li>vibrate</li> </ul> <p>If the deck has lit button with color capabilities:</p> <ul> <li>set_button_color</li> </ul> <p>If the deck has lit button without color capabilities:</p> <ul> <li>set_button_led</li> </ul> <p>If the deck has lit button with several led capabilities (led ramps, etc.):</p> <ul> <li>set_button_encoder_led</li> </ul> <p>The following functions are also necessary and can be overwritten if necessary.</p> <pre><code>    def __init__(self, name: str, config: dict, cockpit: \"Cockpit\", device=None)\n    def set_deck_type(self)\n\n\tdef init(self)\n    def get_id(self) -&gt; str:\n\n\tdef is_virtual_deck(self) -&gt; bool:\n    def get_deck_button_definition(self, idx)\n    def get_deck_type(self) -&gt; DeckType:\n    def get_attribute(self, attribute: str, silence: bool = False)\n    def load(self)\n\n\tdef change_page(self, page: str | None = None)\n    def reload_page(self)\n    def set_home_page(self)\n    def load_home_page(self)\n    def make_default_page(self, b: str | None = None)\n\n\tdef get_button_value(self, name)\n\n\tdef get_index_prefix(self, index)\n    def get_index_numeric(self, index)\n    def valid_indices(self, with_icon: bool = False)\n    def valid_activations(self, index=None)\n    def valid_representations(self, index=None)\n\n\tdef inspect(self, what: str | None = None)\n    def print_page(self, page: Page)\n\n    def vibrate(self, button)\n    def set_brightness(self, brightness: int)\n\n\tdef render(self, button: Button)\n\tdef fill_empty(self, key)\n    def clean_empty(self, key)\n\n\tdef start(self)\n    def terminate(self)\n</code></pre> <p>For deck with iconic display capabilities:</p> <pre><code>    def get_image_size(self, index)\n    def create_empty_icon_for_key(self, index)\n    def get_icon_background(\n        self,\n        name: str,\n        width: int,\n        height: int,\n        texture_in,\n        color_in,\n        use_texture=True,\n        who: str = \"Deck\",\n    ):\n    def create_icon_for_key(self, index, colors, texture)\n    def scale_icon_for_key(self, index, image, name: str | None = None)\n    def fill_empty(self, key)\n    def clean_empty(self, key)\n    def set_key_icon(self, key, image)\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Design%20Helper/","title":"Design Helper","text":"<p>Cockpitdecks comes with two designer tools.</p> <ol> <li>A Web Deck Designer</li> <li>A Button Designer</li> </ol>"},{"location":"Reference/Extending/Development/Internals/Design%20Helper/#web-deck-designer","title":"Web Deck Designer","text":"<p>The Deck Designer is a tool that help positioning, sizing, and naming elements on a web deck background image.</p> <p></p> <p>On the above designer, rectangular or circular buttons, encoder, or hardware image place holders can be positioned and sized.</p> <p>A layout can be saved and loaded later. When saving, two files are created, one for the graphical representation with the design, and one Yaml file in Deck Type format. The latter can be used as a skeleton to define a new virtual web deck.</p> <p>Layout and layout.</p> <p>In a very unfortunate choice of vocabulary, the word layout is used to designed two different things in Cockpitdecks.</p> <ol> <li>Common layouts are sets of pages. A deck must reference a layout, that is a deck must reference a set of pages it will load and propose to the user. A common layout is just a folder that contains pages to be loaded on a deck.</li> <li>Web Deck layout are arrangement of buttons, encoders, and hardware images on the web page of a web deck. They are quickly created, saved, and edited with the Deck Designer tool. Look at the above image, Deck Designer allows the user to add, remove, resize different elements to interact with over the background image. This arrangement of elements is also awkwardly called a layout. Sorry. Fortunately, the second meaning of layout is less frequent, and only used by Web Deck designers.</li> </ol> <p>The web deck can then be used with the same background image, and each button, encoder, or hardware image will be laid over the background at the very precise defined position and size.</p> <p>Of course, manual tweaking of position and sizes is sometimes necessary, but the gross work of estimation is completed in fun time. For instance image size may need to be evenly rounded to the same value for all buttons for aesthetic layouts.</p>"},{"location":"Reference/Extending/Development/Internals/Design%20Helper/#development-example","title":"Development Example","text":"<p>See the A321 Overhead Panel example. Deck Designer is used to define the very precise position of each annunciator or switch.</p>"},{"location":"Reference/Extending/Development/Internals/Design%20Helper/#button-designer","title":"Button Designer","text":"<p>The Button Designer is a simple tools that help test and preview button design.</p> <p>A button can be defined, either through a form by filling a few intuitive fields, or by typing Yaml code directly in the code window. The design tool also can generate Yaml code from the form parameters values.</p> <p>Form is not completed from code area</p> <p>The opposite is not true, when entering or adjusting code in the coding window, form elements are not updated.</p> <p></p> <p>By pressing the render button, Cockpitdecks will generate a button image and make it available for display in the Button Designer preview window. If the simulator is running, the button will show the simulated values like they would appear on the real deck.</p> <p>When \"Saving\u2026\" the button, it is added to a file in the</p> <pre><code>&lt; current-aircraft | deck-name &gt;/deckconfig/&lt;layout-name&gt;/&lt;page-name&gt;.yaml\n</code></pre> <p>file at the index position mentioned in the first part of the form. (If no layout or page name is supplied int he form, acceptable default values are provided.)</p> <p>So is it possible to design buttons one by one and add them after verification to the page file.</p> <p>Once the page is complete, it can be copied over to the <code>deckconfig</code> folder of the aircraft.</p>"},{"location":"Reference/Extending/Development/Internals/Design%20Helper/#notes","title":"Notes","text":"<p>Selecting a new deck name or a new button index resets the forms.</p> <p>To generate code, the code window must be empty. Pressing render while the code window is not empty has no effect.</p> <p>Representations are added one at a time, some are not currently working.</p> <p>What is working well, it the testing area: You can paste your button definition yaml code in the code text area and press render to get a preview of your button, data included if connected to a simulator.</p>"},{"location":"Reference/Extending/Development/Internals/Design%20Helper/#see-also","title":"See Also","text":"<p>Workflow for Web Deck Design</p>"},{"location":"Reference/Extending/Development/Internals/Environment/","title":"Environment","text":"<p>Cockpitdecks discover about its computer host and its extensions through a global configuration file called its environment.</p> <p>The environment consists of a few attributes that tells Cockpitdecks about things it cannot discover on its own.</p> <ol> <li>Simulator type and location</li> <li>Network communication hosts and ports</li> <li>Extensions to Cockpitdecks</li> </ol> <p>Most of the above information can be communicated to Cockpitdecks either through operating system environment variables or in the global configuration file.</p> <p>Recall that Cockpitdecks can run either on the same host as the simulation software, or on a separate host connected through the local area network to the host running the simulator.</p>"},{"location":"Reference/Extending/Development/Internals/Environment/#simulator-type-and-location","title":"Simulator Type and Location","text":"<p>If the simulation software is located on the same host, the <code>XP_HOME</code> environment variable is the operating system folder path to the home directory of the software.</p> <p>If the simulation solftware runs on another computer, XP_HOME does not need to be set or must be set to None.</p>"},{"location":"Reference/Extending/Development/Internals/Environment/#network-communication","title":"Network Communication","text":""},{"location":"Reference/Extending/Development/Internals/Environment/#cockpitdecks-extensions","title":"Cockpitdecks Extensions","text":""},{"location":"Reference/Extending/Development/Internals/Event%20Handling/","title":"Deck Events","text":"<p>It is the deck driver\u2019s responsibility to create a Deck Event based on the input of the user. Deck Events have a type: Press, long press, encoder turn, slide\u2026</p> <p>Deck Events are then enqueued for processing by the Cockpit.</p> <p>The Cockpit dequeues the event, and from information about the deck and the button that was activated, forward the event for activation.</p>"},{"location":"Reference/Extending/Development/Internals/Event%20Handling/#activation","title":"Activation","text":"<p>The activation receives the event, and from its type (press, long press, encoder turned clockwise\u2026) determine which instruction need execution. The activation then execute the Instruction (<code>Instruction.execute()</code>.)</p> <p>The activation then determine its activation value and stores it.</p> <p>When the activation is completed, if the button relies on its activation value, its value is re-computed. If its value changes, the button asks to be rendered again.</p>"},{"location":"Reference/Extending/Development/Internals/Event%20Handling/#rendering","title":"Rendering","text":"<p>Rendering first check whether the button value has changed. If it has not changed, it most of the time renders a cached copy of its representation to prevent recreating the representation. Otherwise, it creates the representation using the new button value(s) and caches it.</p> <p>Rendering always perform some tasks, at most send a cached copy of the representation to the deck. A rendering can be requested by a deck that asks to refresh its page, without modifying any underlying button value.</p>"},{"location":"Reference/Extending/Development/Internals/Event%20Handling/#simulator-events","title":"Simulator Events","text":"<p>There are two types of simulator events:</p> <ul> <li>A value has changed,</li> <li>Something happened (occurrence of an event, like execution of a command).</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Event%20Handling/#value-change","title":"Value Change","text":"<p>When a simulator value has changed, Cockpitdecks stores the new value and warns each value listener. How value listeners handle the change is dependent on the listener. Often, the listener is the button. In this case, the button re-computes its value and update its rendering accordingly.</p>"},{"location":"Reference/Extending/Development/Internals/Event%20Handling/#simulator-event","title":"Simulator Event","text":"<p>When an event of interest occurs inside the simulator, the instruction(s) associated to that event are executed.</p>"},{"location":"Reference/Extending/Development/Internals/Events/","title":"Events","text":"<p>Events are entities created to report activity to Cockpitdecks.</p> <p>Events have a type that identifies the interaction.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#event","title":"Event","text":"<p>Base class for events.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#attributes","title":"Attributes","text":"Attribute Definition action Deck action name timestamp Time of creation of event is_processed Whether event has run or not."},{"location":"Reference/Extending/Development/Internals/Events/#common-functions","title":"Common Functions","text":"Function Description run(just_do_it: bool = False) Run the event.If just_do_it is False, enqueue the Event.Otherwise, execute the activation. handling() Mark the start of processing. handled() Mark the end of processing."},{"location":"Reference/Extending/Development/Internals/Events/#see-also","title":"See Also","text":"<ul> <li>#Deck Event</li> <li>#SimulatorEvent</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Events/#deck-event","title":"Deck Event","text":"<p>Events are entities created by decks to report which interaction occurred on the physical device.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#attributes_1","title":"Attributes","text":"Attribute Definition deck Related Reference/Deck where interaction occured. button Related button index button that produced the event"},{"location":"Reference/Extending/Development/Internals/Events/#pushevent","title":"PushEvent","text":""},{"location":"Reference/Extending/Development/Internals/Events/#parameters","title":"Parameters","text":"Attribute Description pressed <code>True</code> or <code>False</code>, if key is pressed (<code>True</code>) or released (<code>False</code>) pulled True if push/pull option is enabled and button was pulled rather than pushed. <p>PushEvents are in fact raised twice for an interaction. First when the button is pressed, and second when the button it released. It is a main differentiator of Press and LongPress Events.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#pressevent","title":"PressEvent","text":"<p>A Press event is a single event sent when a button is pressed. No event is sent when the button is released. It is therefore impossible to know how long the button was pressed.</p> <p>In the case of PressEvent, we only know that the button was pressed for a short time, without being able to set or determine how long it was pressed.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#longpressevent","title":"LongPressEvent","text":"<p>A LongPress event is a single event sent when a button is pressed for a long time, but the time it remained pressed is not defined or settable. No event is sent when the button is released. It is therefore impossible to know how long the button was pressed.</p> <p>In the case of LongPressEvent, we only know that the button was pressed for a long time, without being able to set or determine how long it was pressed.</p> <p>The long time event occurs experimentally after roughly 600 milliseconds. It is therefore safe to assume that for a LongPress event, the button remained pressed for at least 1 second.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#encodeevent","title":"EncodeEvent","text":""},{"location":"Reference/Extending/Development/Internals/Events/#parameters_1","title":"Parameters","text":"Attribute Description clockwise <code>True</code> or <code>False</code>, if encoder is turned clockwise (<code>True</code>) or counter-clockwise (<code>False</code>)"},{"location":"Reference/Extending/Development/Internals/Events/#slideevent","title":"SlideEvent","text":"Attribute Description value Raw value of the slider (as produced by the driver)"},{"location":"Reference/Extending/Development/Internals/Events/#touchevent","title":"TouchEvent","text":"Attribute Description x x-position of the event (horizontal) y y-position of the event (vertical) start Timestamp of touch event"},{"location":"Reference/Extending/Development/Internals/Events/#swipeevent","title":"SwipeEvent","text":"<p>A Swipe event is either an event on its own, or the combination of two Touch event.</p> <p>In the latter case, the first Touch event is the start of the swipe.</p> <p>The second one being the end of the swipe, and must be supplied the first event as an argument. In this case, the swipe() method will return a Swipe event that combine them both.</p> <p>Streamdeck Touch and Swipe Events</p> <p>Please note that some deck models do no report timing information. In this case, the timing information is either added by Cockpitdecks or not available at it. In particular, Streamdeck decks have a particular Swipe event that always last at most less that a second, without any timing information. Just a start position, and an end position taken at most one second after the start event.</p>"},{"location":"Reference/Extending/Development/Internals/Events/#simulatorevent","title":"SimulatorEvent","text":"<p>A Simulator Event is created when something occurred in the simulator.</p> <p>For X-Plane simulator, The following events are reported:</p> <ol> <li>The value of a monitored simulator variable changed. The event contains the new value.</li> <li>A command that is being monitored was activated in the simulator.</li> </ol>"},{"location":"Reference/Extending/Development/Internals/Events/#datarefevent","title":"DatarefEvent","text":"<p>Dataref path</p> <p>Dataref new value</p>"},{"location":"Reference/Extending/Development/Internals/Events/#commandactiveevent","title":"CommandActiveEvent","text":"<p>Command path</p> <p>Active on or off</p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/","title":"Start-Up and Initialisation","text":"<p>On startup, Cockpitdecks does its best at discovering what features are available to it.</p> <p>What are the currently connected USB devices? Are there decks Cockpitdecks knows connected to the computer?</p> <p>Is there a local flight simulator software? Which one? Where is it located? If a known simulator software is installed, does it have the necessary feature?</p> <p>Did we supply information for a remote installation?</p> <p>If Cockpitdecks X-Plane extension is installed, Cockpitdecks also listen to potential X-Plane beacons that would betray one or more running instances of X-Plane.</p> <p>Cockpitdecks then loads its internal configuration including core fonts, images, observables, etc.</p> <p>It then scans USB ports for available known physical decks.</p> <pre><code>start.py:&lt;module&gt;:505: Initializing Cockpitdecks..\ncockpit.py:add_extensions:627: loaded extensions cockpitdecks_ld, cockpitdecks_xp, cockpitdecks_bx, cockpitdecks_sd, cockpitdecks_tl, cockpitdecks_wm, cockpitdecks_ext\ncockpit.py:init:647: available simulators: NoSimulator, X-Plane\ncockpit.py:init:650: available deck drivers: xtouchmini, loupedeck, streamdeck, virtualdeck\ncockpit.py:init_simulator:688: simulator driver XPlane 2.8.0 installed\ncockpit.py:init_simulator:690: COCKPITDECKS_PATH=/Users/xplane/X-Plane 12/Aircraft/Extra Aircraft:/Users/xplane/X-Plane 12/Aircraft/Laminar Research\ncockpit.py:load_cd_fonts:1270: 24 fonts loaded, default font=D-DIN.otf, default label font=D-DIN.otf\ncockpit.py:load_cd_icons:1212: 19 icons loaded from cache\ncockpit.py:load_cd_icons:1242: default icon name inop.png found\ncockpit.py:load_cd_sounds:1293: 9 sounds loaded\ncockpit.py:load_cd_observables:1196: loaded 3 observables\ncockpit.py:load_cd_deck_types:1186: loaded 8 deck types (LoupedeckLive, X-Touch Mini, Stream Deck Original, Stream Deck Mini, Stream Deck Neo, Stream Deck +, Stream Deck XL, Streamdeck)\ncockpit.py:load_cd_deck_types:1187: loaded 11 virtual deck types (Virtual Deck for Development, virtual loupedeck.ct, virtual loupedeck.live.s, Virtual LoupedeckLive with Mosaic, Virtual LoupedeckLive, Virtual X-Touch Mini, Virtual Streamdeck Mini, Virtual Streamdeck MK.2, Virtual Stream Deck Neo, Virtual Streamdeck +, Virtual Streamdeck XL)\ncockpit.py:load_cd_defaults:1385: added default system font Monaco.ttf\ncockpit.py:scan_devices:770: device drivers installed for xtouchmini 1.3.6, loupedeck 1.4.6, streamdeck 0.9.6\ncockpit.py:scan_devices:771: scanning for decks and initializing them (this may take a few seconds)..\ncockpit.py:scan_devices:787: requirements xtouchmini&gt;=1.3.6;loupedeck&gt;=1.4.5;streamdeck&gt;=0.9.5 satified\ncockpit.py:scan_devices:803: found 0 xtouchmini\ncockpit.py:scan_devices:803: found 1 loupedeck\ncockpit.py:scan_devices:803: found 0 streamdeck\nstart.py:&lt;module&gt;:507: ..initialized\n</code></pre> <p>After the initialization of the Cockpit, Cockpitdecks loads either an aircraft configuration, if supplied, or a demonstration web deck.</p> <p>After loading the aircraft, Cockpitdecks starts its internal monitoring processes, including the application server if requested to do so.</p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#loading-the-aircraft","title":"Loading the Aircraft","text":"<p>When loading the aircraft, Cockpitdecks first inspect what is available and loads aircraft specific resources like fonts, images, observables, and virtual decks if any.</p> <p>After, it loads and prepare each deck for this aircraft. Cockpitdecks initialise each deck by loading its Layout and all Pages it contains.</p> <p>For each Page, Cockpitdecks loads all buttons on that page and prepare them for use.</p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#loading-a-button","title":"Loading a Button","text":"<p>For each button on a Page, Cockpitdecks goes through the same steps.</p> <p>It first identifies what the button will do and check the button is capable of this action. This is done with the help of the definition of the button in the Deck Type (Button Type).</p> <p>Cockpitdecks prepare the button activation and the Instructions the button will require to execute when activated. The button is now ready to interpret the events it receives from that button on the deck when it is manipulated.</p> <p>Then Cockpitdecks identifies what the button will send as a feedback to the deck. It identifies the Representation of the button and check the button is capable of that representation.</p> <p>The Representation is governed by the value of the button. Cockpitdecks therefore identifies the Variables that are necessary to compute the value of the button. It creates and initialise each variable if necessary. If an initial value is supplied, it is set and the button is ready to be rendered on the deck.</p> <p>The button is now ready.</p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#page","title":"Page","text":"<p>The Page merely behaves as a collection of buttons. A Page is the entity that is requested to be displayed on a deck. So when a deck request a Page to be displayed, the Page collects all information from its buttons, and ask each button to render. Also, when a button is manipulated, it is the activation defined in the page for that button that is called.</p> <p>When a Page is loaded, among the thing it does is collection all variables from all individual buttons on that page. If some variable values are coming from the simulation software, the Page will request the simulation software to now monitor those variables and be notified when they change.</p> <p>When a Page is replaced by another one, it first ask the simulation software to stop monitoring  variables it was using, before the new Page ask the simulator to monitor its own set of variables.</p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#event-loop","title":"Event Loop","text":"<p>The Event Loop is the core loop of Cockpitdecks. It receives Deck Events from each individual deck, and Simulator Events from the simulation software. Each event is then executed in sequence. Deck events lead to execution of instructions. Simulator Events lead to updates of variables and buttons values, which in turn, often lead to rendering of updated representations on decks.`</p> <p></p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#decks","title":"Decks","text":"<p>Decks interface to Cockpitdecks through a driver software. The deck driver software has two responsibilities for Cockpitdecks.</p> <p>First it needs to collect the information it receives from its manipulations. Which button was pressed, when, etc. That information is provided to Cockpitdecks into a Deck Event. Cockpitdecks will then interpret the Event, pass it to its Activation which will interpret it and issue the necessary Instructions.</p> <p>Second, the deck driver has to translate the Representation requests into code that can be understood by the deck: Draw an icon on that key, make a sound, turn the LED on, etc.</p>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#simulator-software","title":"Simulator Software","text":"<p>The simulation software has several responsibilities.</p> <p>The first one is to communicate the overall status of the simulation software: Is it running, which version, which aircraft is currently loaded, what is the simulated date and time, is the simulation software running at normal speed?, where is currently located the aircraft.</p> <p>The second responsibility is to interface with Cockpitdecks, the simulator driver:</p> <ul> <li>Collect the used variable values from the simulation software and communicate them to Cockpitdecks,</li> <li>Execute the instructions issued by Cockpitdecks in the simulation software.</li> </ul>"},{"location":"Reference/Extending/Development/Internals/How%20Cockpitdecks%20Works/#variable-and-variable-listener","title":"Variable and Variable Listener","text":"<p>A Variable is a named entity that contains a value. However, it is a complex entity that performs internal tasks.</p> <p>One of its internal work is to detect when the value of a variable changes. In this case, the Variable can notify all entities interested in the new value. These entities are called Variable Listeners.</p> <p>This mechanism brings automatism inside Cockpitdecks. For example, a button can express its interest in being notified when a variable changes. The simulator software collects the value and pushes the values it receives in the variable. If the variable detects its value has changed, it notifies its listeners. When the listener receives the message that the value has changed it can act accordingly, adjusts its state and appearance. All this happens automatically after submitting the new value received from the simulation software.</p>"},{"location":"Reference/Extending/Development/Internals/Rendering%20Mechanism/","title":"Rendering Mechanism","text":"<p>Rendering occurs as follow.</p> <p>Request to render always starts from the Button. The Button solely calls the procedure render() on itself.</p> <p>To render a Page for example, the Page will call render() on each button in turn. It may then call a supplemental procedure to fill unused icons with images.</p> <p>The Button render() call is quickly transferred to the Deck for specific rendering handling. So the Button asks the Deck to render itself:</p> <pre><code>    # In the Button class\n\tdef render(self) -&gt; None:\n\t\tself.deck.render(self)\n</code></pre> <p>From the button index, the Deck will deduce rendering possibilities. It will then ask the button to supply the data for the rendering.</p> <pre><code>\t# In the Deck class\n\tdef render(self, button: Button) -&gt; None:\n\t\tbutton_representation = button.get_representation()\n\t\trender_data = button_representation.render()\n\t\t# transform render_data if necessary\n\t\t# send it to device driver for handling (display, sound, coloring...)\n\t\tself.device.handle_data(render_data)\n</code></pre> <p>In other words, the representation of the button is responsible to generate and provide whatever is necessary for the deck device driver.</p> <p>Let us take a very practical example.</p> <p>The deck device driver has a function to display an iconic image on a key. That function expects the index of the key to designate it unambiguously, and an image in JPG format with the proper size 90 \u00d7 90 pixels.</p> <p>If we use a generic representation that produces an image, the resulting image will be a 256 \u00d7 256 pixel transparent PNG image. We need to convert and resize that image before we can send it to the device driver.</p> <pre><code>\tdef render(self, button: Button) -&gt; None:\n\t\tbrep = button.get_representation()\n\t\trender_image = brep.render()\n\t\t# transform render_data if necessary\n\t\tkeyicon = render_image.resize([90, 90]).convert(\"RGB\")\n\t\t# send it to device driver for handling (display, sound, coloring...)\n\t\tself.device.set_key_image(key=button.index, image=keyicon)\n</code></pre> <p>This is a very simple example, but it shows the flow of information and the sequence of calls to get the work done.</p> <p>To emit a sound, the representation render() function would be responsible for generating, for example, a sound file in WAV format. The deck render function would then pass that sound to the device driver play_sound() function that expects a sound file to play.</p> <p>To color a LED, the representation render() function would be responsible for generating a color and a light intensity (in 0..1 value range). THe deck render function would then pass those data to the device driver turn_led_on(color, intensity) function to submit appropriate instruction to the device to turn the light on with the desired color and intensity.</p> <p>People familiar with internet web development knowledge can follow the process for (Virtual) Web Decks. The device driver of Web Deck (called VirtualDeck) is a relatively straightforward JSON message generator and ultimately sends the message to the browser for display. In the browser, JavaScript process decodes the message and interpret it to display an image, play a sound, or refresh an entire page. (Communication occurs in a WebSocket channel.)</p>"},{"location":"Reference/Extending/Development/Internals/Rendering%20Mechanism/#icon-size","title":"Icon Size","text":"<p>There is an ongoing enhancement request with icons.</p> <p>In early stage of development, icons were always square.</p> <p>Then came non-square icons for Loupedeck Live (left and right side icons).</p> <p>Then came touch screen surfaces for Elgato Stream Deck Plus and Loupedeck Live.</p> <p>Then and only then came Deck Type, where all icons are listed with their proper size.</p> <p>There might have been two years in the process.</p> <p>Ideally, icons should have arbitrary sizes, and Cockpidecks should cope with it. That's not really the case\u2026</p>"},{"location":"Reference/Extending/Development/Internals/Replay/","title":"Replay","text":"<p>Interactions with Cockpidecks enters the application through Events. Deck Events arrive from the user interaction with decks,  Simulator Events arrive because of Simulator data modification. Both then follow the same execution path, performing actions and adjusting deck feedback.</p> <p>In the process, these events can be captured and saved for a later, for a replay of the same events for example.</p> <p>That's the purpose of the Replay feature in Cockpitdecks.</p> <p>Each interaction that occurred during the session has been recorded and can be replayed. It can be submitted to Cockpitdecks in a similar way it was submitted when interactions with the deck occurred. Simulator interactions are recorded as well but never replayed, as we expect the Simulator to respond to user interaction in a similar fashion each time.</p> <p>Replay optionally respect the original timing.</p>"},{"location":"Reference/Extending/Development/Internals/Set%20Dataref/","title":"Set Dataref","text":"<p>The following document explains the special <code>set-dataref</code> attribute that can be used in numerous button definition.</p> <p><code>Set-dataref</code> is an instruction that tells Cockpitdecks to set the value of the data pointed by the <code>set-dataref</code> attribute value to the value of the button.</p> <p></p>"},{"location":"Reference/Extending/Development/Internals/Set%20Dataref/#theory-of-operations","title":"Theory of Operations","text":"<p>The <code>set-dataref</code> attribute points at a writable dataref. After each activation of a button, the value of the button is computed and written to that dataref.</p>"},{"location":"Reference/Extending/Development/Internals/Set%20Dataref/#button-value","title":"Button Value","text":"<p>When a button uses or produces a single value, that value gets written to the <code>set-dataref</code>.</p> <p>When a button produces more than one value (for Annunciators, buttons without representation, etc.), the set-dataref needs additional information to know which value to write. In the latter case, a <code>formula</code> is mandatory to select the appropriate value to send to X-Plane.</p>"},{"location":"Reference/Extending/Development/Internals/Set%20Dataref/#self-modifying-button","title":"Self-Modifying Button","text":"<p>In some case, the button is using the same dataref for representation and set-dataref.</p> <p>Here is the simplest example of this case:</p> <pre><code>- index: 0\n  type: push\n  text:\n    text: ${formula}\n  formula: ${data:activation_count}\n  set-dataref: data:internal_counter\n</code></pre> <p>The indent of the above button is to display a counter of how many times the button was pressed. In this example, it appears clearly that the order of operation must be:</p> <ol> <li>The button is pressed, the activation is triggered.</li> <li>The activation executes the push instruction AND INCREMENT the activation counter.</li> <li>It is only after the counter that has been incremented that the formula is evaluated and the new value of the button is computed</li> <li>The new value of the button just computed is optionally saved in the dataref pointed by <code>set-dataref</code>.</li> </ol> <p>So, in case the value of button is computed from one or more values that are very precisely modified by the activation of the button, the modification of the values is registered first, and the final value of the button computed afterwards, just before it is optionally written to the dataref pointed by the <code>set-dataref</code> attribute.</p>"},{"location":"Reference/Extending/Development/Internals/Text%20Strings/","title":"Text Strings","text":"<p>Text string is a frequent representation mean for buttons. Each button can have a label displayed and other textual information like</p> <ul> <li>Static text,</li> <li>Dynamic text with values,</li> <li>Annunciator \u00abparts\u00bb with text optionally framed in a box.</li> </ul> <p>These frequent displayed elements have been isolated in a common structure for display. The structure simply consists of a convention of text elements that are used together and combined to show the final text.</p> <p>Example 1: Labels</p> <pre><code>    label: RELOAD\n    label-size: 12\n    label-position: cm\n</code></pre> <p>Example 2: Static text display</p> <pre><code>    text:\n      text: ${fa:rotate-right}\n      text-font: fontawesome.otf\n      text-size: 80\n      text-position: cm\n      text-color: lime\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Text%20Strings/#text-block-structure","title":"Text \u00abBlock\u00bb Structure","text":"<p>A text structure consists of a keyword and then the following attributes attached to it:</p> <pre><code>    &lt;keyword&gt;:\n      &lt;keyword&gt;: ${fa:rotate-right}\n      &lt;keyword&gt;-font: fontawesome.otf\n      &lt;keyword&gt;-size: 80\n      &lt;keyword&gt;-position: cm\n      &lt;keyword&gt;-color: lime\n</code></pre> <p>In some circumstances, additional attributes are possible, depending on the specificity of the representation.</p>"},{"location":"Reference/Extending/Development/Internals/Text%20Strings/#text","title":"Text","text":"<p>The text displayed is read in the attribute <code>&lt;keyword&gt;</code>. For labels, (keyword=label), the text is static. (A Representation can change the text in the button attributes.)</p> <p>For other representations, it is possible to use a text expression that contains variables. The text expression is evaluated before display. In this case, the evaluation consists of variable value substitution.</p> <pre><code>    text:\n      text: ${AirbusFBW/BatVolts[0]}\n      text-font: Seven Segment.ttf\n      text-size: 24\n      text-color: white\n      text-format: '{:2.1f}'\n</code></pre> <p>In the above example, the value of the simulator variable <code>AirbusFBW/BatVolts[0]</code> is first converted to string using the <code>text-format</code> attribute and the subsitued in the value of the text attribute i.e.:</p> <pre><code>    text:\n\t  text: 26.8\n      text-font: Seven Segment.ttf\n      text-size: 24\n      text-color: white\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Text%20Strings/#formula","title":"Formula","text":"<p>If the component that has a text representation also has a formula, it is possible to substitude the result of the formula in the text expression:</p> <pre><code>\t- text: ${formula}\n\t  formula: ${sim/cockpit2/gauges/barometer_setting_in_hg_pilot} 2 roundn\n\t  text-format: \"{:4.2f}\"\n\t  text-size: 22\n\t  text-position: cm\n\t  text-color: lightyellow\n\t  text-font: Segment7Standard\n</code></pre> <p>The keyword <code>${formula}</code> is replaced with the value of the formula expression.</p>"},{"location":"Reference/Extending/Development/Internals/Value/","title":"Value","text":"<p>Cockpitdecks introduced the concept of a Value.</p> <p>A Value defines where it gets its value from, and make its value always available through the simple abstraction.</p> <p>Every entity that can have a value uses this abstraction.</p> <ul> <li>The value of a Button,</li> <li>The value of a chart or sparkline,</li> <li>The value of an Annunciator part.</li> </ul> <p>It is a dynamic entity. It does not store any value. It just know where to gets its value from and gets it.</p> <p>It is up to the entity that uses the value to keep a copy, see if it has changed, keep the last ten values\u2026 The Value abstraction only knows where and how to find its value when asked to provide it.</p> <p>A Value can report information about its behavior, like for instance the list of datarefs that are necessary to compute its final value.</p> <p>The Value entity performs necessary variable substitution, computations if there is a formula, and can also take care of writing the value to an X-Plane dataref.</p>"},{"location":"Reference/Extending/Development/Internals/Value/#value-attributes","title":"Value Attributes","text":"<p>Here is the list of attributes that are inspected by a Value to determine its value.</p> Attribute Definition <code>dataref</code> Single Dataref, monitored if coming from X-Plane <code>formula</code> Reverse Polish Notation expression with reference to Cockpitdecks variables such as datarefs, internal datarefs, and internal states. <code>set-dataref</code> Dataref where the value is written to <code>any-attribute</code> If an attribute is added, Cockpitdecks will look into this very particular attribute for variable substitution. See below."},{"location":"Reference/Extending/Development/Internals/Value/#additional-attribute","title":"Additional Attribute","text":"<p>Cockpitdecks will look into known additional attributes for variable substitution. Additionaly, a button designer can ask that its particular attribute be scanned as well.</p> <p>Here is a typical example of such variable scanning:</p> <pre><code>  - index: 5\n    name: SQUAWK00XX\n    type: none\n    formula: ${sim/cockpit/radios/transponder_code} 100 / floor\n    text:\n      text: ${formula}\n      text-format: \"{:02.0f}\"\n      text-font: 7-segment-display-extended.otf\n      text-size: 50\n      text-position: rm\n      text-color: khaki\n      text-bg-color: (40, 40, 40)\n</code></pre> <p>In the above example, attribute <code>text</code> will be scanned for more datarefs. The attribute that gets scanned always has the same name as the main attribute:</p> <pre><code>text:\n\ttext: \"text to be scanned for ${datarefs}\"\n</code></pre> <p>or</p> <pre><code>any-attribute:\n\tany-attribute: \"additional attribute to be scanned for ${datarefs}\"\n</code></pre> <p>A Value will always look into the following attributes:</p> <ul> <li>Text</li> <li>Formula</li> <li>Annunciator parts</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Variable%20and%20Value%20Changes/","title":"Variable and Value Changes","text":"<p>Cockpitdecks manipulates values that can come from different sources:</p> <ol> <li>Variable are simple scalar typed values (mainly string, float or integer). They can either come from the simulator software or Cockpitdecks internal values. They are scalar variables.</li> <li>Value are complex scalar typed values that combines on one or more Variable in a Formula expression which ultimately provide a single final value.</li> </ol> <p>Values are used by buttons and observables. Values are used when there is a need to combine and modify raw values as provided by the simulator or by Cockpitdecks into another meaningful value through simple mathematical operations or rounding.</p> <p>Variables and values have listeners. Listeners are other objects inside Cockpitdecks that are using the variable or value. When the variable or value changes, each listener is notified of the change and can act accordingly.</p> <p>For example, Values are notified when one of its underlying Variable has changed. This allows the Value to compute its new value. the Value in turn notifies the Button or the Observable that relies on it of its change. The Button or Observable can then adjust as needed.</p> <p>Changes of Data value enter Cockpitdecks through Data Events. The SimulatorDataEvent (or one of its sub-class) is used to report the change of a value in the simulator software. The CockpitDataEvent (or one of its sub-class) to report change of value in the Cockpit.</p>"},{"location":"Reference/Extending/Development/Internals/Variable%20and%20Value%20Changes/#formula","title":"Formula","text":"<p>A Formula is a Variable that consist of an expression using other Variables.</p> <pre><code>\tformula: ${sim/cockpit2/gauges/actuators/barometer_setting_in_hg_pilot} 33.86389 * round\n</code></pre> <p>When one of the constituing variable of a formula changed, the formula is reevaluted.</p> <p>The value of a formula can be used in a text expression as <code>${formula}</code>.</p> <p>There can only be one formula expression per activation and one formula expression per representation. (An Annunciator that has several annunciator parts can use a Formula in each of its individual part.)</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/","title":"Weather Representation Internals","text":"<p>Weather representations have been split in two components:</p> <ol> <li>Weather Data</li> <li>Representation</li> </ol> <p>Weather Data is itself a combination of two components:</p> <ol> <li>A Location, which is either fixed, or moving (aircraft position).</li> <li>The actual weather information in a coded form (METAR, TAF, SPECI\u2026)</li> </ol> <p>Location is optionally tracked with aircraft position, or dynamically defined through a (string) dataref that defines the station to use.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#weather-representation","title":"Weather Representation","text":"<p>Weather representation is responsible for creating and updating an image representation of the weather.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#textual-representation","title":"Textual Representation","text":"<p>METAR and TAF.</p> <p>For METAR, short, succinct textual representation of the weather. The background image sof the weather METAR or SPECI is a weather icon that depicts the actual weather.</p> <p>For TAF with multiple pages of forecast, each press of the icon cycles through the pages. Each forecast is a textual representation if its coded transmission.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#graphical-representation--station-plot-","title":"Graphical Representation: \u00ab\u00a0Station Plot\u00a0\u00bb","text":"<p>METAR only.</p> <p>Graphical representation is a Standard Model Plot.</p> <p>There is an \u00ab\u00a0official\u00a0\u00bb, standard Station Plot in either metric or imperial units that reproduces the above data.</p> <p>There also is a fancier, colorful modern representation with non standard information but highly practical. For example, ceiling information usually absent from Standard Model Plot. Fancier Standard Plot tries to ally conventions and iconic modern user interface elements.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#weather-data","title":"Weather Data","text":"<p>The Weather Data entity is responsible for collecting and maintaining coded weather information.</p> <p>The collection occurs at regular time interval or speed (time flows at normal speed, not accelerated or slowed down.)</p> <p>The following two events are handled \u00ab\u00a0on demand\u00a0\u00bb by the weather data service:</p> <ol> <li>Change of location.</li> <li>Change of date/time for historical METAR.</li> </ol> <p>Change to the above data may result in weather data changes, which are transmitted to weather data listeners through the <code>weather_changed()</code> function.</p> <p>Weather Data exposes information in any format that is suitable for its reprensetation. However, in the context of aeronautics, Weather Data exposes information in a standard, weather coded representation like METAR.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#data-sources","title":"Data Sources","text":"<p>As today, the following Weather Data source are available:</p> <ol> <li>Real life current coded weather as METAR or TAF.</li> <li>X-Plane \u00ab\u00a0Real Weather\u00a0\u00bb (METAR only).</li> <li>Ogimet \u00ab\u00a0historical\u00a0\u00bb (past) METAR and TAF, if available.</li> </ol>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#attributes","title":"Attributes","text":"<p>Configuration attributes.</p> <p>Global: animation frequency (<code>speed</code>)</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#location","title":"Location","text":"<p>Moving or fixed.</p> <p>If moving: How often it is checked (because it is expensive to check).</p> <p>Check = moved a certain distance, then station has changed.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#weather","title":"Weather","text":"<p>If station changed, reload.</p> <p>If expired: reload. Expired since last load.</p> <p>Real weather: aircraft or region. Always changes with aircraft position. Default is region.</p> <p>To do: Real weather from METAR in txt file in xplane folders.</p> <p>Live weather: fixed location or moving with aircraft.</p> <p>Fixed location: either supplied or guesseD from MCDU dep/arr (Toliss specific).</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#presentation","title":"Presentation","text":"<p>Colors and sizes.</p> <p>Units.</p> <p>Fancy station plot with Colors and ceiling information.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#fancy--practical--station-plot","title":"Fancy (\u00ab\u00a0Practical\u00a0\u00bb) Station Plot","text":"<p>Standard Staton Plot relies on numerous conventions and it takes a few readings before some values are naturally interpreted. In addition, throw a mix of metric (pressure) and imperial (flight levels, distance in miles) units, and the little circle of numeric values becomes tricky to read.</p> <p>Station Plot were originally targeted at map overlay, sometimes in high densities. Fewer number the better.</p> <p>This lead to the design of an equivalent circle with similar data at the same location around the circle, with the same meaning but with different units, coding, and conventions. In addition, units are often added through a simple, yet unambiguous character or sign.</p> <p>Color is also added as a supplemental information, from green, insignificant values, to red, warning ones. Each value is coded independently.</p>"},{"location":"Reference/Extending/Development/Internals/Weather%20Representation%20Internals/#examples","title":"Examples","text":"<p>Atmospheric pressure is shown explicitly like 983, 1013 or 29.92.</p> <p>Visibility is show in meter below 1000m, and in kilometer above. 60m, 600m, 6k, 12k, 30k.</p> <p>All values are shown in the same unit system, metric by default. All metric or all imperial.</p> <p>Graphical symbols remain unchanged, but sometimes to meaning of the symbol is added under the symbol with a small text.</p> <p>This undoubtedly creates a iconic image with more signs, probably unsuitable for map overlay, but easier to read and understand for occasional flight simmers.</p>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/","title":"Web Decks Internals","text":"<p>Web Decks are designed with simple standard web features, are rendered on an HTML Canvas, uses standard events to report interaction through basic JavaScript functions. The application that serves them is a very simple Flask application with Ninja2 templates. The Flask application also runs the WebSocket proxy.</p> <p></p>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#web-deck-messages","title":"Web Deck Messages","text":""},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#cockpitdecks-to-web-deck-messages","title":"Cockpitdecks to Web Deck Messages","text":""},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#send-code","title":"Send code","text":"<pre><code>{\n    \"code\": code,\n    \"deck\": name,\n    \"meta\": {\n        \"ts\": datetime.now().timestamp()\n    }\n}\n</code></pre> <p>Code is interpreted by the deck. Codes are:</p> <ul> <li>0: Display (attached) image on deck/key</li> <li>1: Reload yourself (deck)</li> <li>2: Emit (attached) sound for deck</li> </ul> <p><code>meta</code> data is a python dictionary serialized into JSON (mostly name, value pairs). It can contain any arbitrary serialisable items.</p>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#send-image","title":"Send Image","text":"<p>It can be a key image, or a \u00abhardware\u00bb image.</p> <pre><code>{\n    \"code\": 0,\n    \"deck\": name,\n    \"key\": key,\n    \"image\": base64.encodebytes(content).decode(\"ascii\"),\n    \"meta\": {\n        \"ts\": datetime.now().timestamp()\n    }\n}\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#send-sound","title":"Send Sound","text":"<p>It can be a key image, or a \u00abhardware\u00bb image.</p> <pre><code>{\n    \"code\": 2,\n    \"deck\": name,\n    \"sound\": base64.encodebytes(content).decode(\"ascii\"),\n    \"type\": \"wav\",\n    \"meta\": {\n        \"ts\": datetime.now().timestamp()\n    }\n}\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#web-decks-to-cockpitdecks-messages","title":"Web Decks to Cockpitdecks Messages","text":""},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#send-code_1","title":"Send code","text":"<pre><code>{\n    \"code\": code,\n    \"deck\": name,\n}\n</code></pre> <p>Code values:</p> <ul> <li>0: Report event (see below)</li> <li>1: New deck, expect reload/refresh data</li> </ul>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#send-event","title":"Send Event","text":"<pre><code>{\n\t\"code\": 0,\n\t\"deck\": deck,\n\t\"key\": key,\n\t\"event\": value,\n\t\"data\": data\n}\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Web%20Decks%20Internals/#web-deck-drawing","title":"Web Deck Drawing","text":"<p>Technically speaking, web decks are very simple browser entities. The web representation is an HTML Canvas. The background image of the deck is laid out as the background image of the canvas. Deck icons are images laid over the background image at precise size and positions. Nothing less, nothing more.</p> <p>Another special kind of icon images can be generated by Cockpitdecks especially for web decks. They are called hardware representations. They behave exactly like other representations, but they only exists for web decks. They usually have particular sizes and positions, and their drawing is sometimes complex.</p> <p>Web decks communicate with Cockpitdecks through standard WebSocket.</p> <p>The connection is established or re-established on startup of Cockpitdecks. Cockpitdecks is aware of the web decks connected to it and only update web decks when necessary. There should never be a need to refresh a web page containing a web deck.</p>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/","title":"Workflow for Web Deck Design","text":"<p>Here is a suggested workflow for web deck design.</p>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/#workflow","title":"Workflow","text":"<p>Ideally, X-Plane simulator should be running to get live response data.</p> <p>Get a background image. <code>PNG</code> or <code>JPEG</code> only.</p> <p>Place it in</p> <pre><code>&lt;Aircraft&gt;/deckconfig/resources/decks/images/&lt;image-name&gt;.png\n</code></pre> <p>Start cockpitdecks for that aircraft:</p> <pre><code>$ cockpitdecks-cli &lt;Aircraft&gt;\n</code></pre> <p>Cockpitdecks will start the application server, notice the available background image and Deck Designer will be available.</p>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/#deck-designer","title":"Deck Designer","text":"<p>Head to the Deck Designer page at</p> <pre><code>http://&lt;hostname&gt;:7777/designer\n</code></pre> <p>and select the above image.</p> <p>Add interactors like buttons, encoders, and hardware images. Resize interactors, position them over the background image, and name them.</p> <p>Double click inside the button to resize it.</p> <p>Click outside the button to deselect it.</p> <p>Press Delete key when selected to remove it.</p> <p>Double on the label to rename it. Press Enter to quit the edit text area.</p> <p>Save the layout. You can load it later if you wish and continue editing.</p> <p>We recommand creating a button named <code>reload</code> and place it at a convenient location on the image.</p> <p>Saving the layout will create a new Deck Type, and will add a new deck in the config.yaml file, like any other deck, and add it to the secret.yaml file as well.</p> <pre><code>&lt;Aircraft&gt;/deckconfig/resources/decks/types/&lt;image-name&gt;.json\n&lt;Aircraft&gt;/deckconfig/resources/decks/types/&lt;image-name&gt;.yaml\n</code></pre> <p>Reload the decks, which will provoke the reload of virtual web decks as well.</p> <p>Web Deck Definitions</p> <p>Web deck definitions are located either in the Cockpitdecks code or in the aircraft deckconfig folder. On page reloads, web decks definitions located in the code are not reloaded. Web deck definitions in the aircraft folder are reloaded.</p>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/#button-designer","title":"Button Designer","text":"<p>Head to the web deck home page.</p> <pre><code>http://&lt;hostname&gt;:7777/\n</code></pre> <p>Your new deck appears. In the web deck list, select the newly created deck it will open in a new window.</p> <p>Using the button designer create and test a new button for your new deck selectable at the top.</p> <p>Select the deck, give a name to a layout (default would be default if none provided), and to the page.</p> <p>If you followed our advise, there should be a button named <code>reload</code>, the label we gave it in the Deck Designer.</p> <p>Select reload as Activation.</p> <p>Select icon as Representation. Select icon named \"reload.png\".</p> <p>Press render to preview rendering.</p> <p>Press save to save the layout/page/button.</p> <p>Reload pages immediately preview the appearance on the new button.</p> <p>From now on, it is now possible to adjust any of the layout, or button definition, save them, reload and use the button.</p> <p>When happy with the final deck, I simply comment out the code of the reload button. You will need it later\u2026</p> <pre><code>index: reload\ntype: reload\nicon: reload.png\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/#a-word-of-advise","title":"A Word of Advise","text":"<p>Never ever forget that the goal of these designer tools is currently not to provide you with a final design ready to be used. One day may be. The above designer tools aim at providing you with skeleton files that contain data that is difficult to get or estimate, thereby removing numerous trial and errors attempts.</p> <p>The goal of the Deck Designer is to supply deck image positions and sizes for all items that need displaying on a web deck.</p> <p>The goal of the Button Designer is twofold:</p> <ol> <li>Help you test button design right away, viewing a button\u2019s appearance without requiring numerous \u00ab\u00a0deck reload page\u00a0\u00bb.</li> <li>Learning the button design options and capabilities without searching through the code.</li> </ol> <p>I hope both tools reach their goal and help you design buttons faster for your decks.</p> <p>One more thing\u2026</p> <p>Never ever forget enjoy flying with your home made set up.</p> <p>If Cockpitdecks crashes or is not responding, just restart it. It will restart, reconnect, and reload necessary data. If failures are persistent, just drop us a mail with a description of the problem and <code>Cockpitdecks.log</code> file.</p> <p>Now just go and take off for new adventures.</p>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/#automation","title":"Automation","text":"<p>Using an external file watcher, it is possible to provoke a deck reload each time a file has been saved, using curl(1) to post a request for page reload to Cockpitdecks. There is a handy shell script that does exactly this using nodejs nodemon utility.</p> <pre><code>$ nodemon -w aircrafts/*/deckconfig/resources/decks/types -e yaml --exec curl \"http://127.0.0.1:7777/reload-decks\"\n</code></pre>"},{"location":"Reference/Extending/Development/Internals/Workflow%20for%20Web%20Deck%20Design/#moving-on-from-there","title":"Moving on from there","text":"<p>From there one can:</p> <ul> <li>Add more buttons, encoders, hardware button.</li> <li>Adjust the layout, resize buttons, move them.</li> <li>Save the new layout.</li> <li>Define and save more button definitions.</li> <li>Reload the deck to preview.</li> </ul> <p>When the deck is completed, it is advisable to rename it.</p> <p>Change name and cross references to name in config, secret, and layout pages.</p>"}]}